Disassembly Listing for luge_IMU-UDB5
Generated From:
C:/Users/bill/Desktop/git_repos/git_luge/MultiRotor/luge_IMU-UDB5.X/dist/default/production/luge_IMU-UDB5.X.production.elf
Mar 15, 2023 4:03:05 PM

---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vzpad.s  ----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	; none...
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorZeroPad: pad with zeros the numZeros tail elements of a vector.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstV[n] = srcV[n], 0 <= n < numElems
                                                  41:    ;	dstV[n] = 0, numElems <= n < numElems+numZeros
                                                  42:    ; NOTE:
                                                  43:    ;	srcV defined AT LEAST WITHIN 0 <= n < numElems
                                                  44:    ;	dstV defined EXACTLY WITHIN 0 <= n < numElems+numZeros
                                                  45:    ;
                                                  46:    ; Input:
                                                  47:    ;	w0 = number elements in source vector to be preserved (numElems)
                                                  48:    ;	w1 = number elements to zero pad (numZeros)
                                                  49:    ;	w2 = ptr to destination vector (dstV)
                                                  50:    ;	w3 = ptr to source vector (srcV)
                                                  51:    ; Return:
                                                  52:    ;	w0 = ptr to destination vector (dstV)
                                                  53:    ;
                                                  54:    ; System resources usage:
                                                  55:    ;	{w0..w6}	used, not restored
                                                  56:    ;
                                                  57:    ; DO and REPEAT instruction usage.
                                                  58:    ;	no DO instructions
                                                  59:    ;	1 level REPEAT intruction
                                                  60:    ;
                                                  61:    ; Program words (24-bit instructions):
                                                  62:    ;	13
                                                  63:    ; plus program words from VectorCopy.
                                                  64:    ;
                                                  65:    ; Cycles (including C-function call and return overheads):
                                                  66:    ;	18 + numZeros
                                                  67:    ; plus cycles from VectorCopy.
                                                  68:    ; NOTE that the VectorCopy source code reports the number of cycles
                                                  69:    ; including 3 cycles of C-function call overhead. Thus, the number of
                                                  70:    ; actual cycles from VectorCopy to add to VectorWindow is 3 less
                                                  71:    ; than whatever number of cycles it takes a stand alone VectorCopy.
                                                  72:    ;............................................................................
                                                  73:    
                                                  74:    	; External symbols.
                                                  75:    	.extern	_VectorCopy
                                                  76:    
                                                  77:    	.global	_VectorZeroPad	; export
                                                  78:    _VectorZeroPad:
                                                  79:    
000D96  F80036     PUSH RCOUNT                    80:    	push	RCOUNT
                                                  81:    
                                                  82:    ;............................................................................
                                                  83:    
000D98  780302     MOV W2, W6                     84:    	mov	w2,w6				; save return value (dstV)
                                                  85:    
                                                  86:    	; Copy numElems from srcV to dstV.
000D9A  D00200     SL W0, W4                      87:    	sl	w0,w4				; w4 = sizeof(numElems)
000D9C  E90281     DEC W1, W5                     88:    	dec	w1,w5				; w5 = numZeros-1
000D9E  780082     MOV W2, W1                     89:    	mov	w2,w1				; w1-> dstV[0]
000DA0  780103     MOV W3, W2                     90:    	mov	w3,w2				; w2-> srcV[0]
000DA2  020BAC     CALL 0xBAC                     91:    	call _VectorCopy
                                                  92:    						; now w0-> dstV[0]
                                                  93:    	; Advance to zero padding area.
000DA6  400004     ADD W0, W4, W0                 94:    	add	w0,w4,w0			; w0-> dstV[numElems]
000DA8  200001     MOV #0x0, W1                   95:    	mov	#0,w1
000DAA  098005     REPEAT W5                      96:    	repeat	w5				; do (numZeros-1)+1 times
000DAC  781801     MOV W1, [W0++]                 97:    	mov	w1,[w0++]			; dstV[n] = 0
                                                  98:    						; w0-> dstV[n+1]
                                                  99:    
000DAE  780006     MOV W6, W0                     100:   	mov	w6,w0				; restore return value
                                                  101:   
                                                  102:   ;............................................................................
                                                  103:   
000DB0  F90036     POP RCOUNT                     104:   	pop		RCOUNT
                                                  105:   
000DB2  060000     RETURN                         106:   	return	
                                                  107:   
                                                  108:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  109:   
                                                  110:   	.end
                                                  111:   
                                                  112:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  113:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vsub.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include "dspcommon.inc"    ; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorSubtract: Vector Subtraction.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstV[n] = srcV1[n] - srcV2[n], with
                                                  41:    ;
                                                  42:    ; n in {0, 1,... , numElems-1}
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = number elements in vector(s) (numElems)
                                                  46:    ;	w1 = ptr to destination vector (dstV)
                                                  47:    ;	w2 = ptr to source one vector (srcV1)
                                                  48:    ;	w3 = ptr to source two vector (srcV2)
                                                  49:    ; Return:
                                                  50:    ;	w0 = ptr to destination vector (dstV)
                                                  51:    ;
                                                  52:    ; System resources usage:
                                                  53:    ;	{w0..w4}    used, not restored
                                                  54:    ;	 AccuA      saved, used, restored
                                                  55:    ;	 AccuB      saved, used, restored
                                                  56:    ;	 CORCON     saved, used, restored
                                                  57:    ;
                                                  58:    ; DO and REPEAT instruction usage.
                                                  59:    ;	1 level DO instruction
                                                  60:    ;	no REPEAT intructions
                                                  61:    ;
                                                  62:    ; Program words (24-bit instructions):
                                                  63:    ;	14
                                                  64:    ;
                                                  65:    ; Cycles (including C-function call and return overheads):
                                                  66:    ;	17 + 4*numElems
                                                  67:    ;............................................................................
                                                  68:    
                                                  69:    	.global _VectorSubtract ; export
                                                  70:    _VectorSubtract:
                                                  71:    
                                                  72:    ;	save the 40 bit A accumulator
000D4A  F80022     PUSH ACCA                      73:    	push    ACCAL
000D4C  F80024     PUSH ACCAH                     74:    	push    ACCAH
000D4E  F80026     PUSH ACCAU                     75:    	push    ACCAU
                                                  76:    
                                                  77:    ;	save the 40 bit B accumulator
000D50  F80028     PUSH ACCB                      78:    	push    ACCBL
000D52  F8002A     PUSH ACCBH                     79:    	push    ACCBH
000D54  F8002C     PUSH ACCBU                     80:    	push    ACCBU
                                                  81:    
                                                  82:    	; Prepare CORCON for fractional computation.
000D56  F80044     PUSH CORCON                    83:    	push    CORCON
000D58  200F04     MOV #0xF0, W4                  84:    	fractsetup  w4
                                                  85:    
                                                  86:    ;............................................................................
                                                  87:    
000D5C  780201     MOV W1, W4                     88:    	mov	w1,w4           ; save return value (dstV)
                                                  89:    
                                                  90:    ;............................................................................
                                                  91:    
                                                  92:    	; Prepare operation.
000D5E  E90000     DEC W0, W0                     93:    	dec     w0,w0       ; w0 = numElems-1
                                                  94:    
                                                  95:    ;	save the do loop registers
000D60  F80038     PUSH DCOUNT                    96:    	push    DCOUNT
000D62  F8003A     PUSH DOSTART                   97:    	push    DOSTARTL
000D64  F8003C     PUSH DOSTARTH                  98:    	push    DOSTARTH
000D66  F8003E     PUSH DOEND                     99:    	push    DOENDL
000D68  F80040     PUSH DOENDH                    100:   	push    DOENDH
                                                  101:   
                                                  102:   	; Perform operation.
000D6A  088000     DO W0, 0xD78                   103:   	do      w0,_endSub  ; { ; do (numElems-1)+1 times
                                                  104:   .ifdef PSV_ERRATA
000D6E  7802B2     MOV [W2++], W5                 105:   	mov     [w2++],w5
000D70  CA0005     LAC W5, A                      106:   	lac     w5,a        ; a  = srcV1[n]
                                                  107:   	                    ; w2-> srcV1[n+1]
000D72  7802B3     MOV [W3++], W5                 108:   	mov     [w3++],w5
000D74  CA8005     LAC W5, B                      109:   	lac     w5,b        ; b  = srcV2[n]
                                                  110:   	                    ; w3-> srcV2[n+1]
                                                  111:   .else
                                                  112:   	lac     [w2++],a    ; a  = srcV1[n]
                                                  113:   	                    ; w2-> srcV1[n+1]
                                                  114:   	lac     [w3++],b    ; b  = srcV2[n]
                                                  115:   	                    ; w3-> srcV2[n+1]
                                                  116:   .endif
000D76  CB3000     SUB A                          117:   	sub     a           ; a -= b
                                                  118:   _endSub:
000D78  CC0031     SAC A, [W1++]                  119:   	sac     a,[w1++]    ; dstV[n] = srcV1[n] - srcV2[n]
                                                  120:   
                                                  121:   ;	restore the do loop registers
000D7A  F90040     POP DOENDH                     122:   	pop     DOENDH
000D7C  F9003E     POP DOEND                      123:   	pop     DOENDL
000D7E  F9003C     POP DOSTARTH                   124:   	pop     DOSTARTH
000D80  F9003A     POP DOSTART                    125:   	pop     DOSTARTL
000D82  F90038     POP DCOUNT                     126:   	pop     DCOUNT
                                                  127:   
                                                  128:   ; }
                                                  129:   
                                                  130:   ;............................................................................
                                                  131:   
000D84  780004     MOV W4, W0                     132:   	mov     w4,w0       ; restore return value
                                                  133:   
                                                  134:   ;............................................................................
                                                  135:   
                                                  136:   	; restore CORCON.
000D86  F90044     POP CORCON                     137:   	pop     CORCON
                                                  138:   
                                                  139:   ;............................................................................
                                                  140:   
                                                  141:   ;	restore the 40 bit B accumulator
000D88  F9002C     POP ACCBU                      142:   	pop     ACCBU
000D8A  F9002A     POP ACCBH                      143:   	pop     ACCBH
000D8C  F90028     POP ACCB                       144:   	pop     ACCBL
                                                  145:   
                                                  146:   ;	restore the 40 bit A accumulator
000D8E  F90026     POP ACCAU                      147:   	pop     ACCAU
000D90  F90024     POP ACCAH                      148:   	pop     ACCAH
000D92  F90022     POP ACCA                       149:   	pop     ACCAL
                                                  150:   
000D94  060000     RETURN                         151:   	return
                                                  152:   
                                                  153:   
                                                  154:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  155:   
                                                  156:   	.end
                                                  157:   
                                                  158:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  159:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vscl.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorScale: Vector scale.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstV[n] = sclVal * srcV[n], with
                                                  41:    ;
                                                  42:    ; n in {0, 1,... , numElems-1}
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = number elements in vector(s) (numElems)
                                                  46:    ;	w1 = ptr to destination vector (dstV)
                                                  47:    ;	w2 = ptr to source vector (srcV)
                                                  48:    ;	w3 = scale value (sclVal)
                                                  49:    ; Return:
                                                  50:    ;	w0 = ptr to destination vector (dstV)
                                                  51:    ;
                                                  52:    ; System resources usage:
                                                  53:    ;	{w0..w5}	used, not restored
                                                  54:    ;	 AccuA		saved, used, restored
                                                  55:    ;	 CORCON		saved, used, restored
                                                  56:    ;
                                                  57:    ; DO and REPEAT instruction usage.
                                                  58:    ;	1 level DO instruction
                                                  59:    ;	no REPEAT intructions
                                                  60:    ;
                                                  61:    ; Program words (24-bit instructions):
                                                  62:    ;	14
                                                  63:    ;
                                                  64:    ; Cycles (including C-function call and return overheads):
                                                  65:    ;	18 + 3*numElems
                                                  66:    ;............................................................................
                                                  67:    
                                                  68:    	.global	_VectorScale	; export
                                                  69:    _VectorScale:
                                                  70:    
                                                  71:    ;	save the 40 bit A accumulator
000D0E  F80022     PUSH ACCA                      72:    	push	ACCAL
000D10  F80024     PUSH ACCAH                     73:    	push	ACCAH
000D12  F80026     PUSH ACCAU                     74:    	push	ACCAU
                                                  75:    
                                                  76:    ;............................................................................
                                                  77:    
                                                  78:    	; Save working registers.
                                                  79:    	; None to save...
                                                  80:    
                                                  81:    ;............................................................................
                                                  82:    
                                                  83:    	; Prepare CORCON for fractional computation.
000D14  F80044     PUSH CORCON                    84:    	push	CORCON
000D16  200F04     MOV #0xF0, W4                  85:    	fractsetup	w4
                                                  86:    
                                                  87:    ;............................................................................
                                                  88:    
000D1A  781F81     MOV W1, [W15++]                89:    	push	w1				; save return value (dstV)
                                                  90:    
                                                  91:    ;............................................................................
                                                  92:    
                                                  93:    	; Prepare operation.
000D1C  E90000     DEC W0, W0                     94:    	dec	w0,w0				; w0 = numElems-1
000D1E  780203     MOV W3, W4                     95:    	mov	w3,w4				; w4 = sclVal
                                                  96:    
                                                  97:    ;	save the do loop registers
000D20  F80038     PUSH DCOUNT                    98:    	push	DCOUNT
000D22  F8003A     PUSH DOSTART                   99:    	push	DOSTARTL
000D24  F8003C     PUSH DOSTARTH                  100:   	push	DOSTARTH
000D26  F8003E     PUSH DOEND                     101:   	push	DOENDL
000D28  F80040     PUSH DOENDH                    102:   	push	DOENDH
                                                  103:   
                                                  104:   	; Perform operation.
000D2A  088000     DO W0, 0xD32                   105:   	do	w0,_endScl		; {	; do (numElems-1)+1 times
000D2E  7802B2     MOV [W2++], W5                 106:   	mov	[w2++],w5			; w5 = srcV[n]
                                                  107:   						; w2-> srcV[n+1]
000D30  C00113     MPY W4*W5, A                   108:   	mpy	w4*w5,a				; a = sclVal*srcV[n]
                                                  109:   _endScl:
000D32  CD0031     SAC.R A, [W1++]                110:   	sac.r	a,[w1++]			; dstV[n] = sclVal*srcV[n]
                                                  111:   						; w2-> dstV[n+1]
                                                  112:   
                                                  113:   ;	restore the do loop registers
000D34  F90040     POP DOENDH                     114:   	pop		DOENDH
000D36  F9003E     POP DOEND                      115:   	pop		DOENDL
000D38  F9003C     POP DOSTARTH                   116:   	pop		DOSTARTH
000D3A  F9003A     POP DOSTART                    117:   	pop		DOSTARTL
000D3C  F90038     POP DCOUNT                     118:   	pop		DCOUNT
                                                  119:   
                                                  120:   ; }
                                                  121:   
                                                  122:   ;............................................................................
                                                  123:   
000D3E  78004F     MOV [--W15], W0                124:   	pop	w0				; restore return value
                                                  125:   
                                                  126:   ;............................................................................
                                                  127:   
                                                  128:   	; restore CORCON.
000D40  F90044     POP CORCON                     129:   	pop	CORCON
                                                  130:   
                                                  131:   ;............................................................................
                                                  132:   
                                                  133:   	; Restore working registers.
                                                  134:   	; None to restore...
                                                  135:   
                                                  136:   ;............................................................................
                                                  137:   
                                                  138:   ;	restore the 40 bit A accumulator
000D42  F90026     POP ACCAU                      139:   	pop		ACCAU
000D44  F90024     POP ACCAH                      140:   	pop		ACCAH
000D46  F90022     POP ACCA                       141:   	pop		ACCAL
                                                  142:   
000D48  060000     RETURN                         143:   	return	
                                                  144:   
                                                  145:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  146:   
                                                  147:   	.end
                                                  148:   
                                                  149:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  150:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vpow.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorPower: Vector Power.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	powVal = sum (srcV[n] * srcV[n]), with
                                                  41:    ;
                                                  42:    ; n in {0, 1,... , numElems-1}
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = number elements in vector(s) (numElems)
                                                  46:    ;	w1 = ptr to source vector (srcV)
                                                  47:    ; Return:
                                                  48:    ;	w0 = power value (powVal)
                                                  49:    ;
                                                  50:    ; System resources usage:
                                                  51:    ;	{w0..w2}	used, not restored
                                                  52:    ;	{w4}		used, not restored
                                                  53:    ;	 AccuA		saved, used, restored
                                                  54:    ;	 CORCON		saved, used, restored
                                                  55:    ;
                                                  56:    ; DO and REPEAT instruction usage.
                                                  57:    ;	1 level DO intructions
                                                  58:    ;	no REPEAT instruction
                                                  59:    ;
                                                  60:    ; Program words (24-bit instructions):
                                                  61:    ;	12
                                                  62:    ;
                                                  63:    ; Cycles (including C-function call and return overheads):
                                                  64:    ;	16 + 2*numElems
                                                  65:    ;............................................................................
                                                  66:    
                                                  67:    	.global	_VectorPower	; export
                                                  68:    _VectorPower:
                                                  69:    
                                                  70:    ;	save the 40 bit A accumulator
000CD6  F80022     PUSH ACCA                      71:    	push	ACCAL
000CD8  F80024     PUSH ACCAH                     72:    	push	ACCAH
000CDA  F80026     PUSH ACCAU                     73:    	push	ACCAU
                                                  74:    
                                                  75:    ;............................................................................
                                                  76:    
                                                  77:    	; Save working registers.
                                                  78:    	; None to save...
                                                  79:    
                                                  80:    ;............................................................................
                                                  81:    
                                                  82:    	; Prepare CORCON for fractional computation.
000CDC  F80044     PUSH CORCON                    83:    	push	CORCON
000CDE  200F02     MOV #0xF0, W2                  84:    	fractsetup	w2
                                                  85:    
                                                  86:    ;............................................................................
                                                  87:    
                                                  88:    	; Prepare operation.
000CE2  E90000     DEC W0, W0                     89:    	dec	w0,w0				; w0 = numElems-1
000CE4  C30112     CLR A                          90:    	clr	a				; a = 0
                                                  91:    
                                                  92:    ;	save the do loop registers
000CE6  F80038     PUSH DCOUNT                    93:    	push	DCOUNT
000CE8  F8003A     PUSH DOSTART                   94:    	push	DOSTARTL
000CEA  F8003C     PUSH DOSTARTH                  95:    	push	DOSTARTH
000CEC  F8003E     PUSH DOEND                     96:    	push	DOENDL
000CEE  F80040     PUSH DOENDH                    97:    	push	DOENDH
                                                  98:    
                                                  99:    	; Perform operation.
000CF0  088000     DO W0, 0xCF6                   100:   	do	w0,_endPow		; {	; do (numElems-1)+1 times
000CF4  780231     MOV [W1++], W4                 101:   	mov	[w1++],w4			; w4 = srcV[n]
                                                  102:   						; w1-> srcV[n+1]
                                                  103:   _endPow:
000CF6  F00110     MAC W4*W4, A                   104:   	mac	w4*w4,a				; a += srcV[n]*srcV[n]
                                                  105:   
                                                  106:   ;	restore the do loop registers
000CF8  F90040     POP DOENDH                     107:   	pop		DOENDH
000CFA  F9003E     POP DOEND                      108:   	pop		DOENDL
000CFC  F9003C     POP DOSTARTH                   109:   	pop		DOSTARTH
000CFE  F9003A     POP DOSTART                    110:   	pop		DOSTARTL
000D00  F90038     POP DCOUNT                     111:   	pop		DCOUNT
                                                  112:   
                                                  113:   ; }
                                                  114:   
                                                  115:   ;............................................................................
                                                  116:   
000D02  CD0000     SAC.R A, W0                    117:   	sac.r	a,w0				; powVal return value
                                                  118:   
                                                  119:   ;............................................................................
                                                  120:   
                                                  121:   	; restore CORCON.
000D04  F90044     POP CORCON                     122:   	pop	CORCON
                                                  123:   
                                                  124:   ;............................................................................
                                                  125:   
                                                  126:   	; Restore working registers.
                                                  127:   	; None to restore...
                                                  128:   
                                                  129:   ;............................................................................
                                                  130:   
                                                  131:   ;	restore the 40 bit A accumulator
000D06  F90026     POP ACCAU                      132:   	pop		ACCAU
000D08  F90024     POP ACCAH                      133:   	pop		ACCAH
000D0A  F90022     POP ACCA                       134:   	pop		ACCAL
                                                  135:   
000D0C  060000     RETURN                         136:   	return	
                                                  137:   
                                                  138:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  139:   
                                                  140:   	.end
                                                  141:   
                                                  142:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  143:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vneg.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorNegate: Vector Negation.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstV[n] = (-1)*srcV1[n] + 0, 0 <= n < numElems
                                                  41:    ;
                                                  42:    ; NOTE: negate of 0x8000 is 0x7FFF.
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = number elements in vector(s) (numElems)
                                                  46:    ;	w1 = ptr to destination vector (dstV)
                                                  47:    ;	w2 = ptr to source vector (srcV)
                                                  48:    ; Return:
                                                  49:    ;	w0 = ptr to destination vector (dstV)
                                                  50:    ;
                                                  51:    ; System resources usage:
                                                  52:    ;	{w0..w5}	used, not restored
                                                  53:    ;	 AccuA		saved, used, restored
                                                  54:    ;	 CORCON		saved, used, restored
                                                  55:    ;
                                                  56:    ; DO and REPEAT instruction usage.
                                                  57:    ;	1 level DO instruction
                                                  58:    ;	no REPEAT intructions
                                                  59:    ;
                                                  60:    ; Program words (24-bit instructions):
                                                  61:    ;	16
                                                  62:    ;
                                                  63:    ; Cycles (including C-function call and return overheads):
                                                  64:    ;	19 + 4*numElems
                                                  65:    ;............................................................................
                                                  66:    
                                                  67:    	.global	_VectorNegate	; export
                                                  68:    _VectorNegate:
                                                  69:    
                                                  70:    ;	save the 40 bit A accumulator
000C96  F80022     PUSH ACCA                      71:    	push	ACCAL
000C98  F80024     PUSH ACCAH                     72:    	push	ACCAH
000C9A  F80026     PUSH ACCAU                     73:    	push	ACCAU
                                                  74:    
                                                  75:    ;............................................................................
                                                  76:    
                                                  77:    	; Save working registers.
                                                  78:    	; None to save...
                                                  79:    
                                                  80:    ;............................................................................
                                                  81:    
                                                  82:    	; Prepare CORCON for fractional computation.
000C9C  F80044     PUSH CORCON                    83:    	push	CORCON
000C9E  200F03     MOV #0xF0, W3                  84:    	fractsetup	w3
                                                  85:    
                                                  86:    ;............................................................................
                                                  87:    
000CA2  780181     MOV W1, W3                     88:    	mov	w1,w3				; save return value (dstV)
                                                  89:    
                                                  90:    ;............................................................................
                                                  91:    
                                                  92:    	; Prepare operation.
000CA4  E90000     DEC W0, W0                     93:    	dec	w0,w0				; w0 = numElems-1
000CA6  280004     MOV #0x8000, W4                94:    	mov	#0x8000,w4			; w4 = -1[Q.15] (to negate)
000CA8  C30112     CLR A                          95:    	clr	a				; a  = 0
                                                  96:    
                                                  97:    ;	save the do loop registers
000CAA  F80038     PUSH DCOUNT                    98:    	push	DCOUNT
000CAC  F8003A     PUSH DOSTART                   99:    	push	DOSTARTL
000CAE  F8003C     PUSH DOSTARTH                  100:   	push	DOSTARTH
000CB0  F8003E     PUSH DOEND                     101:   	push	DOENDL
000CB2  F80040     PUSH DOENDH                    102:   	push	DOENDH
                                                  103:   
                                                  104:   	; Perform operation.
000CB4  088000     DO W0, 0xCBE                   105:   	do	w0,_endNeg		; {	; do (numElems-1)+1 times
000CB8  7802B2     MOV [W2++], W5                 106:   	mov	[w2++],w5			; w5 = srcV[n]
                                                  107:   						; w2-> srcV[n+1]
000CBA  C00112     MAC W4*W5, A                   108:   	mac	w4*w5,a				; a = (-1)*srcV[n]
000CBC  CC0031     SAC A, [W1++]                  109:   	sac	a,[w1++]			; *(dstV++) = -(*(srcV))
                                                  110:   _endNeg:
000CBE  C30112     CLR A                          111:   	clr	a				; reset
                                                  112:   
                                                  113:   ;	restore the do loop registers
000CC0  F90040     POP DOENDH                     114:   	pop		DOENDH
000CC2  F9003E     POP DOEND                      115:   	pop		DOENDL
000CC4  F9003C     POP DOSTARTH                   116:   	pop		DOSTARTH
000CC6  F9003A     POP DOSTART                    117:   	pop		DOSTARTL
000CC8  F90038     POP DCOUNT                     118:   	pop		DCOUNT
                                                  119:   
                                                  120:   ; }
                                                  121:   
                                                  122:   ;............................................................................
                                                  123:   
000CCA  780003     MOV W3, W0                     124:   	mov	w3,w0				; restore return value
                                                  125:   
                                                  126:   ;............................................................................
                                                  127:   
                                                  128:   	; restore CORCON.
000CCC  F90044     POP CORCON                     129:   	pop	CORCON
                                                  130:   
                                                  131:   ;............................................................................
                                                  132:   
                                                  133:   	; Restore working registers.
                                                  134:   	; None to restore...
                                                  135:   
                                                  136:   ;............................................................................
                                                  137:   
                                                  138:   ;	restore the 40 bit A accumulator
000CCE  F90026     POP ACCAU                      139:   	pop		ACCAU
000CD0  F90024     POP ACCAH                      140:   	pop		ACCAH
000CD2  F90022     POP ACCA                       141:   	pop		ACCAL
                                                  142:   
000CD4  060000     RETURN                         143:   	return	
                                                  144:   
                                                  145:   
                                                  146:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  147:   
                                                  148:   	.end
                                                  149:   
                                                  150:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  151:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vmul.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorMultiply: Vector Multiply.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstV[n] = srcV1[n] * srcV2[n], with
                                                  41:    ;
                                                  42:    ; n in {0, 1,... , numElems-1}
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = number elements in vector(s) (numElems)
                                                  46:    ;	w1 = ptr to destination vector (dstV)
                                                  47:    ;	w2 = ptr to source one vector (srcV1)
                                                  48:    ;	w3 = ptr to source two vector (srcV2)
                                                  49:    ; Return:
                                                  50:    ;	w0 = ptr to destination vector (dstV)
                                                  51:    ;
                                                  52:    ; System resources usage:
                                                  53:    ;	{w0..w5}	used, not restored
                                                  54:    ;	 AccuA		saved, used, restored
                                                  55:    ;	 CORCON		saved, used, restored
                                                  56:    ;
                                                  57:    ; DO and REPEAT instruction usage.
                                                  58:    ;	1 level DO instruction
                                                  59:    ;	no REPEAT intructions
                                                  60:    ;
                                                  61:    ; Program words (24-bit instructions):
                                                  62:    ;	14
                                                  63:    ;
                                                  64:    ; Cycles (including C-function call and return overheads):
                                                  65:    ;	17 + 4*numElems
                                                  66:    ;............................................................................
                                                  67:    
                                                  68:    	.global	_VectorMultiply	; export
                                                  69:    _VectorMultiply:
                                                  70:    
                                                  71:    ;	save the 40 bit A accumulator
000C5A  F80022     PUSH ACCA                      72:    	push	ACCAL
000C5C  F80024     PUSH ACCAH                     73:    	push	ACCAH
000C5E  F80026     PUSH ACCAU                     74:    	push	ACCAU
                                                  75:    
                                                  76:    ;............................................................................
                                                  77:    
                                                  78:    	; Save working registers.
                                                  79:    	; None to save...
                                                  80:    
                                                  81:    ;............................................................................
                                                  82:    
                                                  83:    	; Prepare CORCON for fractional computation.
000C60  F80044     PUSH CORCON                    84:    	push	CORCON
000C62  200F04     MOV #0xF0, W4                  85:    	fractsetup	w4
                                                  86:    
                                                  87:    ;............................................................................
                                                  88:    
000C66  781F81     MOV W1, [W15++]                89:    	push	w1				; save return value (dstV)
                                                  90:    
                                                  91:    ;............................................................................
                                                  92:    
                                                  93:    	; Prepare operation.
000C68  E90000     DEC W0, W0                     94:    	dec	w0,w0				; w0 = numElems-1
                                                  95:    
                                                  96:    ;	save the do loop registers
000C6A  F80038     PUSH DCOUNT                    97:    	push	DCOUNT
000C6C  F8003A     PUSH DOSTART                   98:    	push	DOSTARTL
000C6E  F8003C     PUSH DOSTARTH                  99:    	push	DOSTARTH
000C70  F8003E     PUSH DOEND                     100:   	push	DOENDL
000C72  F80040     PUSH DOENDH                    101:   	push	DOENDH
                                                  102:   
                                                  103:   	; Perform operation.
000C74  088000     DO W0, 0xC7E                   104:   	do	w0,_endMul		; {	; do (numElems-1)+1 times
000C78  780232     MOV [W2++], W4                 105:   	mov	[w2++],w4			; w4 = srcV[n]
                                                  106:   						; w2-> srcV[n+1]
000C7A  7802B3     MOV [W3++], W5                 107:   	mov	[w3++],w5			; w5 = srcV2[n]
                                                  108:   						; w3-> srcV2[n+1]
000C7C  C00113     MPY W4*W5, A                   109:   	mpy	w4*w5,a				; a = srcV1[n]*srcV2[n]
                                                  110:   _endMul:
000C7E  CD0031     SAC.R A, [W1++]                111:   	sac.r	a,[w1++]			; dstV[n] = srcV1[n]*srcV2[n]
                                                  112:   						; w1-> dstV[n+1]
                                                  113:   
                                                  114:   ;	restore the do loop registers
000C80  F90040     POP DOENDH                     115:   	pop		DOENDH
000C82  F9003E     POP DOEND                      116:   	pop		DOENDL
000C84  F9003C     POP DOSTARTH                   117:   	pop		DOSTARTH
000C86  F9003A     POP DOSTART                    118:   	pop		DOSTARTL
000C88  F90038     POP DCOUNT                     119:   	pop		DCOUNT
                                                  120:   
                                                  121:   ; }
                                                  122:   
                                                  123:   ;............................................................................
                                                  124:   
000C8A  78004F     MOV [--W15], W0                125:   	pop	w0				; restore return value
                                                  126:   
                                                  127:   ;............................................................................
                                                  128:   
                                                  129:   	; restore CORCON.
000C8C  F90044     POP CORCON                     130:   	pop	CORCON
                                                  131:   
                                                  132:   ;............................................................................
                                                  133:   
                                                  134:   	; Restore working registers.
                                                  135:   	; None to restore...
                                                  136:   
                                                  137:   ;............................................................................
                                                  138:   
                                                  139:   ;	restore the 40 bit A accumulator
000C8E  F90026     POP ACCAU                      140:   	pop		ACCAU
000C90  F90024     POP ACCAH                      141:   	pop		ACCAH
000C92  F90022     POP ACCA                       142:   	pop		ACCAL
                                                  143:   
000C94  060000     RETURN                         144:   	return	
                                                  145:   
                                                  146:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  147:   
                                                  148:   	.end
                                                  149:   
                                                  150:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  151:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vmin.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.list
                                                  29:    
                                                  30:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  31:    
                                                  32:    	.section .libdsp, code
                                                  33:    
                                                  34:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  35:    ;
                                                  36:    ; _VectorMin: Vector Minimum Value (and last index with minimum value).
                                                  37:    ;
                                                  38:    ; Operation:
                                                  39:    ;	minVal = min {srcV[n], n in {0, 1,...numElems-1} }
                                                  40:    ;   residually,
                                                  41:    ;	if srcV[i] = srcV[j] = minVal, and i < j, then *(minIndex) = j
                                                  42:    ;
                                                  43:    ; Input:
                                                  44:    ;	w0 = number elements in vector(s) (numElems)
                                                  45:    ;	w1 = ptr to source vector (srcV)
                                                  46:    ;	w2 = ptr to index of minimum value (&minIndex)
                                                  47:    ; Return:
                                                  48:    ;	w0 = minimum value (minVal)
                                                  49:    ;
                                                  50:    ; System resources usage:
                                                  51:    ;	{w0..w5}	used, not restored
                                                  52:    ;
                                                  53:    ; DO and REPEAT instruction usage.
                                                  54:    ;	no DO intructions
                                                  55:    ;	no REPEAT intructions
                                                  56:    ;
                                                  57:    ; Program words (24-bit instructions):
                                                  58:    ;	13
                                                  59:    ;
                                                  60:    ; Cycles (including C-function call and return overheads):
                                                  61:    ;	14			(if numElems == 1)
                                                  62:    ;	20 + 8*(numElems-2)	(if srcV[n] >= srcV[n+1], 0 <= n < numElems-1)
                                                  63:    ;	19 + 7*(numElems-2)	(if srcV[n] <  srcV[n+1], 0 <= n < numElems-1)
                                                  64:    ;............................................................................
                                                  65:    
                                                  66:    	.global	_VectorMin	; export
                                                  67:    _VectorMin:
                                                  68:    
                                                  69:    ;............................................................................
                                                  70:    
000C40  7802B1     MOV [W1++], W5                 71:    	mov	[w1++],w5			; w5 = srcV[0] (current minVal)
000C42  EB0900     CLR [W2]                       72:    	clr	[w2]				; *w2 = current min value index
000C44  E90200     DEC W0, W4                     73:    	dec	w0,w4				; w4 = numElems-1
000C46  340007     BRA LE, 0xC56                  74:    	bra	le,_endMin			; no more elements...
                                                  75:    _compare:
000C48  7801B1     MOV [W1++], W3                 76:    	mov	[w1++],w3			; w3 = srcV[n+1]
000C4A  E12803     CP.W W5, W3                    77:    	cp	w5,w3				; srcV[n] < srcV[n+1] ?
000C4C  350002     BRA LT, 0xC52                  78:    	bra	lt,_noUpdate			; yes => no update
                                                  79:    _doUpdate:					; no  => do update
000C4E  780283     MOV W3, W5                     80:    	mov	w3,w5				; w5 = (current minVal)
000C50  500904     SUB W0, W4, [W2]               81:    	sub	w0,w4,[w2]			; *w2 = current min value index
                                                  82:    _noUpdate:
000C52  E90204     DEC W4, W4                     83:    	dec	w4,w4				; w4 = numElems-n
000C54  3CFFF9     BRA GT, 0xC48                  84:    	bra	gt,_compare			; no more elements...
                                                  85:    _endMin:
000C56  780005     MOV W5, W0                     86:    	mov	w5,w0				; restore return value
                                                  87:    
                                                  88:    ;............................................................................
                                                  89:    
000C58  060000     RETURN                         90:    	return	
                                                  91:    
                                                  92:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  93:    
                                                  94:    	.end
                                                  95:    
                                                  96:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  97:    ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vmax.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.list
                                                  29:    
                                                  30:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  31:    
                                                  32:    	.section .libdsp, code
                                                  33:    
                                                  34:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  35:    ;
                                                  36:    ; _VectorMax: Vector Maximum Value (and last index with maximum value).
                                                  37:    ;
                                                  38:    ; Operation:
                                                  39:    ;	maxVal = max {srcV[n], n in {0, 1,...numElems-1} }
                                                  40:    ;   residually,
                                                  41:    ;	if srcV[i] = srcV[j] = maxVal, and i < j, then *(maxIndex) = j
                                                  42:    ;
                                                  43:    ; Input:
                                                  44:    ;	w0 = number elements in vector(s) (numElems)
                                                  45:    ;	w1 = ptr to source vector (srcV)
                                                  46:    ;	w2 = ptr to index of maximum value (&maxIndex)
                                                  47:    ; Return:
                                                  48:    ;	w0 = maximum value (maxVal)
                                                  49:    ;
                                                  50:    ; System resources usage:
                                                  51:    ;	{w0..w5}	used, not restored
                                                  52:    ;
                                                  53:    ; DO and REPEAT instruction usage.
                                                  54:    ;	no DO intructions
                                                  55:    ;	no REPEAT intructions
                                                  56:    ;
                                                  57:    ; Program words (24-bit instructions):
                                                  58:    ;	13
                                                  59:    ;
                                                  60:    ; Cycles (including C-function call and return overheads):
                                                  61:    ;	14			(if numElems == 1)
                                                  62:    ;	20 + 8*(numElems-2)	(if srcV[n] <= srcV[n+1], 0 <= n < numElems-1)
                                                  63:    ;	19 + 7*(numElems-2)	(if srcV[n] >  srcV[n+1], 0 <= n < numElems-1)
                                                  64:    ;............................................................................
                                                  65:    
                                                  66:    	.global	_VectorMax	; export
                                                  67:    _VectorMax:
                                                  68:    
                                                  69:    ;............................................................................
                                                  70:    
000C26  7802B1     MOV [W1++], W5                 71:    	mov	[w1++],w5			; w5 = srcV[0] (current maxVal)
000C28  EB0900     CLR [W2]                       72:    	clr	[w2]				; *w2 = current max value index
000C2A  E90200     DEC W0, W4                     73:    	dec	w0,w4				; w4 = numElems-1
000C2C  340007     BRA LE, 0xC3C                  74:    	bra	le,_endMax			; no more elements...
                                                  75:    _compare:
000C2E  7801B1     MOV [W1++], W3                 76:    	mov	[w1++],w3			; w3 = srcV[n+1]
000C30  E12803     CP.W W5, W3                    77:    	cp	w5,w3				; srcV[n] < srcV[n+1] ?
000C32  3C0002     BRA GT, 0xC38                  78:    	bra	gt,_noUpdate			; yes => no update
                                                  79:    _doUpdate:					; no  => do update
000C34  780283     MOV W3, W5                     80:    	mov	w3,w5				; w5 = (current maxVal)
000C36  500904     SUB W0, W4, [W2]               81:    	sub	w0,w4,[w2]			; *w2 = current max value index
                                                  82:    _noUpdate:
000C38  E90204     DEC W4, W4                     83:    	dec	w4,w4				; w4 = numElems-n
000C3A  3CFFF9     BRA GT, 0xC2E                  84:    	bra	gt,_compare			; no more elements...
                                                  85:    _endMax:
000C3C  780005     MOV W5, W0                     86:    	mov	w5,w0				; restore return value
                                                  87:    
                                                  88:    ;............................................................................
                                                  89:    
000C3E  060000     RETURN                         90:    	return	
                                                  91:    
                                                  92:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  93:    
                                                  94:    	.end
                                                  95:    
                                                  96:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  97:    ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vdot.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorDotProduct: Vector Dot Product.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dotVal = sum (srcV1[n] * srcV2[n]), with
                                                  41:    ;
                                                  42:    ; n in {0, 1,... , numElems-1}
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = number elements in vector(s) (numElems)
                                                  46:    ;	w1 = ptr to source one vector (srcV1)
                                                  47:    ;	w2 = ptr to source two vector (srcV2)
                                                  48:    ; Return:
                                                  49:    ;	w0 = dot product value (dotVal)
                                                  50:    ;
                                                  51:    ; System resources usage:
                                                  52:    ;	{w0..w2}	used, not restored
                                                  53:    ;	{w4..w5}		used, not restored
                                                  54:    ;	 AccuA		saved, used, restored
                                                  55:    ;	 CORCON		saved, used, restored
                                                  56:    ;
                                                  57:    ; DO and REPEAT instruction usage.
                                                  58:    ;	1 level DO instruction
                                                  59:    ;	no REPEAT intructions
                                                  60:    ;
                                                  61:    ; Program words (24-bit instructions):
                                                  62:    ;	13
                                                  63:    ;
                                                  64:    ; Cycles (including C-function call and return overheads):
                                                  65:    ;	17 + 3*numElems
                                                  66:    ;............................................................................
                                                  67:    
                                                  68:    	.global	_VectorDotProduct	; export
                                                  69:    _VectorDotProduct:
                                                  70:    
                                                  71:    ;	save the 40 bit A accumulator
000BEC  F80022     PUSH ACCA                      72:    	push	ACCAL
000BEE  F80024     PUSH ACCAH                     73:    	push	ACCAH
000BF0  F80026     PUSH ACCAU                     74:    	push	ACCAU
                                                  75:    
                                                  76:    
                                                  77:    ;............................................................................
                                                  78:    
                                                  79:    	; Save working registers.
                                                  80:    	; None to save...
                                                  81:    
                                                  82:    ;............................................................................
                                                  83:    
                                                  84:    	; Prepare CORCON for fractional computation.
000BF2  F80044     PUSH CORCON                    85:    	push	CORCON
000BF4  200F04     MOV #0xF0, W4                  86:    	fractsetup	w4
                                                  87:    
                                                  88:    ;............................................................................
                                                  89:    
                                                  90:    	; Prepare operation.
000BF8  E90000     DEC W0, W0                     91:    	dec	w0,w0				; w0 = numElems-1
000BFA  C30112     CLR A                          92:    	clr	a				; a = 0
                                                  93:    
                                                  94:    ;	save the do loop registers
000BFC  F80038     PUSH DCOUNT                    95:    	push	DCOUNT
000BFE  F8003A     PUSH DOSTART                   96:    	push	DOSTARTL
000C00  F8003C     PUSH DOSTARTH                  97:    	push	DOSTARTH
000C02  F8003E     PUSH DOEND                     98:    	push	DOENDL
000C04  F80040     PUSH DOENDH                    99:    	push	DOENDH
                                                  100:   
                                                  101:   	; Perform operation.
000C06  088000     DO W0, 0xC0E                   102:   	do	w0,_endDot		; {	; do (numElems-1)+1 times
000C0A  780231     MOV [W1++], W4                 103:   	mov	[w1++],w4			; w4 = srcV1[n]
                                                  104:   						; w1-> srcV1[n+1]
000C0C  7802B2     MOV [W2++], W5                 105:   	mov	[w2++],w5			; w5 = srcV2[n]
                                                  106:   						; w2-> srcV2[n+1]
                                                  107:   _endDot:
000C0E  C00112     MAC W4*W5, A                   108:   	mac	w4*w5,a				; a += srcV1[n]*srcV2[n]
                                                  109:   
                                                  110:   ;	restore the do loop registers
000C10  F90040     POP DOENDH                     111:   	pop		DOENDH
000C12  F9003E     POP DOEND                      112:   	pop		DOENDL
000C14  F9003C     POP DOSTARTH                   113:   	pop		DOSTARTH
000C16  F9003A     POP DOSTART                    114:   	pop		DOSTARTL
000C18  F90038     POP DCOUNT                     115:   	pop		DCOUNT
                                                  116:   
                                                  117:   ; }
                                                  118:   
                                                  119:   ;............................................................................
                                                  120:   
000C1A  CD0000     SAC.R A, W0                    121:   	sac.r	a,w0				; dotVal return value
                                                  122:   
                                                  123:   ;............................................................................
                                                  124:   
                                                  125:   	; restore CORCON.
000C1C  F90044     POP CORCON                     126:   	pop	CORCON
                                                  127:   
                                                  128:   ;............................................................................
                                                  129:   
                                                  130:   	; Restore working registers.
                                                  131:   	; None to restore...
                                                  132:   
                                                  133:   ;............................................................................
                                                  134:   
                                                  135:   ;	restore the 40 bit A accumulator
000C1E  F90026     POP ACCAU                      136:   	pop		ACCAU
000C20  F90024     POP ACCAH                      137:   	pop		ACCAH
000C22  F90022     POP ACCA                       138:   	pop		ACCAL
                                                  139:   
000C24  060000     RETURN                         140:   	return	
                                                  141:   
                                                  142:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  143:   
                                                  144:   	.end
                                                  145:   
                                                  146:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  147:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vcor.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorCorrelate: Vector correlation (using convolution).
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	r[n] = sum_(k=0:N-1){x[k]*y[k+n]},
                                                  41:    ; where:
                                                  42:    ;	x[n] defined for 0 <= n < N,
                                                  43:    ;	y[n] defined for 0 <= n < M, (M <= N),
                                                  44:    ;	r[n] defined for 0 <= n < N+M-1,
                                                  45:    ;
                                                  46:    ; Input:
                                                  47:    ;	w0 = N, number elements in vector one
                                                  48:    ;	w1 = M, number elements in vector two
                                                  49:    ;	w2 = r, ptr to destination vector, with R elements
                                                  50:    ;	w3 = x, ptr to source vector one
                                                  51:    ;	w4 = y, ptr to source vector two
                                                  52:    ; Return:
                                                  53:    ;	w0 = r, ptr to destination vector
                                                  54:    ;
                                                  55:    ; System resources usage:
                                                  56:    ;	{w0..w7}	used, not restored
                                                  57:    ; plus resuorces from VectorConvolve.
                                                  58:    ;
                                                  59:    ; DO and REPEAT instruction usage.
                                                  60:    ;	1 level DO instruction
                                                  61:    ;	no REPEAT intructions
                                                  62:    ; plus Do/REPEAT instructions from VectorConvolve.
                                                  63:    ;
                                                  64:    ; Program words (24-bit instructions):
                                                  65:    ;	14
                                                  66:    ; plus words from VectorConvolve
                                                  67:    ;
                                                  68:    ; Cycles (including C-function call and return overheads):
                                                  69:    ;	19 + floor(M/2)*3,
                                                  70:    ; plus cycles from VectorConvolve.
                                                  71:    ; NOTE that the VectorConvolve source code reports the number of cycles
                                                  72:    ; including 4 cycles of C-function call overhead. Thus, the number of
                                                  73:    ; actual cycles from VectorConvolve to add to VectorCorrelate is 4 less
                                                  74:    ; than whatever number of cycles it takes a stand alone VectorConvolve.
                                                  75:    ;............................................................................
                                                  76:    
                                                  77:    	; External symbols.
                                                  78:    	.extern	_VectorConvolve
                                                  79:    
                                                  80:    	.global	_VectorCorrelate	; export
                                                  81:    _VectorCorrelate:
                                                  82:    
                                                  83:    ;............................................................................
                                                  84:    
                                                  85:    	; Save working registers.
                                                  86:    	; none to save...
                                                  87:    
                                                  88:    ;............................................................................
                                                  89:    
                                                  90:    	; Compute correlation (using convolution).
                                                  91:    
                                                  92:    	; First, revert y (source vector two).
000BBC  780384     MOV W4, W7                     93:    	mov	w4,w7				; w7-> y[0]
000BBE  E90281     DEC W1, W5                     94:    	dec	w1,w5				; w5 = M-1
000BC0  D00285     SL W5, W5                      95:    	sl	w5,w5				; w5 = (M-1)*sizeof(fractional)
000BC2  420305     ADD W4, W5, W6                 96:    	add	w4,w5,w6			; w6-> y[M-1]
000BC4  D10281     LSR W1, W5                     97:    	lsr	w1,w5				; w5 = floor (M/2)
000BC6  E90285     DEC W5, W5                     98:    	dec	w5,w5				; w5 = M/2-1
                                                  99:    
                                                  100:   ;	save the do loop registers
000BC8  F80038     PUSH DCOUNT                    101:   	push	DCOUNT
000BCA  F8003A     PUSH DOSTART                   102:   	push	DOSTARTL
000BCC  F8003C     PUSH DOSTARTH                  103:   	push	DOSTARTH
000BCE  F8003E     PUSH DOEND                     104:   	push	DOENDL
000BD0  F80040     PUSH DOENDH                    105:   	push	DOENDH
                                                  106:   
000BD2  088005     DO W5, 0xBDA                   107:   	do	w5,_endRevert		; {	; do (M/2-1)+1 times
                                                  108:   						; w5 up for grabs...
000BD6  780296     MOV [W6], W5                   109:   	mov	[w6],w5				; w5 = y[M-1-n]
000BD8  781317     MOV [W7], [W6--]               110:   	mov	[w7],[w6--]			; y[n] into y[M-1-n]
                                                  111:   						; w6-> y[M-1-(n+1)]
                                                  112:   _endRevert:
000BDA  781B85     MOV W5, [W7++]                 113:   	mov	w5,[w7++]			; y[M-1-n] into y[n]
                                                  114:   						; w7-> y[n+1]
                                                  115:   ;	restore the do loop registers
000BDC  F90040     POP DOENDH                     116:   	pop		DOENDH
000BDE  F9003E     POP DOEND                      117:   	pop		DOENDL
000BE0  F9003C     POP DOSTARTH                   118:   	pop		DOSTARTH
000BE2  F9003A     POP DOSTART                    119:   	pop		DOSTARTL
000BE4  F90038     POP DCOUNT                     120:   	pop		DCOUNT
                                                  121:   
                                                  122:   ; }
                                                  123:   
                                                  124:   	; Then, invoke convolution...
000BE6  020AB4     CALL 0xAB4                     125:   	call	_VectorConvolve
                                                  126:   
                                                  127:   ;............................................................................
                                                  128:   
                                                  129:   	; Restore working registers.
                                                  130:   	; none to restore...
                                                  131:   
                                                  132:   ;............................................................................
                                                  133:   
000BEA  060000     RETURN                         134:   	return			; NOTE that w0 is set up by _VectorConvolve
                                                  135:   
                                                  136:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  137:   
                                                  138:   	.end
                                                  139:   
                                                  140:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  141:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vcopy.s  ----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	; none...
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorCopy: initialization to zero of FIR filter delay.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstV[n] = srcV[n], 0 <= n < numElems
                                                  41:    ;
                                                  42:    ; Input:
                                                  43:    ;	w0 = number elements to copy from source vector (numElems)
                                                  44:    ;	w1 = ptr to destination vector (dstV)
                                                  45:    ;	w2 = ptr to source vector (srcV)
                                                  46:    ; Return:
                                                  47:    ;	w0 = ptr to destination vector (dstV)
                                                  48:    ;
                                                  49:    ; System resources usage:
                                                  50:    ;	{w0..w3}	used, not restored
                                                  51:    ;
                                                  52:    ; DO and REPEAT instruction usage.
                                                  53:    ;	no DO instructions
                                                  54:    ;	1 level REPEAT intruction
                                                  55:    ;
                                                  56:    ; Program words (24-bit instructions):
                                                  57:    ;	6
                                                  58:    ;
                                                  59:    ; Cycles (including C-function call and return overheads):
                                                  60:    ;	12 + numElems
                                                  61:    ;............................................................................
                                                  62:    
                                                  63:    	.global	_VectorCopy	; export
                                                  64:    _VectorCopy:
                                                  65:    
000BAC  F80036     PUSH RCOUNT                    66:    	push	RCOUNT
                                                  67:    
                                                  68:    ;............................................................................
                                                  69:    
000BAE  780181     MOV W1, W3                     70:    	mov	w1,w3				; save return value (dstV)
                                                  71:    
000BB0  E90000     DEC W0, W0                     72:    	dec	w0,w0				; w0 = numElems-1
000BB2  098000     REPEAT W0                      73:    	repeat	w0				; do (numElems-1)+1 times
000BB4  7818B2     MOV [W2++], [W1++]             74:    	mov	[w2++],[w1++]			; dstV[n] = srcV[n]
                                                  75:    						; w1-> dstV[n+1]
                                                  76:    						; w2-> srcV[n+1]
                                                  77:    
000BB6  780003     MOV W3, W0                     78:    	mov	w3,w0				; restore return value
                                                  79:    
                                                  80:    ;............................................................................
                                                  81:    
000BB8  F90036     POP RCOUNT                     82:    	pop		RCOUNT
                                                  83:    
000BBA  060000     RETURN                         84:    	return	
                                                  85:    
                                                  86:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  87:    
                                                  88:    	.end
                                                  89:    
                                                  90:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  91:    ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vcon.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorConvolve: Vector convolution.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	y[n] = sum_(k=0:n){x[k]*h[n-k]},	0 <= n < M
                                                  41:    ;	y[n] = sum_(k=n-M+1:n){x[k]*h[n-k]},	M <= n < N
                                                  42:    ;	y[n] = sum_(k=n-M+1:N-1){x[k]*h[n-k]},	N <= n < N+M-1
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = N, number elements in vector one
                                                  46:    ;	w1 = M, number elements in vector two, M <= N
                                                  47:    ;	w2 = y, ptr to destination vector, with (N + M - 1) elements
                                                  48:    ;	w3 = x, ptr to source vector one
                                                  49:    ;	w4 = h, ptr to source vector two
                                                  50:    ; Return:
                                                  51:    ;	w0 = y, ptr to destination vector
                                                  52:    ;
                                                  53:    ; System resources usage:
                                                  54:    ;	{w0..w7}	used, not restored
                                                  55:    ;	{w8..w10}	saved, used, restored
                                                  56:    ;	 AccuA		saved, used, restored
                                                  57:    ;	 CORCON		saved, used, restored
                                                  58:    ;
                                                  59:    ; DO and REPEAT instruction usage.
                                                  60:    ;	2 level DO instruction
                                                  61:    ;	no REPEAT intructions
                                                  62:    ;
                                                  63:    ; Program words (24-bit instructions):
                                                  64:    ;	58
                                                  65:    ;
                                                  66:    ; Cycles (including C-function call and return overheads):
                                                  67:    ;	28 + 13*M + 6*sum_(m=1:M){m} + (N-M)*(7+3*M)	(if M < N)
                                                  68:    ;	26 + 13*M + 6*sum_(m=1:M){m}			(if M = N)
                                                  69:    ;............................................................................
                                                  70:    
                                                  71:    	.global	_VectorConvolve	; export
                                                  72:    _VectorConvolve:
                                                  73:    
                                                  74:    ;	save the 40 bit A accumulator
000AB4  F80022     PUSH ACCA                      75:    	push	ACCAL
000AB6  F80024     PUSH ACCAH                     76:    	push	ACCAH
000AB8  F80026     PUSH ACCAU                     77:    	push	ACCAU
                                                  78:    
                                                  79:    ;............................................................................
                                                  80:    
                                                  81:    	; Save working registers.
000ABA  BE9F88     MOV.D W8, [W15++]              82:    	push.d	w8				; {w8:w9} to TOS
000ABC  781F8A     MOV W10, [W15++]               83:    	push	w10				; {w10} to TOS
                                                  84:    
                                                  85:    ;............................................................................
                                                  86:    
                                                  87:    	; Prepare CORCON for fractional computation.
000ABE  F80044     PUSH CORCON                    88:    	push	CORCON
000AC0  200F07     MOV #0xF0, W7                  89:    	fractsetup	w7
                                                  90:    
                                                  91:    ;............................................................................
                                                  92:    
                                                  93:    	; Set up.
000AC4  781F82     MOV W2, [W15++]                94:    	push	w2				; save return value (y)
                                                  95:    
                                                  96:    ;............................................................................
                                                  97:    
                                                  98:    	; First stage: y[n] = sum_(k=0:n){x[k]*h[n-k]}, 0 <= n < M.
                                                  99:    
                                                  100:   	; Prepare operation.
000AC6  E90381     DEC W1, W7                     101:   	dec	w1,w7				; w7 = M-1
000AC8  EB0500     CLR W10                        102:   	clr	w10				; w10= 0
                                                  103:   
                                                  104:   ;	save the do loop registers
000ACA  F80038     PUSH DCOUNT                    105:   	push	DCOUNT
000ACC  F8003A     PUSH DOSTART                   106:   	push	DOSTARTL
000ACE  F8003C     PUSH DOSTARTH                  107:   	push	DOSTARTH
000AD0  F8003E     PUSH DOEND                     108:   	push	DOENDL
000AD2  F80040     PUSH DOENDH                    109:   	push	DOENDH
                                                  110:   
                                                  111:   	; Perform operation.
000AD4  088007     DO W7, 0xB00                   112:   	do	w7,_endOutFirst		; {	; do (M-1)+1 times
                                                  113:   
                                                  114:   	; Prepare operation.
000AD8  780403     MOV W3, W8                     115:   	mov	w3,w8				; w8-> x[0]
000ADA  780484     MOV W4, W9                     116:   	mov	w4,w9				; w9-> h[n]
000ADC  C30112     CLR A                          117:   	clr	a				; a  = 0
                                                  118:   
                                                  119:   ;	save the do loop registers
000ADE  F80038     PUSH DCOUNT                    120:   	push	DCOUNT
000AE0  F8003A     PUSH DOSTART                   121:   	push	DOSTARTL
000AE2  F8003C     PUSH DOSTARTH                  122:   	push	DOSTARTH
000AE4  F8003E     PUSH DOEND                     123:   	push	DOENDL
000AE6  F80040     PUSH DOENDH                    124:   	push	DOENDH
                                                  125:   
                                                  126:   	; Perform operation.
000AE8  08800A     DO W10, 0xAF0                  127:   	do	w10,_endInFirst		; {	; do n+1 times
000AEC  7802B8     MOV [W8++], W5                 128:   	mov	[w8++],w5			; w5 = x[k]
                                                  129:   						; w8-> x[k+1]
000AEE  780329     MOV [W9--], W6                 130:   	mov	[w9--],w6			; w6 = h[n-k]
                                                  131:   						; w9-> h[n-k-1]
                                                  132:   _endInFirst:
000AF0  C40112     MAC W5*W6, A                   133:   	mac	w5*w6,a				; a  = x[k]*h[n-k]
                                                  134:   
                                                  135:   ;	restore the do loop registers
000AF2  F90040     POP DOENDH                     136:   	pop		DOENDH
000AF4  F9003E     POP DOEND                      137:   	pop		DOENDL
000AF6  F9003C     POP DOSTARTH                   138:   	pop		DOSTARTH
000AF8  F9003A     POP DOSTART                    139:   	pop		DOSTARTL
000AFA  F90038     POP DCOUNT                     140:   	pop		DCOUNT
                                                  141:   
                                                  142:   ; }
                                                  143:   
000AFC  CD0032     SAC.R A, [W2++]                144:   	sac.r	a,[w2++]			; y[n] store
                                                  145:   
                                                  146:   	; Update for next operation.
000AFE  E88204     INC2 W4, W4                    147:   	inc2	w4,w4				; w4-> h[n+1]
                                                  148:   _endOutFirst:
000B00  E8050A     INC W10, W10                   149:   	inc	w10,w10				; w10++
                                                  150:   
                                                  151:   ;	restore the do loop registers
000B02  F90040     POP DOENDH                     152:   	pop		DOENDH
000B04  F9003E     POP DOEND                      153:   	pop		DOENDL
000B06  F9003C     POP DOSTARTH                   154:   	pop		DOSTARTH
000B08  F9003A     POP DOSTART                    155:   	pop		DOSTARTL
000B0A  F90038     POP DCOUNT                     156:   	pop		DCOUNT
                                                  157:   
                                                  158:   ; }
                                                  159:   
                                                  160:   	; Update for next stage.
000B0C  E98204     DEC2 W4, W4                    161:   	dec2	w4,w4				; w4-> h[M-1]
000B0E  E88183     INC2 W3, W3                    162:   	inc2	w3,w3				; w3-> x[1]
                                                  163:   
                                                  164:   	; Second stage: y[n] = sum_(k=n-M+1:n){x[k]*h[n-k]}, M <= n < N. 
                                                  165:   	; ONLY if M < N!!!
                                                  166:   
                                                  167:   	; Prepare operation.
000B10  500501     SUB W0, W1, W10                168:   	sub	w0,w1,w10			; w10= N-M
000B12  340021     BRA LE, 0xB56                  169:   	bra	le,_begThird			; M == N (skip second stage)
000B14  E9050A     DEC W10, W10                   170:   	dec	w10,w10				; w10= N-M-1
                                                  171:   
                                                  172:   ;	save the do loop registers
000B16  F80038     PUSH DCOUNT                    173:   	push	DCOUNT
000B18  F8003A     PUSH DOSTART                   174:   	push	DOSTARTL
000B1A  F8003C     PUSH DOSTARTH                  175:   	push	DOSTARTH
000B1C  F8003E     PUSH DOEND                     176:   	push	DOENDL
000B1E  F80040     PUSH DOENDH                    177:   	push	DOENDH
                                                  178:   
                                                  179:   	; Perform operation.
000B20  08800A     DO W10, 0xB4A                  180:   	do	w10,_endOutSecond	; {	; do (N-M-1)+1 times
                                                  181:   
                                                  182:   	; Prepare operation.
000B24  780403     MOV W3, W8                     183:   	mov	w3,w8				; w8-> x[k]
000B26  780484     MOV W4, W9                     184:   	mov	w4,w9				; w9-> h[M-1]
000B28  C30112     CLR A                          185:   	clr	a				; a  = 0
                                                  186:   
                                                  187:   ;	save the do loop registers
000B2A  F80038     PUSH DCOUNT                    188:   	push	DCOUNT
000B2C  F8003A     PUSH DOSTART                   189:   	push	DOSTARTL
000B2E  F8003C     PUSH DOSTARTH                  190:   	push	DOSTARTH
000B30  F8003E     PUSH DOEND                     191:   	push	DOENDL
000B32  F80040     PUSH DOENDH                    192:   	push	DOENDH
                                                  193:   
                                                  194:   	; Perform operation.
000B34  088007     DO W7, 0xB3C                   195:   	do	w7,_endInSecond		; {	; do (M-1)+1 times
000B38  7802B8     MOV [W8++], W5                 196:   	mov	[w8++],w5			; w5 = x[k]
                                                  197:   						; w8-> x[k+1]
000B3A  780329     MOV [W9--], W6                 198:   	mov	[w9--],w6			; w6 = h[n-k]
                                                  199:   						; w9-> h[n-k-1]
                                                  200:   _endInSecond:
000B3C  C40112     MAC W5*W6, A                   201:   	mac	w5*w6,a				; a  = x[k]*h[n-k]
                                                  202:   
                                                  203:   ;	restore the do loop registers
000B3E  F90040     POP DOENDH                     204:   	pop		DOENDH
000B40  F9003E     POP DOEND                      205:   	pop		DOENDL
000B42  F9003C     POP DOSTARTH                   206:   	pop		DOSTARTH
000B44  F9003A     POP DOSTART                    207:   	pop		DOSTARTL
000B46  F90038     POP DCOUNT                     208:   	pop		DCOUNT
                                                  209:   
                                                  210:   ; }
                                                  211:   
000B48  CD0032     SAC.R A, [W2++]                212:   	sac.r	a,[w2++]			; y[n] store
                                                  213:   
                                                  214:   	; Update for next operation.
                                                  215:   _endOutSecond:
000B4A  E88183     INC2 W3, W3                    216:   	inc2	w3,w3				; w3-> x[k]
                                                  217:   
                                                  218:   ;	restore the do loop registers
000B4C  F90040     POP DOENDH                     219:   	pop		DOENDH
000B4E  F9003E     POP DOEND                      220:   	pop		DOENDL
000B50  F9003C     POP DOSTARTH                   221:   	pop		DOSTARTH
000B52  F9003A     POP DOSTART                    222:   	pop		DOSTARTL
000B54  F90038     POP DCOUNT                     223:   	pop		DCOUNT
                                                  224:   
                                                  225:   ; }
                                                  226:   
                                                  227:   	; Third stage: y[n] = sum_(k=n-M+1:N-1){x[k]*h[n-k]}, N <= n < N+M-1.
                                                  228:   	; ONLY if M > 1!!!
                                                  229:   
                                                  230:   _begThird:
                                                  231:   	; Prepare operation.
000B56  E90387     DEC W7, W7                     232:   	dec	w7,w7				; w7 = (M-1)-1
000B58  350021     BRA LT, 0xB9C                  233:   	bra	lt,_noMore			; M == 1 (skip third stage)
                                                  234:   
                                                  235:   ;	save the do loop registers
000B5A  F80038     PUSH DCOUNT                    236:   	push	DCOUNT
000B5C  F8003A     PUSH DOSTART                   237:   	push	DOSTARTL
000B5E  F8003C     PUSH DOSTARTH                  238:   	push	DOSTARTH
000B60  F8003E     PUSH DOEND                     239:   	push	DOENDL
000B62  F80040     PUSH DOENDH                    240:   	push	DOENDH
                                                  241:   
                                                  242:   	; Perform operation.
000B64  088007     DO W7, 0xB90                   243:   	do	w7,_endOutThird		; {	; do (M-2)+1 times
                                                  244:   
                                                  245:   	; Prepare operation.
000B68  780403     MOV W3, W8                     246:   	mov	w3,w8				; w8-> x[k]
000B6A  780484     MOV W4, W9                     247:   	mov	w4,w9				; w9-> h[M-1]
000B6C  C30112     CLR A                          248:   	clr	a				; a  = 0
                                                  249:   
                                                  250:   ;	save the do loop registers
000B6E  F80038     PUSH DCOUNT                    251:   	push	DCOUNT
000B70  F8003A     PUSH DOSTART                   252:   	push	DOSTARTL
000B72  F8003C     PUSH DOSTARTH                  253:   	push	DOSTARTH
000B74  F8003E     PUSH DOEND                     254:   	push	DOENDL
000B76  F80040     PUSH DOENDH                    255:   	push	DOENDH
                                                  256:   
                                                  257:   	; Perform operation.
000B78  088007     DO W7, 0xB80                   258:   	do	w7,_endInThird		; {	; do N+M-1-n times
000B7C  7802B8     MOV [W8++], W5                 259:   	mov	[w8++],w5			; w5 = x[k]
                                                  260:   						; w8-> x[k+1]
000B7E  780329     MOV [W9--], W6                 261:   	mov	[w9--],w6			; w6 = h[n-k]
                                                  262:   						; w9-> h[n-k-1]
                                                  263:   _endInThird:
000B80  C40112     MAC W5*W6, A                   264:   	mac	w5*w6,a				; a  = x[k]*h[n-k]
                                                  265:   
                                                  266:   ;	restore the do loop registers
000B82  F90040     POP DOENDH                     267:   	pop		DOENDH
000B84  F9003E     POP DOEND                      268:   	pop		DOENDL
000B86  F9003C     POP DOSTARTH                   269:   	pop		DOSTARTH
000B88  F9003A     POP DOSTART                    270:   	pop		DOSTARTL
000B8A  F90038     POP DCOUNT                     271:   	pop		DCOUNT
                                                  272:   
                                                  273:   ; }
                                                  274:   
000B8C  CD0032     SAC.R A, [W2++]                275:   	sac.r	a,[w2++]			; y[n] store
                                                  276:   
                                                  277:   	; Update for next operation.
000B8E  E88183     INC2 W3, W3                    278:   	inc2	w3,w3				; w3-> x[k]
                                                  279:   _endOutThird:
000B90  E90387     DEC W7, W7                     280:   	dec	w7,w7				; w7--
                                                  281:   
                                                  282:   ;	restore the do loop registers
000B92  F90040     POP DOENDH                     283:   	pop		DOENDH
000B94  F9003E     POP DOEND                      284:   	pop		DOENDL
000B96  F9003C     POP DOSTARTH                   285:   	pop		DOSTARTH
000B98  F9003A     POP DOSTART                    286:   	pop		DOSTARTL
000B9A  F90038     POP DCOUNT                     287:   	pop		DCOUNT
                                                  288:   
                                                  289:   ; }
                                                  290:   
                                                  291:   _noMore:
                                                  292:   ;............................................................................
                                                  293:   
000B9C  78004F     MOV [--W15], W0                294:   	pop	w0				; restore return value
                                                  295:   
                                                  296:   ;............................................................................
                                                  297:   
                                                  298:   	; Restore CORCON.
000B9E  F90044     POP CORCON                     299:   	pop	CORCON
                                                  300:   
                                                  301:   ;............................................................................
                                                  302:   
                                                  303:   	; Restore working registers.
000BA0  78054F     MOV [--W15], W10               304:   	pop	w10				; {w10} from TOS
000BA2  BE044F     MOV.D [--W15], W8              305:   	pop.d	w8				; {w8:w9} from TOS
                                                  306:   
                                                  307:   ;............................................................................
                                                  308:   
                                                  309:   ;	restore the 40 bit A accumulator
000BA4  F90026     POP ACCAU                      310:   	pop		ACCAU
000BA6  F90024     POP ACCAH                      311:   	pop		ACCAH
000BA8  F90022     POP ACCA                       312:   	pop		ACCAL
                                                  313:   
000BAA  060000     RETURN                         314:   	return	
                                                  315:   
                                                  316:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  317:   
                                                  318:   	.end
                                                  319:   
                                                  320:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  321:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/vadd.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include "dspcommon.inc"    ; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _VectorAdd: Vector Addition.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstV[n] = srcV1[n] + srcV2[n], with
                                                  41:    ;
                                                  42:    ; n in {0, 1,... , numElems-1}
                                                  43:    ;
                                                  44:    ; Input:
                                                  45:    ;	w0 = number elements in vector(s) (numElems)
                                                  46:    ;	w1 = ptr to destination vector (dstV)
                                                  47:    ;	w2 = ptr to source one vector (srcV1)
                                                  48:    ;	w3 = ptr to source two vector (srcV2)
                                                  49:    ; Return:
                                                  50:    ;	w0 = ptr to destination vector (dstV)
                                                  51:    ;
                                                  52:    ; System resources usage:
                                                  53:    ;	{w0..w4}    used, not restored
                                                  54:    ;	 AccuA      saved, used, restored
                                                  55:    ;	 CORCON     saved, used, restored
                                                  56:    ;
                                                  57:    ; DO and REPEAT instruction usage.
                                                  58:    ;	1 level DO instruction
                                                  59:    ;	no REPEAT intructions
                                                  60:    ;
                                                  61:    ; Program words (24-bit instructions):
                                                  62:    ;	13
                                                  63:    ;
                                                  64:    ; Cycles (including C-function call and return overheads):
                                                  65:    ;	17 + 3*numElems
                                                  66:    ;............................................................................
                                                  67:    
                                                  68:    	.global _VectorAdd  ; export
                                                  69:    _VectorAdd:
                                                  70:    
                                                  71:    ;	save the 40 bit A accumulator
000A76  F80022     PUSH ACCA                      72:    	push    ACCAL
000A78  F80024     PUSH ACCAH                     73:    	push    ACCAH
000A7A  F80026     PUSH ACCAU                     74:    	push    ACCAU
                                                  75:    
                                                  76:    ;............................................................................
                                                  77:    
                                                  78:    	; Prepare CORCON for fractional computation.
000A7C  F80044     PUSH CORCON                    79:    	push     CORCON
000A7E  200F04     MOV #0xF0, W4                  80:    	fractsetup  w4
                                                  81:    
                                                  82:    ;............................................................................
                                                  83:    
000A82  780201     MOV W1, W4                     84:    	mov      w1,w4      ; save return value (dstV)
                                                  85:    
                                                  86:    ;............................................................................
                                                  87:    
                                                  88:    	; Prepare operation.
000A84  E90000     DEC W0, W0                     89:    	dec     w0,w0       ; w0 = numElems-1
                                                  90:    
                                                  91:    ;	save the do loop registers
000A86  F80038     PUSH DCOUNT                    92:    	push    DCOUNT
000A88  F8003A     PUSH DOSTART                   93:    	push    DOSTARTL
000A8A  F8003C     PUSH DOSTARTH                  94:    	push    DOSTARTH
000A8C  F8003E     PUSH DOEND                     95:    	push    DOENDL
000A8E  F80040     PUSH DOENDH                    96:    	push    DOENDH
                                                  97:    
                                                  98:    	; Perform operation.
000A90  088000     DO W0, 0xA9C                   99:    	do      w0,_endAdd  ; { ; do (numElems-1)+1 times
                                                  100:   .ifdef PSV_ERRATA
000A94  7802B2     MOV [W2++], W5                 101:   	mov     [w2++],w5
000A96  CA0005     LAC W5, A                      102:   	lac     w5,a        ; a  = srcV1[n]
                                                  103:   	                    ; w2-> srcV1[n+1]
000A98  7802B3     MOV [W3++], W5                 104:   	mov     [w3++],w5
000A9A  C90005     ADD W5, A                      105:   	add     w5,a        ; a += srcV2[n]
                                                  106:   	                    ; w3-> srcV2[n+1]
                                                  107:   .else
                                                  108:   	lac     [w2++],a    ; a  = srcV1[n]
                                                  109:   	                    ; w2-> srcV1[n+1]
                                                  110:   	add     [w3++],a    ; a += srcV2[n]
                                                  111:   	                    ; w3-> srcV2[n+1]
                                                  112:   .endif
                                                  113:   _endAdd:
000A9C  CC0031     SAC A, [W1++]                  114:   	sac      a,[w1++]   ; dstV[n] = srcV1[n] + srcV2[n]
                                                  115:   
                                                  116:   ;	restore the do loop registers
000A9E  F90040     POP DOENDH                     117:   	pop     DOENDH
000AA0  F9003E     POP DOEND                      118:   	pop     DOENDL
000AA2  F9003C     POP DOSTARTH                   119:   	pop     DOSTARTH
000AA4  F9003A     POP DOSTART                    120:   	pop     DOSTARTL
000AA6  F90038     POP DCOUNT                     121:   	pop     DCOUNT
                                                  122:   
                                                  123:   ; }
                                                  124:   
                                                  125:   ;............................................................................
                                                  126:   
000AA8  780004     MOV W4, W0                     127:   	mov     w4,w0       ; restore return value
                                                  128:   
                                                  129:   ;............................................................................
                                                  130:   
                                                  131:   	; restore CORCON.
000AAA  F90044     POP CORCON                     132:   	pop     CORCON
                                                  133:   
                                                  134:   ;............................................................................
                                                  135:   
                                                  136:   ;	restore the 40 bit A accumulator
000AAC  F90026     POP ACCAU                      137:   	pop     ACCAU
000AAE  F90024     POP ACCAH                      138:   	pop     ACCAH
000AB0  F90022     POP ACCA                       139:   	pop     ACCAL
                                                  140:   
000AB2  060000     RETURN                         141:   	return
                                                  142:   
                                                  143:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  144:   
                                                  145:   	.end
                                                  146:   
                                                  147:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  148:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/mtrp.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.list
                                                  29:    
                                                  30:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  31:    
                                                  32:    	.section .libdsp, code
                                                  33:    
                                                  34:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  35:    ;
                                                  36:    ; _MatrixTranspose: Matrix transposition.
                                                  37:    ;
                                                  38:    ; Operation:
                                                  39:    ;	dstM[i][j] = srcM[j][i]
                                                  40:    ;
                                                  41:    ; Input:
                                                  42:    ;	w0 = number rows in source matrix (numRows)
                                                  43:    ;	w1 = number cols in source matrix (numCols)
                                                  44:    ;	w2 = ptr to destination matrix (dstM)
                                                  45:    ;	w3 = ptr to source matrix (srcM)
                                                  46:    ; Return:
                                                  47:    ;	w0 = ptr to destination matrix (dstM)
                                                  48:    ;
                                                  49:    ; System resources usage:
                                                  50:    ;	{w0..w5}	used, not restored
                                                  51:    ;
                                                  52:    ; DO and REPEAT instruction usage.
                                                  53:    ;	2 level DO instruction
                                                  54:    ;	no REPEAT intructions
                                                  55:    ;
                                                  56:    ; Program words (24-bit instructions):
                                                  57:    ;	14
                                                  58:    ;
                                                  59:    ; Cycles (including C-function call and return overheads):
                                                  60:    ;	16 + numCols*(6 + (numRows-1)*3)
                                                  61:    ;............................................................................
                                                  62:    
                                                  63:    	.global	_MatrixTranspose	; export
                                                  64:    _MatrixTranspose:
                                                  65:    
                                                  66:    ;............................................................................
                                                  67:    
000A2E  780282     MOV W2, W5                     68:    	mov	w2,w5				; save return value (dstV)
                                                  69:    
                                                  70:    ;............................................................................
                                                  71:    
                                                  72:    	; Prepare operation.
000A30  E90000     DEC W0, W0                     73:    	dec	w0,w0				; w0 = numRows-1
000A32  E90201     DEC W1, W4                     74:    	dec	w1,w4				; w4 = numCols-1
000A34  408081     ADD W1, W1, W1                 75:    	add	w1,w1,w1			; w1 = sizeof (Rows)
                                                  76:    
                                                  77:    	; Perform operation.
                                                  78:    
                                                  79:    ;	save the do loop registers
000A36  F80038     PUSH DCOUNT                    80:    	push	DCOUNT
000A38  F8003A     PUSH DOSTART                   81:    	push	DOSTARTL
000A3A  F8003C     PUSH DOSTARTH                  82:    	push	DOSTARTH
000A3C  F8003E     PUSH DOEND                     83:    	push	DOENDL
000A3E  F80040     PUSH DOENDH                    84:    	push	DOENDH
                                                  85:    
000A40  088004     DO W4, 0xA66                   86:    	do	w4,_endCols		; {	; do (numCols-1)+1 times
000A44  780203     MOV W3, W4                     87:    	mov	w3,w4				; w4-> srcM[0][c]
                                                  88:    
                                                  89:    ;	save the do loop registers
000A46  F80038     PUSH DCOUNT                    90:    	push	DCOUNT
000A48  F8003A     PUSH DOSTART                   91:    	push	DOSTARTL
000A4A  F8003C     PUSH DOSTARTH                  92:    	push	DOSTARTH
000A4C  F8003E     PUSH DOEND                     93:    	push	DOENDL
000A4E  F80040     PUSH DOENDH                    94:    	push	DOENDH
                                                  95:    
000A50  088000     DO W0, 0xA56                   96:    	do	w0,_endRows		; {	; do (numRows-1)+1 times
000A54  781914     MOV [W4], [W2++]               97:    	mov	[w4],[w2++]			; dstM[c][r] = srcM[r][c]
                                                  98:    							; w2-> dstM[c][r+1]
                                                  99:    _endRows:
000A56  420201     ADD W4, W1, W4                 100:   	add	w4,w1,w4			; w4-> srcM[r+1][c]
                                                  101:   
                                                  102:   ;	restore the do loop registers
000A58  F90040     POP DOENDH                     103:   	pop		DOENDH
000A5A  F9003E     POP DOEND                      104:   	pop		DOENDL
000A5C  F9003C     POP DOSTARTH                   105:   	pop		DOSTARTH
000A5E  F9003A     POP DOSTART                    106:   	pop		DOSTARTL
000A60  F90038     POP DCOUNT                     107:   	pop		DCOUNT
                                                  108:   
000A62  000000     NOP                            109:   	nop
000A64  E88183     INC2 W3, W3                    110:   	inc2	w3,w3			; w3-> srcM[0][c+1]
                                                  111:   _endCols:; }
000A66  000000     NOP                            112:   	nop
                                                  113:   ;	restore the do loop registers
000A68  F90040     POP DOENDH                     114:   	pop		DOENDH
000A6A  F9003E     POP DOEND                      115:   	pop		DOENDL
000A6C  F9003C     POP DOSTARTH                   116:   	pop		DOSTARTH
000A6E  F9003A     POP DOSTART                    117:   	pop		DOSTARTL
000A70  F90038     POP DCOUNT                     118:   	pop		DCOUNT
                                                  119:   
                                                  120:   ; }
                                                  121:   
                                                  122:   ;............................................................................
                                                  123:   
000A72  780005     MOV W5, W0                     124:   	mov	w5,w0				; restore return value
                                                  125:   
                                                  126:   ;............................................................................
                                                  127:   
000A74  060000     RETURN                         128:   	return	
                                                  129:   
                                                  130:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  131:   
                                                  132:   	.end
                                                  133:   
                                                  134:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  135:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/msub.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include "dspcommon.inc"    ; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _MatrixSubtract: Matrix subtraction.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstM[i][j] = srcM1[i][j] - srcM2[i][j]
                                                  41:    ;
                                                  42:    ; Input:
                                                  43:    ;	w0 = number rows in source matrix (numRows)
                                                  44:    ;	w1 = number cols in source matrix (numCols)
                                                  45:    ;	w2 = ptr to destination matrix (dstM)
                                                  46:    ;	w3 = ptr to source one matrix (srcM1)
                                                  47:    ;	w4 = ptr to source two matrix (srcM2)
                                                  48:    ; Return:
                                                  49:    ;	w0 = ptr to destination matrix (dstM)
                                                  50:    ;
                                                  51:    ; System resources usage:
                                                  52:    ;	{w0..w4}    used, not restored
                                                  53:    ;	 AccuA      saved, used, restored
                                                  54:    ;	 AccuB      saved, used, restored
                                                  55:    ;	 CORCON     saved, used, restored
                                                  56:    ;	 DO         saved, used, restored
                                                  57:    ;
                                                  58:    ; DO and REPEAT instruction usage.
                                                  59:    ;	1 level DO instruction
                                                  60:    ;	no REPEAT intructions
                                                  61:    ;
                                                  62:    ; Program words (24-bit instructions):
                                                  63:    ;	15
                                                  64:    ;
                                                  65:    ; Cycles (including C-function call and return overheads):
                                                  66:    ;	20 + 4*(numRows*numCols)
                                                  67:    ;............................................................................
                                                  68:    
                                                  69:    	.global	_MatrixSubtract	; export
                                                  70:    _MatrixSubtract:
                                                  71:    
                                                  72:    ;	save the 40 bit A accumulator
0009E0  F80022     PUSH ACCA                      73:    	push    ACCAL
0009E2  F80024     PUSH ACCAH                     74:    	push    ACCAH
0009E4  F80026     PUSH ACCAU                     75:    	push    ACCAU
                                                  76:    
                                                  77:    ;	save the 40 bit B accumulator
0009E6  F80028     PUSH ACCB                      78:    	push    ACCBL
0009E8  F8002A     PUSH ACCBH                     79:    	push    ACCBH
0009EA  F8002C     PUSH ACCBU                     80:    	push    ACCBU
                                                  81:    
                                                  82:    ;............................................................................
                                                  83:    
                                                  84:    	; Prepare operation.
0009EC  B80001     MUL.UU W0, W1, W0              85:    	mul.uu  w0,w1,w0    ; w0 = numRows*numCols
                                                  86:    	                    ; w1 available for reuse
0009EE  E90000     DEC W0, W0                     87:    	dec     w0,w0       ; w0 = num elements-1
                                                  88:    
                                                  89:    ;............................................................................
                                                  90:    
                                                  91:    	; Prepare CORCON for fractional computation.
0009F0  F80044     PUSH CORCON                    92:    	push    CORCON
0009F2  200F01     MOV #0xF0, W1                  93:    	fractsetup  w1
                                                  94:    
                                                  95:    ;............................................................................
                                                  96:    
0009F6  780082     MOV W2, W1                     97:    	mov     w2,w1       ; save return value (dstV)
                                                  98:    
                                                  99:    ;............................................................................
                                                  100:   
                                                  101:   ;	save the do loop registers
0009F8  F80038     PUSH DCOUNT                    102:   	push    DCOUNT
0009FA  F8003A     PUSH DOSTART                   103:   	push    DOSTARTL
0009FC  F8003C     PUSH DOSTARTH                  104:   	push    DOSTARTH
0009FE  F8003E     PUSH DOEND                     105:   	push    DOENDL
000A00  F80040     PUSH DOENDH                    106:   	push    DOENDH
                                                  107:   
                                                  108:   	; Perform operation.
000A02  088000     DO W0, 0xA10                   109:   	do      w0,_endSub  ; { ; do (num elems-1)+1 times
                                                  110:   .ifdef PSV_ERRATA
000A06  7802B3     MOV [W3++], W5                 111:   	mov     [w3++],w5
000A08  CA0005     LAC W5, A                      112:   	lac     w5,a        ; a  = srcM1[r][c]
                                                  113:   	                    ; w3-> srcM1[r][c+1]
000A0A  7802B4     MOV [W4++], W5                 114:   	mov     [w4++],w5
000A0C  CA8005     LAC W5, B                      115:   	lac     w5,b        ; b  = srcM2[r][c]
                                                  116:   	                    ; w4-> srcM2[r][c+1]
                                                  117:   .else
                                                  118:   	lac     [w3++],a    ; a  = srcM1[r][c]
                                                  119:   	                    ; w3-> srcM1[r][c+1]
                                                  120:   	lac     [w4++],b    ; b  = srcM2[r][c]
                                                  121:   	                    ; w4-> srcM2[r][c+1]
                                                  122:   .endif
000A0E  CB3000     SUB A                          123:   	sub     a           ; a += b
                                                  124:   _endSub:
000A10  CC0032     SAC A, [W2++]                  125:   	sac     a,[w2++]    ; dstM[n] =
                                                  126:   	                    ;    srcM1[r][c] - srcM2[r][c]
                                                  127:   	                    ; w2-> dstM[r][c+1]
                                                  128:   
                                                  129:   ;	restore the do loop registers
000A12  F90040     POP DOENDH                     130:   	pop     DOENDH
000A14  F9003E     POP DOEND                      131:   	pop     DOENDL
000A16  F9003C     POP DOSTARTH                   132:   	pop     DOSTARTH
000A18  F9003A     POP DOSTART                    133:   	pop     DOSTARTL
000A1A  F90038     POP DCOUNT                     134:   	pop     DCOUNT
                                                  135:   
                                                  136:   ; }
                                                  137:   
                                                  138:   ;............................................................................
                                                  139:   
000A1C  780001     MOV W1, W0                     140:   	mov     w1,w0          ; restore return value
                                                  141:   
                                                  142:   ;............................................................................
                                                  143:   
                                                  144:   	; restore CORCON.
000A1E  F90044     POP CORCON                     145:   	pop     CORCON
                                                  146:   
                                                  147:   ;............................................................................
                                                  148:   
                                                  149:   ;	restore the 40 bit B accumulator
000A20  F9002C     POP ACCBU                      150:   	pop     ACCBU
000A22  F9002A     POP ACCBH                      151:   	pop     ACCBH
000A24  F90028     POP ACCB                       152:   	pop     ACCBL
                                                  153:   
                                                  154:   ;	restore the 40 bit A accumulator
000A26  F90026     POP ACCAU                      155:   	pop     ACCAU
000A28  F90024     POP ACCAH                      156:   	pop     ACCAH
000A2A  F90022     POP ACCA                       157:   	pop     ACCAL
                                                  158:   
000A2C  060000     RETURN                         159:   	return
                                                  160:   
                                                  161:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  162:   
                                                  163:   	.end
                                                  164:   
                                                  165:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  166:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/mscl.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _MatrixScale: Matrix scale.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstM[i][j] = sclVal * srcM[i][j]
                                                  41:    ;
                                                  42:    ; Input:
                                                  43:    ;	w0 = number rows in source matrix (numRows)
                                                  44:    ;	w1 = number cols in source matrix (numCols)
                                                  45:    ;		(NOTE: numRows*numCols < 2^14)
                                                  46:    ;	w2 = ptr to destination matrix (dstM)
                                                  47:    ;	w3 = ptr to source matrix (srcM)
                                                  48:    ;	w4 = scale value (sclVal)
                                                  49:    ; Return:
                                                  50:    ;	w0 = ptr to destination matrix (dstM)
                                                  51:    ;
                                                  52:    ; System resources usage:
                                                  53:    ;	{w0..w5}	used, not restored
                                                  54:    ;	 AccuA		saved, used, restored
                                                  55:    ;	 CORCON		saved, used, restored
                                                  56:    ;	 DO			saved, used, restored
                                                  57:    ;
                                                  58:    ; DO and REPEAT instruction usage.
                                                  59:    ;	1 level DO instruction
                                                  60:    ;	no REPEAT intructions
                                                  61:    ;
                                                  62:    ; Program words (24-bit instructions):
                                                  63:    ;	14
                                                  64:    ;
                                                  65:    ; Cycles (including C-function call and return overheads):
                                                  66:    ;	20 + 3*(numRows*numCols)
                                                  67:    ;............................................................................
                                                  68:    
                                                  69:    	.global	_MatrixScale	; export
                                                  70:    _MatrixScale:
                                                  71:    
                                                  72:    ;	save the 40 bit A accumulator
0009A4  F80022     PUSH ACCA                      73:    	push	ACCAL
0009A6  F80024     PUSH ACCAH                     74:    	push	ACCAH
0009A8  F80026     PUSH ACCAU                     75:    	push	ACCAU
                                                  76:    
                                                  77:    
                                                  78:    ;............................................................................
                                                  79:    
                                                  80:    	; Save working registers.
                                                  81:    	; None to save...
                                                  82:    
                                                  83:    ;............................................................................
                                                  84:    
                                                  85:    	; Prepare CORCON for fractional computation.
0009AA  F80044     PUSH CORCON                    86:    	push	CORCON
0009AC  200F05     MOV #0xF0, W5                  87:    	fractsetup	w5
                                                  88:    
                                                  89:    ;............................................................................
                                                  90:    
                                                  91:    	; Prepare operation.
0009B0  B80001     MUL.UU W0, W1, W0              92:    	mul.uu	w0,w1,w0			; w0 = numRows*numCols
0009B2  E90000     DEC W0, W0                     93:    	dec	w0,w0				; w0 = num elements-1
                                                  94:    						; w4 = sclVal from input
                                                  95:    
0009B4  780082     MOV W2, W1                     96:    	mov	w2,w1				; save return value (dstV)
                                                  97:    
                                                  98:    ;	save the do loop registers
0009B6  F80038     PUSH DCOUNT                    99:    	push	DCOUNT
0009B8  F8003A     PUSH DOSTART                   100:   	push	DOSTARTL
0009BA  F8003C     PUSH DOSTARTH                  101:   	push	DOSTARTH
0009BC  F8003E     PUSH DOEND                     102:   	push	DOENDL
0009BE  F80040     PUSH DOENDH                    103:   	push	DOENDH
                                                  104:   
                                                  105:   	; Perform operation.
0009C0  088000     DO W0, 0x9C8                   106:   	do	w0,_endScl		; {	; do (num elems-1)+1 times
0009C4  7802B3     MOV [W3++], W5                 107:   	mov	[w3++],w5			; w5 = srcM(n)
                                                  108:   						; w3-> srcM(n+1)
0009C6  C00113     MPY W4*W5, A                   109:   	mpy	w4*w5,a				; a=sclVal*srcM(n)
                                                  110:   _endScl:
0009C8  CD0032     SAC.R A, [W2++]                111:   	sac.r	a,[w2++]			; dstM[r][c] = sclVal*srcM[r][c]
                                                  112:   						; w2-> dstM(n+1)
                                                  113:   ;	restore the do loop registers
0009CA  F90040     POP DOENDH                     114:   	pop		DOENDH
0009CC  F9003E     POP DOEND                      115:   	pop		DOENDL
0009CE  F9003C     POP DOSTARTH                   116:   	pop		DOSTARTH
0009D0  F9003A     POP DOSTART                    117:   	pop		DOSTARTL
0009D2  F90038     POP DCOUNT                     118:   	pop		DCOUNT
                                                  119:   
                                                  120:   ; }
                                                  121:   
0009D4  780001     MOV W1, W0                     122:   	mov	w1,w0				; restore return value
                                                  123:   
                                                  124:   ;............................................................................
                                                  125:   
                                                  126:   	; restore CORCON.
0009D6  F90044     POP CORCON                     127:   	pop	CORCON
                                                  128:   
                                                  129:   ;............................................................................
                                                  130:   
                                                  131:   	; Restore working registers.
                                                  132:   	; None to restore...
                                                  133:   
                                                  134:   ;............................................................................
                                                  135:   
                                                  136:   ;	restore the 40 bit A accumulator
0009D8  F90026     POP ACCAU                      137:   	pop		ACCAU
0009DA  F90024     POP ACCAH                      138:   	pop		ACCAH
0009DC  F90022     POP ACCA                       139:   	pop		ACCAL
                                                  140:   
0009DE  060000     RETURN                         141:   	return	
                                                  142:   
                                                  143:   
                                                  144:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  145:   
                                                  146:   	.end
                                                  147:   
                                                  148:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  149:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/mmul.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include	"dspcommon.inc"		; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _MatrixMultiply: Matrix Multiplication.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstM[i][j] = sum_k(srcM1[i][k]*srcM2[k][j]), with
                                                  41:    ; i in {0, 1, ..., numRows1-1}
                                                  42:    ; j in {0, 1, ..., numCols2-1}
                                                  43:    ; k in {0, 1, ..., numCols1Rows2-1}
                                                  44:    ;
                                                  45:    ; Input:
                                                  46:    ;	w0 = number rows in source one matrix (numRows1)
                                                  47:    ;	w1 = number cols in source one matrix,
                                                  48:    ;	     and rows in source tow matrix (numCols1Rows2)
                                                  49:    ;	w2 = number cols in source two matrix (numCols2)
                                                  50:    ;	w3 = ptr to destination matrix (dstM)
                                                  51:    ;	w4 = ptr to source one matrix (srcM1)
                                                  52:    ;	w5 = ptr to source two matrix (srcM2)
                                                  53:    ; Return:
                                                  54:    ;	w0 = ptr to destination matrix (dstM)
                                                  55:    ;
                                                  56:    ; System resources usage:
                                                  57:    ;	{w0..w7}	used, not restored
                                                  58:    ;	{w8..w13}	used, and restored
                                                  59:    ;	 AccuA		saved, used, restored
                                                  60:    ;	 CORCON		saved, used, restored
                                                  61:    ;	 DO			saved, used, restored
                                                  62:    ;
                                                  63:    ; DO and REPEAT instruction usage.
                                                  64:    ;	2 level DO instruction
                                                  65:    ;	no REPEAT intructions
                                                  66:    ;
                                                  67:    ; Program words (24-bit instructions):
                                                  68:    ;	35
                                                  69:    ;
                                                  70:    ; Cycles (including C-function call and return overheads):
                                                  71:    ;	36 + numRows1*(8 + numCols2*(7 + 4*numCols1Rows2))
                                                  72:    ;............................................................................
                                                  73:    
                                                  74:    	.global	_MatrixMultiply	; export
                                                  75:    _MatrixMultiply:
                                                  76:    
                                                  77:    ;	save the 40 bit A accumulator
00092A  F80022     PUSH ACCA                      78:    	push	ACCAL
00092C  F80024     PUSH ACCAH                     79:    	push	ACCAH
00092E  F80026     PUSH ACCAU                     80:    	push	ACCAU
                                                  81:    
                                                  82:    ;............................................................................
                                                  83:    
                                                  84:    	; Save working registers.
000930  BE9F88     MOV.D W8, [W15++]              85:    	push.d	w8				; {w8:w9} to TOS
000932  BE9F8A     MOV.D W10, [W15++]             86:    	push.d	w10				; {w10:w11} to TOS
000934  BE9F8C     MOV.D W12, [W15++]             87:    	push.d	w12				; {w12:w13} to TOS
                                                  88:    
                                                  89:    ;............................................................................
                                                  90:    
                                                  91:    	; Prepare CORCON for fractional computation.
000936  F80044     PUSH CORCON                    92:    	push	CORCON
000938  200F0D     MOV #0xF0, W13                 93:    	fractsetup	w13
                                                  94:    
                                                  95:    ;............................................................................
                                                  96:    
00093C  780683     MOV W3, W13                    97:    	mov	w3,w13				; save return value (dstM)
                                                  98:    
                                                  99:    ;............................................................................
                                                  100:   
00093E  E90601     DEC W1, W12                    101:   	dec	w1,w12				; w12 = numCols1Rows2-1
000940  E90582     DEC W2, W11                    102:   	dec	w2,w11				; w11 = numCols2-1
000942  408081     ADD W1, W1, W1                 103:   	add	w1,w1,w1			; w1  = sizeof (Cols1Rows2)
000944  410102     ADD W2, W2, W2                 104:   	add	w2,w2,w2			; w2  = sizeof (Cols2)
                                                  105:   
                                                  106:   _doRows1:
000946  E90000     DEC W0, W0                     107:   	dec	w0,w0				; w0  = w0-1
000948  350024     BRA LT, 0x992                  108:   	bra	lt,_doneRows1
                                                  109:   						; do (numRows1) times
00094A  780505     MOV W5, W10                    110:   	mov	w5,w10				; w10-> srcM2[0][0]
                                                  111:   
                                                  112:   ;	save the do loop registers
00094C  F80038     PUSH DCOUNT                    113:   	push	DCOUNT
00094E  F8003A     PUSH DOSTART                   114:   	push	DOSTARTL
000950  F8003C     PUSH DOSTARTH                  115:   	push	DOSTARTH
000952  F8003E     PUSH DOEND                     116:   	push	DOENDL
000954  F80040     PUSH DOENDH                    117:   	push	DOENDH
                                                  118:   
000956  08800B     DO W11, 0x982                  119:   	do	w11,_endCols2		; {	; do (numCols2-1)+1 times
00095A  780404     MOV W4, W8                     120:   	mov	w4,w8				; w8 -> srcM1[i][0]
00095C  78048A     MOV W10, W9                    121:   	mov	w10,w9				; w9 -> srcM2[0][j]
00095E  C30112     CLR A                          122:   	clr	a				; a   = 0
                                                  123:   
                                                  124:   ;	save the do loop registers
000960  F80038     PUSH DCOUNT                    125:   	push	DCOUNT
000962  F8003A     PUSH DOSTART                   126:   	push	DOSTARTL
000964  F8003C     PUSH DOSTARTH                  127:   	push	DOSTARTH
000966  F8003E     PUSH DOEND                     128:   	push	DOENDL
000968  F80040     PUSH DOENDH                    129:   	push	DOENDH
                                                  130:   
00096A  08800C     DO W12, 0x974                  131:   	do	w12,_endCols1Rows2	; {	; do (numCols1Rows2-1)+1 times
00096E  780338     MOV [W8++], W6                 132:   	mov	[w8++],w6			; w6  = srcM1[i][k]
                                                  133:   						; w8 -> srcM1[i][k+1]
000970  780399     MOV [W9], W7                   134:   	mov	[w9],w7				; w7  = srcM2[k][j]
000972  C60112     MAC W6*W7, A                   135:   	mac	w6*w7,a				; a  += srcM1[i][k]*srcM2[k][j]
                                                  136:   _endCols1Rows2:
000974  448482     ADD W9, W2, W9                 137:   	add	w9,w2,w9			; w9 -> srcM2[k+1][0]
                                                  138:   
                                                  139:   ;	restore the do loop registers
000976  F90040     POP DOENDH                     140:   	pop		DOENDH
000978  F9003E     POP DOEND                      141:   	pop		DOENDL
00097A  F9003C     POP DOSTARTH                   142:   	pop		DOSTARTH
00097C  F9003A     POP DOSTART                    143:   	pop		DOSTARTL
00097E  F90038     POP DCOUNT                     144:   	pop		DCOUNT
                                                  145:   
                                                  146:   ; }
                                                  147:   
000980  CD0033     SAC.R A, [W3++]                148:   	sac.r	a,[w3++]			; dst[i][j] =
                                                  149:   						; sum_k(srcM1[i][k]*srcM2[k][j])
                                                  150:   	; Update for next column.
                                                  151:   _endCols2:
000982  E8850A     INC2 W10, W10                  152:   	inc2	w10,w10				; w10-> srcM2[0][j+1]
                                                  153:   
                                                  154:   ;	restore the do loop registers
000984  F90040     POP DOENDH                     155:   	pop		DOENDH
000986  F9003E     POP DOEND                      156:   	pop		DOENDL
000988  F9003C     POP DOSTARTH                   157:   	pop		DOSTARTH
00098A  F9003A     POP DOSTART                    158:   	pop		DOSTARTL
00098C  F90038     POP DCOUNT                     159:   	pop		DCOUNT
                                                  160:   
                                                  161:   ; }
                                                  162:   
                                                  163:   	; Update for next row.
00098E  420201     ADD W4, W1, W4                 164:   	add	w4,w1,w4			; w4 -> srcM1[i][0]
000990  37FFDA     BRA 0x946                      165:   	bra	_doRows1
                                                  166:   _doneRows1:
                                                  167:   
                                                  168:   ;............................................................................
                                                  169:   
000992  78000D     MOV W13, W0                    170:   	mov	w13,w0				; restore return value
                                                  171:   
                                                  172:   ;............................................................................
                                                  173:   
                                                  174:   	; restore CORCON.
000994  F90044     POP CORCON                     175:   	pop	CORCON
                                                  176:   
                                                  177:   ;............................................................................
                                                  178:   
                                                  179:   	; Restore working registers.
000996  BE064F     MOV.D [--W15], W12             180:   	pop.d	w12				; {w12:w13} from TOS
000998  BE054F     MOV.D [--W15], W10             181:   	pop.d	w10				; {w10:w11} from TOS
00099A  BE044F     MOV.D [--W15], W8              182:   	pop.d	w8				; {w8:w9} from TOS
                                                  183:   
                                                  184:   ;............................................................................
                                                  185:   
                                                  186:   ;	restore the 40 bit A accumulator
00099C  F90026     POP ACCAU                      187:   	pop		ACCAU
00099E  F90024     POP ACCAH                      188:   	pop		ACCAH
0009A0  F90022     POP ACCA                       189:   	pop		ACCAL
                                                  190:   
0009A2  060000     RETURN                         191:   	return	
                                                  192:   
                                                  193:   
                                                  194:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  195:   
                                                  196:   	.end
                                                  197:   
                                                  198:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  199:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libVectorMatrix/madd.s  -----------------------------------
                                                  1:     ;*********************************************************************
                                                  2:     ;                                                                    *
                                                  3:     ;                       Software License Agreement                   *
                                                  4:     ;                                                                    *
                                                  5:     ;   The software supplied herewith by Microchip Technology           *
                                                  6:     ;   Incorporated (the "Company") for its dsPIC controller            *
                                                  7:     ;   is intended and supplied to you, the Company's customer,         *
                                                  8:     ;   for use solely and exclusively on Microchip dsPIC                *
                                                  9:     ;   products. The software is owned by the Company and/or its        *
                                                  10:    ;   supplier, and is protected under applicable copyright laws. All  *
                                                  11:    ;   rights are reserved. Any use in violation of the foregoing       *
                                                  12:    ;   restrictions may subject the user to criminal sanctions under    *
                                                  13:    ;   applicable laws, as well as to civil liability for the breach of *
                                                  14:    ;   the terms and conditions of this license.                        *
                                                  15:    ;                                                                    *
                                                  16:    ;   THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION.  NO           *
                                                  17:    ;   WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING,    *
                                                  18:    ;   BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND    *
                                                  19:    ;   FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE     *
                                                  20:    ;   COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,  *
                                                  21:    ;   INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  *
                                                  22:    ;                                                                    *
                                                  23:    ;   (c) Copyright 2003 Microchip Technology, All rights reserved.    *
                                                  24:    ;*********************************************************************
                                                  25:    
                                                  26:    	; Local inclusions.
                                                  27:    	.nolist
                                                  28:    	.include "dspcommon.inc"    ; fractsetup
                                                  29:    	.list
                                                  30:    
                                                  31:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  32:    
                                                  33:    	.section .libdsp, code
                                                  34:    
                                                  35:    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  36:    ;
                                                  37:    ; _MatrixAdd: Matrix addition.
                                                  38:    ;
                                                  39:    ; Operation:
                                                  40:    ;	dstM[i][j] = srcM1[i][j] + srcM2[i][j]
                                                  41:    ;
                                                  42:    ; Input:
                                                  43:    ;	w0 = number rows in source matrix (numRows)
                                                  44:    ;	w1 = number cols in source matrix (numCols)
                                                  45:    ;	    (NOTE: numRows*numCols < 2^14)
                                                  46:    ;	w2 = ptr to destination matrix (dstM)
                                                  47:    ;	w3 = ptr to source one matrix (srcM1)
                                                  48:    ;	w4 = ptr to source two matrix (srcM2)
                                                  49:    ; Return:
                                                  50:    ;	w0 = ptr to destination matrix (dstM)
                                                  51:    ;
                                                  52:    ; System resources usage:
                                                  53:    ;	{w0..w4}    used, not restored
                                                  54:    ;	 AccuA      saved, used, restored
                                                  55:    ;	 CORCON     saved, used, restored
                                                  56:    ;	 DO         saved, used, restored
                                                  57:    ;
                                                  58:    ; DO and REPEAT instruction usage.
                                                  59:    ;	1 level DO instruction
                                                  60:    ;	no REPEAT intructions
                                                  61:    ;
                                                  62:    ; Program words (24-bit instructions):
                                                  63:    ;	14
                                                  64:    ;
                                                  65:    ; Cycles (including C-function call and return overheads):
                                                  66:    ;	20 + 3*(numRows*numCols)
                                                  67:    ;............................................................................
                                                  68:    
                                                  69:    	.global _MatrixAdd  ; export
                                                  70:    _MatrixAdd:
                                                  71:    
                                                  72:    ;	save the 40 bit A accumulator
0008EA  F80022     PUSH ACCA                      73:    	push    ACCAL
0008EC  F80024     PUSH ACCAH                     74:    	push    ACCAH
0008EE  F80026     PUSH ACCAU                     75:    	push    ACCAU
                                                  76:    
                                                  77:    ;............................................................................
                                                  78:    
                                                  79:    	; Prepare operation.
0008F0  B80001     MUL.UU W0, W1, W0              80:    	mul.uu  w0,w1,w0    ; w0 = numRows*numCols
                                                  81:    	                    ; w1 available for reuse
0008F2  E90000     DEC W0, W0                     82:    	dec	w0,w0           ; w0 = num elements-1
                                                  83:    
                                                  84:    ;............................................................................
                                                  85:    
                                                  86:    	; Prepare CORCON for fractional computation.
0008F4  F80044     PUSH CORCON                    87:    	push    CORCON
0008F6  200F01     MOV #0xF0, W1                  88:    	fractsetup  w1
                                                  89:    
                                                  90:    ;............................................................................
                                                  91:    
0008FA  780082     MOV W2, W1                     92:    	mov     w2,w1       ; save return value (dstV)
                                                  93:    
                                                  94:    ;............................................................................
                                                  95:    
                                                  96:    ;	save the do loop registers
0008FC  F80038     PUSH DCOUNT                    97:    	push    DCOUNT
0008FE  F8003A     PUSH DOSTART                   98:    	push    DOSTARTL
000900  F8003C     PUSH DOSTARTH                  99:    	push    DOSTARTH
000902  F8003E     PUSH DOEND                     100:   	push    DOENDL
000904  F80040     PUSH DOENDH                    101:   	push    DOENDH
                                                  102:   
                                                  103:   	; Perform operation.
000906  088000     DO W0, 0x912                   104:   	do      w0,_endAdd  ; { ; do (num elems-1)+1 times
                                                  105:   .ifdef PSV_ERRATA
00090A  7802B3     MOV [W3++], W5                 106:   	mov     [w3++],w5
00090C  CA0005     LAC W5, A                      107:   	lac     w5,a        ; a  = srcM1[r][c]
                                                  108:   	                    ; w3-> srcM1[r][c+1]
00090E  7802B4     MOV [W4++], W5                 109:   	mov     [w4++],w5
000910  C90005     ADD W5, A                      110:   	add     w5,a        ; a += srcM2[r][c]
                                                  111:   	                    ; w4-> srcM2[r][c+1]
                                                  112:   .else
                                                  113:   	lac     [w3++],a    ; a  = srcM1[r][c]
                                                  114:   	                    ; w3-> srcM1[r][c+1]
                                                  115:   	add     [w4++],a    ; a += srcM2[r][c]
                                                  116:   	                    ; w4-> srcM2[r][c+1]
                                                  117:   .endif
                                                  118:   _endAdd:
000912  CC0032     SAC A, [W2++]                  119:   	sac     a,[w2++]    ; dstM[n] =
                                                  120:   	                    ;    srcM1[r][c] + srcM2[r][c]
                                                  121:   	                    ; w2-> dstM[r][c+1]
                                                  122:   
                                                  123:   ;	restore the do loop registers
000914  F90040     POP DOENDH                     124:   	pop     DOENDH
000916  F9003E     POP DOEND                      125:   	pop     DOENDL
000918  F9003C     POP DOSTARTH                   126:   	pop     DOSTARTH
00091A  F9003A     POP DOSTART                    127:   	pop     DOSTARTL
00091C  F90038     POP DCOUNT                     128:   	pop     DCOUNT
                                                  129:   
                                                  130:   ; }
                                                  131:   
                                                  132:   ;............................................................................
                                                  133:   
00091E  780001     MOV W1, W0                     134:   	mov     w1,w0       ; restore return value
                                                  135:   
                                                  136:   ;............................................................................
                                                  137:   
                                                  138:   	; restore CORCON.
000920  F90044     POP CORCON                     139:   	pop     CORCON
                                                  140:   
                                                  141:   ;............................................................................
                                                  142:   
                                                  143:   ;	restore the 40 bit A accumulator
000922  F90026     POP ACCAU                      144:   	pop     ACCAU
000924  F90024     POP ACCAH                      145:   	pop     ACCAH
000926  F90022     POP ACCA                       146:   	pop     ACCAL
                                                  147:   
000928  060000     RETURN                         148:   	return
                                                  149:   
                                                  150:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  151:   
                                                  152:   	.end
                                                  153:   
                                                  154:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  155:   ; OEF
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/write.c  -------------------------------------------
1:                 #if defined(__dsPIC33E__)
2:                 #include <p33Exxxx.h>
3:                 #elif defined(__dsPIC33F__)
4:                 #include <p33Fxxxx.h>
5:                 #endif
6:                 
7:                 extern int __C30_UART;
8:                 
9:                 int __attribute__((__weak__, __section__(".libc")))
10:                write(int handle, void *buffer, unsigned int len) 
11:                {
000456  FA0010     LNK #0x10
000458  980750     MOV W0, [W14+10]
00045A  980761     MOV W1, [W14+12]
00045C  980772     MOV W2, [W14+14]
12:                	int i;
13:                	volatile UxMODEBITS *umode = &U1MODEbits;
00045E  202200     MOV #0x220, W0
000460  980710     MOV W0, [W14+2]
14:                	volatile UxSTABITS *ustatus = &U1STAbits;
000462  202220     MOV #0x222, W0
000464  980720     MOV W0, [W14+4]
15:                	volatile unsigned int *txreg = &U1TXREG;
000466  202240     MOV #0x224, W0
000468  980730     MOV W0, [W14+6]
16:                	volatile unsigned int *brg = &U1BRG;
00046A  202280     MOV #0x228, W0
00046C  980740     MOV W0, [W14+8]
17:                
18:                	switch (handle)
00046E  90005E     MOV [W14+10], W0
000470  DE80CF     ASR W0, #15, W1
000472  200042     MOV #0x4, W2
000474  200003     MOV #0x0, W3
000476  500F82     SUB W0, W2, [W15]
000478  588F83     SUBB W1, W3, [W15]
00047A  3E0012     BRA GTU, .LSM12, .L2
00047C  016000     BRA W0
00047E  370004     BRA .LSM6, .L3
000480  370003     BRA .LSM6, .L3
000482  370002     BRA .LSM6, .L3
000484  37000F     BRA .LSM13, .L15
000486  37000E     BRA .LSM13, .L15
19:                	{
20:                		case 0:
21:                		case 1:
22:                		case 2:
23:                			if (__C30_UART == 2) {
000488  80F560     MOV 0x1EAC, W0
00048A  500FE2     SUB W0, #0x2, [W15]
00048C  3A000D     BRA NZ, .LSM14, .L16
24:                				umode = (UxMODEBITS*)&U2MODEbits;
00048E  202300     MOV #0x230, W0
000490  980710     MOV W0, [W14+2]
25:                				ustatus = (UxSTABITS*)&U2STAbits;
000492  202320     MOV #0x232, W0
000494  980720     MOV W0, [W14+4]
26:                				txreg = &U2TXREG;
000496  202340     MOV #0x234, W0
000498  980730     MOV W0, [W14+6]
27:                				brg = &U2BRG;
00049A  202380     MOV #0x238, W0
00049C  980740     MOV W0, [W14+8]
28:                			}
29:                #if defined (__dsPIC33E__)
30:                			if (__C30_UART == 3) {
31:                				umode = (UxMODEBITS*)&U3MODEbits;
32:                				ustatus = (UxSTABITS*)&U3STAbits;
33:                				txreg = &U3TXREG;
34:                				brg = &U3BRG;
35:                			}
36:                			if (__C30_UART == 4) {
37:                				umode = (UxMODEBITS*)&U4MODEbits;
38:                				ustatus = (UxSTABITS*)&U4STAbits;
39:                				txreg = &U4TXREG;
40:                				brg = &U4BRG;
41:                			}
42:                #endif // __dsPIC33E__
43:                			break;
00049E  370005     BRA .LSM15, .L8
0004A8  000000     NOP
44:                
45:                		case 3:
46:                #if defined (__dsPIC33E__)
47:                			umode = (UxMODEBITS*)&U3MODEbits;
48:                			ustatus = (UxSTABITS*)&U3STAbits;
49:                			txreg = &U3TXREG;
50:                			brg = &U3BRG;
51:                #endif // __dsPIC33E__
52:                			break;
53:                		case 4:
54:                #if defined (__dsPIC33E__)
55:                			umode = (UxMODEBITS*)&U4MODEbits;
56:                			ustatus = (UxSTABITS*)&U4STAbits;
57:                			txreg = &U4TXREG;
58:                			brg = &U4BRG;
59:                #endif // __dsPIC33E__
60:                			break;
0004A4  000000     NOP
0004A6  370001     BRA .LSM15, .L8
61:                		default: {
62:                //			SIMIO simio;
63:                //			register PSIMIO psimio asm("w0") = &simio;
64:                //			simio.method = SIM_WRITE;
65:                //			simio.u.write.handle = handle;
66:                //			simio.u.write.buffer = buffer;
67:                //			simio.u.write.len = len;
68:                //			dowrite(psimio);
69:                //			len = simio.u.write.len;
70:                			return 0;
0004A0  EB0000     CLR W0
0004A2  370033     BRA .LSM25, .L9
71:                		}
72:                	}
73:                	if ((umode->UARTEN) == 0)
0004AA  90001E     MOV [W14+2], W0
0004AC  780090     MOV [W0], W1
0004AE  280000     MOV #0x8000, W0
0004B0  608000     AND W1, W0, W0
0004B2  500FE0     SUB W0, #0x0, [W15]
0004B4  3A0008     BRA NZ, .LSM18, .L10
74:                	{
75:                		*brg = 0;
0004B6  90004E     MOV [W14+8], W0
0004B8  EB0080     CLR W1
0004BA  780801     MOV W1, [W0]
76:                		umode->UARTEN = 1;
0004BC  90001E     MOV [W14+2], W0
0004BE  780110     MOV [W0], W2
0004C0  280001     MOV #0x8000, W1
0004C2  710081     IOR W2, W1, W1
0004C4  780801     MOV W1, [W0]
77:                	}
78:                	if ((ustatus->UTXEN) == 0)
0004C6  90002E     MOV [W14+4], W0
0004C8  780090     MOV [W0], W1
0004CA  204000     MOV #0x400, W0
0004CC  608000     AND W1, W0, W0
0004CE  500FE0     SUB W0, #0x0, [W15]
0004D0  3A0005     BRA NZ, .LSM20, .L11
79:                	{
80:                		ustatus->UTXEN = 1;
0004D2  90002E     MOV [W14+4], W0
0004D4  780110     MOV [W0], W2
0004D6  204001     MOV #0x400, W1
0004D8  710081     IOR W2, W1, W1
0004DA  780801     MOV W1, [W0]
81:                	}
82:                	for (i = len; i; --i)
0004DC  90007E     MOV [W14+14], W0
0004DE  780F00     MOV W0, [W14]
0004E0  370010     BRA .L12
000500  E90F1E     DEC [W14], [W14]
000502  78001E     MOV [W14], W0
000504  500FE0     SUB W0, #0x0, [W15]
000506  3AFFED     BRA NZ, .LSM21, .L17
83:                	{
84:                		while ((ustatus->TRMT) ==0);
0004E2  000000     NOP
0004E4  90002E     MOV [W14+4], W0
0004E6  780090     MOV [W0], W1
0004E8  201000     MOV #0x100, W0
0004EA  608000     AND W1, W0, W0
0004EC  500FE0     SUB W0, #0x0, [W15]
0004EE  32FFFA     BRA Z, .L13
85:                		*txreg = *(char*)buffer++;
0004F0  90006E     MOV [W14+12], W0
0004F2  784010     MOV.B [W0], W0
0004F4  FB0080     SE W0, W1
0004F6  90003E     MOV [W14+6], W0
0004F8  780801     MOV W1, [W0]
0004FA  90006E     MOV [W14+12], W0
0004FC  E80000     INC W0, W0
0004FE  980760     MOV W0, [W14+12]
86:                	}
87:                	return len;
000508  90007E     MOV [W14+14], W0
88:                }
00050A  FA8000     ULNK
00050C  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/uart.c  --------------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "oscillator.h"
24:                #include "uart.h"
25:                #include "options_ports.h"
26:                
27:                #if defined(__dsPIC33E__)
28:                #include <p33Exxxx.h>
29:                #elif defined(__dsPIC33F__)
30:                #include <p33Fxxxx.h>
31:                #endif
32:                
33:                #ifndef CONSOLE_UART
34:                #error CONSOLE_UART must be defined
35:                #endif
36:                
37:                extern int __C30_UART;
38:                
39:                #if (CONSOLE_UART != 0) && (CONSOLE_UART != 9)
40:                
41:                #ifdef USE_BLUETOOTH_UART
42:                #define BAUDRATEX       9600UL
43:                #define BRGHX           0
44:                #else
45:                #define BAUDRATEX       115200UL
46:                #define BRGHX           1
47:                #endif
48:                
49:                #if (BRGHX == 0)
50:                	#define BRG_DIVX    16
51:                #elif (BRGHX == 1)
52:                	#define BRG_DIVX    4
53:                #else
54:                	#error Must select a valid BRGHX value
55:                #endif
56:                
57:                //******************************************************************************
58:                // Constants
59:                //******************************************************************************
60:                
61:                //UBRG register value and baudrate mistake calculation
62:                
63:                #if defined (__C30__)
64:                	#if defined (__dsPIC33E__) || defined (__PIC24E__)
65:                	#define BAUDRATEREG     (((GetPeripheralClock())/(BRG_DIVX * BAUDRATEX)) - 1)
66:                	#else
67:                	#define BAUDRATEREG     (((GetSystemClock()/2)+(BRG_DIVX/2*BAUDRATEX))/BRG_DIVX/BAUDRATEX-1)
68:                	#endif
69:                #elif defined (__PIC32MX__)
70:                	#define BAUDRATEREG     ((GetPeripheralClock()+(BRG_DIVX/2*BAUDRATEX))/BRG_DIVX/BAUDRATEX-1)
71:                #else
72:                	#error Cannot calculate BAUDRATEREG value
73:                #endif
74:                
75:                #if defined (__C30__)
76:                	#if defined (__dsPIC33E__)|| defined (__PIC24E__)
77:                	#define BAUD_ACTUAL     ((GetPeripheralClock())/(BRG_DIVX * (BAUDRATEREG+1)))
78:                	#else
79:                	#define BAUD_ACTUAL     ((GetSystemClock()/2)/BRG_DIVX/(BAUDRATEREG+1))
80:                	#endif
81:                #elif defined (__PIC32MX__)
82:                	#define BAUD_ACTUAL     (GetPeripheralClock()/BRG_DIVX/(BAUDRATEREG+1))
83:                #else
84:                	#error Cannot calculate actual baud rate
85:                #endif
86:                
87:                #define BAUD_ERROR          ((BAUD_ACTUAL > BAUDRATEX) ? BAUD_ACTUAL-BAUDRATEX : BAUDRATEX-BAUD_ACTUAL)
88:                #define BAUD_ERROR_PERCENT  ((BAUD_ERROR*100+BAUDRATEX/2)/BAUDRATEX)
89:                
90:                #if defined (__C30__)
91:                	#if (BAUD_ERROR_PERCENT > 3)
92:                		#error UART frequency error is worse than 3%
93:                	#elif (BAUD_ERROR_PERCENT > 2)
94:                		#warning UART frequency error is worse than 2%
95:                	#endif
96:                #endif // #if defined (__C30__)
97:                
98:                #if defined (__dsPIC33F__)
99:                #undef BAUDRATEREG
100:               //#define UDB_BAUD(x) ((int16_t)((FREQOSC / CLK_PHASES) / ((int32_t)4 * x) - 1))
101:               #define BAUDRATEREG ((int16_t)((FREQOSC / CLK_PHASES) / ((int32_t)4 * BAUDRATEX) - 1))
102:               #endif
103:               
104:               #define _INIT(x, y) \
105:               void Init(void) \
106:               { \
107:               	U##x##BRG = BAUDRATEREG; \
108:               	U##x##MODE = 0; \
109:               	U##x##MODEbits.BRGH = BRGHX; \
110:               	U##x##STA = 0; \
111:               	U##x##MODEbits.UARTEN = 1; \
112:               	U##x##STAbits.UTXEN = 1; \
113:               	IFS##y##bits.U##x##RXIF = 0; \
114:               }
115:               
116:               #define _ISPRESSED(x) \
117:               char IsPressed(void) \
118:               { \
119:               	if (U##x##STAbits.URXDA) return 1; \
120:               	return 0; \
121:               }
122:               
123:               #define _GETCHAR(x) \
124:               char GetChar(void) \
125:               { \
126:               	char Temp; \
127:               	while (!IsPressed()); \
128:               	Temp = U##x##RXREG; \
129:               	ClrError(); \
130:               	return Temp; \
131:               }
132:               
133:               #define _PUTCHAR(x) \
134:               void PutChar(char ch) \
135:               { \
136:               	U##x##TXREG = ch; \
137:               	while (U##x##STAbits.TRMT == 0); \
138:               }
139:               
140:               #define _CLRERROR(x) \
141:               void ClrError(void) \
142:               { \
143:               	if (U##x##STAbits.OERR) U##x##STAbits.OERR = 0; \
144:               }
145:               
146:               // define the 'pastor' macros
147:               #define _Init(x, y)   _INIT(x, y)
148:               #define _IsPressed(x) _ISPRESSED(x)
149:               #define _GetChar(x)   _GETCHAR(x)
150:               #define _PutChar(x)   _PUTCHAR(x)
151:               #define _ClrError(x)  _CLRERROR(x)
152:               
153:               #if (CONSOLE_UART == 1)
154:               _Init(CONSOLE_UART, 0);
155:               #elif (CONSOLE_UART == 2)
156:               _Init(CONSOLE_UART, 1);
157:               #elif (CONSOLE_UART == 3 || CONSOLE_UART == 4)
158:               _Init(CONSOLE_UART, 5);
159:               #endif // CONSOLE_UART
160:               
161:               _IsPressed(CONSOLE_UART);
162:               _GetChar(CONSOLE_UART);
163:               _PutChar(CONSOLE_UART);
164:               _ClrError(CONSOLE_UART);
165:               
166:               void init_uart(void)
167:               {
168:               	__C30_UART = CONSOLE_UART;
169:               	Init();
170:               }
171:               
172:               /*******************************************************************************
173:               Function: GetBaudError()
174:               
175:               Precondition:
176:               	None.
177:               
178:               Overview:
179:               	This routine checks the UART baud rate error percentage and returns it.
180:               
181:               Input: None.
182:               
183:               Output: Returns the baud rate error in percent.
184:               
185:               *******************************************************************************/
186:               char GetBaudError(void)
187:               {
188:               	unsigned int errorPercent = 0;
189:               
190:               	errorPercent = ((BAUD_ERROR*100+BAUDRATEX/2)/BAUDRATEX);
191:               	return (char)errorPercent;
192:               }
193:               
194:               
195:               /*******************************************************************************
196:               Function: PrintString(char *str)
197:               
198:               Precondition:
199:               	Init must be called prior to calling this routine.
200:               
201:               Overview:
202:               	This function prints a string of characters to the UART.
203:               
204:               Input: Pointer to a null terminated character string.
205:               
206:               Output: None.
207:               
208:               *******************************************************************************/
209:               void PrintString(const char *str)
210:               {
211:               	unsigned char c;
212:               
213:               	while ((c = *str++))
214:               		PutChar(c);
215:               }
216:               
217:               /*******************************************************************************
218:               Function: PutDec(unsigned char dec)
219:               
220:               Precondition:
221:               	Init must be called prior to calling this routine.
222:               
223:               Overview:
224:               	This function converts decimal data into a string and outputs it to UART.
225:               
226:               Input: Binary data.
227:               
228:               Output: None.
229:               
230:               *******************************************************************************/
231:               void PutDec(unsigned char dec)
232:               {
233:               	unsigned char res;
234:               	unsigned char printed_already = 0;
235:               
236:               	res = dec;
237:               
238:               	if (res/100)
239:               	{
240:               		PutChar(res/100 + '0');
241:               		printed_already = 1;
242:               	}
243:               	res = res - (res/100)*100;
244:               
245:               	if ((res/10) || (printed_already == 1))
246:               	{
247:               		PutChar(res/10 + '0');
248:               	}
249:               	res = res - (res/10)*10;
250:               
251:               	PutChar(res + '0');
252:               }
253:               
254:               /*******************************************************************************
255:               Function: PutHex
256:               
257:               Precondition:
258:               	Init must be called prior to calling this routine.
259:               
260:               Overview:
261:               	This function converts hex data into a string and outputs it to UART.
262:               
263:               Input: Binary data.
264:               
265:               Output: None.
266:               
267:               *******************************************************************************/
268:               
269:               const unsigned char CharacterArray[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
270:               //extern const unsigned char CharacterArray[];
271:               
272:               void PutHex(int toPrint)
273:               {
274:               	int printVar;
275:               
276:               	printVar = toPrint;
277:               	toPrint = (toPrint>>4) & 0x0F;
278:               	PutChar(CharacterArray[toPrint]);
279:               
280:               	toPrint = printVar & 0x0F;
281:               	PutChar(CharacterArray[toPrint]);
282:               }
283:               
284:               /*******************************************************************************
285:               Function: PutHexWord(unsigned int toPrint)
286:               
287:               Precondition:
288:               	Init must be called prior to calling this routine.
289:               
290:               Overview:
291:               	This function converts hex data into a string and outputs it to UART.
292:               
293:               Input: Binary data.
294:               
295:               Output: None.
296:               
297:               *******************************************************************************/
298:               #if defined(__C30__) || defined(__PIC32MX__)
299:               void PutHexWord(unsigned int toPrint)
300:               {
301:               	unsigned int printVar;
302:               
303:               	printVar = (toPrint>>12) & 0x0F;
304:               	PutChar(CharacterArray[printVar]);
305:               
306:               	printVar = (toPrint>>8) & 0x0F;
307:               	PutChar(CharacterArray[printVar]);
308:               
309:               	printVar = (toPrint>>4) & 0x0F;
310:               	PutChar(CharacterArray[printVar]);
311:               
312:               	printVar = toPrint & 0x0F;
313:               	PutChar(CharacterArray[printVar]);
314:               }
315:               
316:               void PutHexDWord(unsigned long toPrint)
317:               {
318:               	unsigned long printVar;
319:               
320:               	printVar = (toPrint>>28) & 0x0F;
321:               	PutChar(CharacterArray[printVar]);
322:               
323:               	printVar = (toPrint>>24) & 0x0F;
324:               	PutChar(CharacterArray[printVar]);
325:               
326:               	printVar = (toPrint>>20) & 0x0F;
327:               	PutChar(CharacterArray[printVar]);
328:               
329:               	printVar = (toPrint>>16) & 0x0F;
330:               	PutChar(CharacterArray[printVar]);
331:               
332:               	printVar = (toPrint>>12) & 0x0F;
333:               	PutChar(CharacterArray[printVar]);
334:               
335:               	printVar = (toPrint>>8) & 0x0F;
336:               	PutChar(CharacterArray[printVar]);
337:               
338:               	printVar = (toPrint>>4) & 0x0F;
339:               	PutChar(CharacterArray[printVar]);
340:               
341:               	printVar = toPrint & 0x0F;
342:               	PutChar(CharacterArray[printVar]);
343:               }
344:               
345:               #endif
346:               
347:               /*********************************************************************
348:               Function: char Char2Hex(char ch)
349:               
350:               PreCondition: none
351:               
352:               Input: ASCII to be converted
353:               
354:               Output: number
355:               
356:               Side Effects: none
357:               
358:               Overview: converts ASCII coded digit into number
359:               
360:               Note: none
361:               
362:               ********************************************************************/
363:               char Char2Hex(char ch)
364:               {
365:               	// Wrong char
366:               	if (ch > 102)
367:               		return 0;
368:               
369:               	// From a to f
370:               	if (ch > 96)
371:               		return (ch - 87);
372:               
373:               	// Wrong char
374:               	if (ch > 70)
375:               		return 0;
376:               
377:               	// From A to F
378:               	if (ch > 64)
379:               		return (ch - 55);
380:               
381:               	// Wrong char
382:               	if (ch > 57)
383:               		return 0;
384:               
385:               	// From 0 - 9
386:               	if (ch > 47)
387:               		return (ch - 48);
388:               	else // Wrong char
389:               		return 0;
390:               }
391:               
392:               /*********************************************************************
393:               Function: char Hex2Char(char hex)
394:               
395:               PreCondition: none
396:               
397:               Input: number
398:               
399:               Output: ASCII code
400:               
401:               Side Effects: none
402:               
403:               Overview: converts low nibble into ASCII coded digit
404:               
405:               Note: none
406:               
407:               ********************************************************************/
408:               char Hex2Char(char hex)
409:               {
410:               	char h;
411:               	h = hex & 0x0f;
412:               
413:               	// From 0xa to 0xf
414:               	if (h > 9)
415:               		return (h + 55);
416:               	else
417:               		return (h + 48);
418:               }
419:               
420:               #else
421:               
422:               void init_uart(void)
423:               {
008094  FA0000     LNK #0x0
424:               #if (CONSOLE_UART == 9)
425:               	__C30_UART = CONSOLE_UART;
426:               #endif
427:               }
008096  FA8000     ULNK
008098  060000     RETURN
428:               
429:               #endif // CONSOLE_UART
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/traps_asm.s  ---------------------------------------
                                                  1:     
                                                  2:     .ifdef __dsPIC33F
                                                  3:     .include "p33Fxxxx.inc"
                                                  4:     .endif
                                                  5:     .ifdef __dsPIC33E
                                                  6:     .include "p33Exxxx.inc"
                                                  7:     .endif
                                                  8:     
                                                  9:     ; MATH_ERROR 1
                                                  10:    ; STACK_ERROR 2
                                                  11:    ; ADDRESS_ERROR 4
                                                  12:    ; OSC_FAIL 8
                                                  13:    ; unhandled interrupt 16
                                                  14:    ; DMACError 32
                                                  15:    
                                                  16:    /*
                                                  17:    .extern	_trap_flags
                                                  18:    .extern _trap_source
                                                  19:    .extern _osc_fail_count
                                                  20:    
                                                  21:    __MathError:	mov.w #1,w0
                                                  22:    				bra save_states
                                                  23:    
                                                  24:    __StackError:	mov.w #2,w0
                                                  25:    				bra save_states
                                                  26:    
                                                  27:    __AddressError:	mov.w #4,w0
                                                  28:    				bra save_states
                                                  29:    
                                                  30:    __OscillatorFail:inc _osc_fail_count
                                                  31:    				mov.w #8,w0
                                                  32:    				bra save_states
                                                  33:    
                                                  34:    __DMACError:	mov.w #32,w0
                                                  35:    				bra save_states
                                                  36:    
                                                  37:    __DefaultInterrupt:	mov.w #16,w0
                                                  38:    				bra	save_states
                                                  39:    
                                                  40:    save_states:	mov.w w0,_trap_flags
                                                  41:    				pop.d w0
                                                  42:    				mov.w w0, _trap_source
                                                  43:    				and #0x7f,w1
                                                  44:    				mov.w w1, _trap_source+2
                                                  45:    				reset
                                                  46:    
                                                  47:    .global __MathError
                                                  48:    .global __StackError
                                                  49:    .global __AddressError
                                                  50:    .global __OscillatorFail
                                                  51:    .global __DefaultInterrupt
                                                  52:    .global __DMACError
                                                  53:     */
                                                  54:    
                                                  55:    .global _SP_start
                                                  56:    .global _SP_limit
                                                  57:    .global _SP_current
                                                  58:    
                                                  59:    .section .text
                                                  60:    
                                                  61:    _SP_start:
007FFE  21FB40     MOV #0x1FB4, W0                62:    	mov #__SP_init,w0
008000  060000     RETURN                         63:    	return
                                                  64:    
                                                  65:    _SP_limit:
008002  800100     MOV SPLIM, W0                  66:    	mov SPLIM,w0
008004  060000     RETURN                         67:    	return
                                                  68:    
                                                  69:    _SP_current:
008006  78000F     MOV W15, W0                    70:    	mov w15,w0
008008  060000     RETURN                         71:    	return
                                                  72:    
                                                  73:    .global _getErrLoc
                                                  74:    .section .text
                                                  75:    
                                                  76:    _getErrLoc:
00800A  78010E     MOV W14, W2                    77:    	mov    w14,w2
00800C  510178     SUB W2, #0x18, W2              78:    	sub    w2,#24,w2
00800E  780032     MOV [W2++], W0                 79:    	mov    [w2++],w0
008010  7800B2     MOV [W2++], W1                 80:    	mov    [w2++],w1 
008012  2007F3     MOV #0x7F, W3                  81:    	mov    #0x7f,w3     ; Mask off non-address bits
008014  608083     AND W1, W3, W1                 82:    	and    w1,w3,w1
008016  200022     MOV #0x2, W2                   83:    	mov    #2,w2        ; Decrement the address by 2
008018  500002     SUB W0, W2, W0                 84:    	sub    w0,w2,w0
00801A  EB0100     CLR W2                         85:    	clr    w2
00801C  588082     SUBB W1, W2, W1                86:    	subb   w1,w2,w1
00801E  060000     RETURN                         87:    	return
                                                  88:    
                                                  89:    ; Stack Growth from Trap Error
                                                  90:    ;1. PC[15:0]            <--- Trap Address
                                                  91:    ;2. SR[7:0]:IPL3:PC[22:16]
                                                  92:    ;3. RCOUNT
                                                  93:    ;4. W0
                                                  94:    ;5. W1
                                                  95:    ;6. W2
                                                  96:    ;7. W3
                                                  97:    ;8. W4
                                                  98:    ;9. W5
                                                  99:    ;10. W6
                                                  100:   ;11. W7
                                                  101:   ;12. OLD FRAME POINTER [W14]
                                                  102:   ;13. PC[15:0]           <---- W14 
                                                  103:   ;14. 0:PC[22:16]
                                                  104:   ;15.                    <---- W15
                                                  105:   
                                                  106:   /*
                                                  107:   .global __AddressError
                                                  108:   .global _AddrErrInstructionAddrLow, _AddrErrInstructionAddrHigh
                                                  109:   
                                                  110:   .section .bss
                                                  111:   _AddrErrInstructionAddrLow: .space 2
                                                  112:   _AddrErrInstructionAddrHigh: .space 2
                                                  113:   
                                                  114:   .section .text
                                                  115:   
                                                  116:   __AddressError:
                                                  117:           mov     #_AddrErrInstructionAddrHigh, w1
                                                  118:           pop     [w1--]                  ;Pop the Program Counter (PC) from the stack
                                                  119:           pop     [w1++]                  ;Remember that the PC(PCH and PCL) is stacked
                                                  120:           bclr    [w1], #7                ;along with the SRL byte and IPL3 bit from
                                                  121:           inc     w1, w1                  ;CORCON. So we need to extract just the 24-bit
                                                  122:           clr.b   [w1]                    ;PCH:PCL information from the stack
                                                  123:           mov     #_AddrErrInstructionAddrLow, w1  ;Decrement that value by 2
                                                  124:           mov     #2, w2                  ;Store the 24-bit result into 2x16-bit words
                                                  125:           subr    w2, [w1], [w1++]        ;in RAM at- AddrErrInstructionAddrHigh:Low
                                                  126:           clr     w2
                                                  127:           subbr   w2, [w1], [w1]
                                                  128:           bclr    INTCON1, #ADDRERR       ;Clear the trap flag
                                                  129:   StayTrappedAddrErr:                     ;Stay in this routine
                                                  130:           bra     StayTrappedAddrErr
                                                  131:           ;Place a breakpoint above and halt the Debugging process and view
                                                  132:           ;the variables named: AddrErrInstructionAddrHigh:Low
                                                  133:           retfie
                                                  134:    */
                                                  135:   
                                                  136:   .global _setjmp
                                                  137:   .global _JmpStckPtr
                                                  138:   .global _JmpAddrLow
                                                  139:   .global _JmpAddrHgh
                                                  140:   
                                                  141:   .section .bss
                                                  142:   _JmpStckPtr: .space 2
                                                  143:   _JmpAddrLow: .space 2
                                                  144:   _JmpAddrHgh: .space 2
                                                  145:   
                                                  146:   .section .text
                                                  147:   _setjmp:
008020  78000F     MOV W15, W0                    148:   	mov     w15,w0
008022  200041     MOV #0x4, W1                   149:   	mov     #4,w1           ; Subtract 4 from the stack pointer
008024  500001     SUB W0, W1, W0                 150:   	sub     w0,w1,w0        ; to negate entry into this function
008026  88F420     MOV W0, 0x1E84                 151:   	mov     w0,_JmpStckPtr
008028  21E880     MOV #0x1E88, W0                152:   	mov     #_JmpAddrHgh,w0
00802A  78104F     MOV [--W15], [W0--]            153:   	pop     [w0--]          ; Pop the return address from the stack
00802C  78084F     MOV [--W15], [W0]              154:   	pop     [w0]            ; and save it in the jump address variables
00802E  781FB0     MOV [W0++], [W15++]            155:   	push    [w0++]          ; Put it back again so we can return from here
008030  781F90     MOV [W0], [W15++]              156:   	push    [w0]
008032  EB0000     CLR W0                         157:   	clr     w0
008034  060000     RETURN                         158:   	return
                                                  159:   
                                                  160:   
                                                  161:   .global _gentrap
                                                  162:   
                                                  163:   .section .text
                                                  164:   _gentrap:
008036  2FFFF0     MOV #0xFFFF, W0                165:   	mov     #0xFFFF,w0      ; Load an unimplemented address into w0
008038  2FFFF0     MOV #0xFFFF, W0                166:   	mov     #0xFFFF,w0      ; Load an unimplemented address into w1
                                                  167:   trap_causing_mov_instruction:
00803A  780890     MOV [W0], [W1]                 168:   	mov     [w0],[w1]       ; Perform an illegal mov instruction that the 
                                                  169:   	                        ; tools will not be able to detect at compile-time.
                                                  170:   	                        ; This mov instruction tries to fetch and
                                                  171:   	                        ; store values from and to unimplemented addresses
                                                  172:   	                        ; Also, it performs a misaligned access.
                                                  173:   done:
00803C  37FFFF     BRA 0x803C                     174:   	bra     done            ; Code execution never reaches here.
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/traps.c  -------------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #if defined(__dsPIC33F__)
23:                #include "p33Fxxxx.h"
24:                #elif defined(__dsPIC33E__)
25:                #include "p33Exxxx.h"
26:                #elif defined(__PIC24E__)
27:                #include "p24Exxxx.h"
28:                #endif
29:                #include <stdint.h>
30:                #include <stdio.h>
31:                #include "interrupt.h"
32:                #include "mcu.h"
33:                
34:                //#define USE_SETJMP
35:                
36:                #define TRAP_SRC_OSCFAIL    1
37:                #define TRAP_SRC_MATHERR    2
38:                #define TRAP_SRC_RESERVED   4
39:                #define TRAP_SRC_STACKERR   8
40:                #define TRAP_SRC_ADDRSERR   16
41:                #define TRAP_SRC_DEFAULTINT 32
42:                #define TRAP_SRC_DMACERR    64
43:                
44:                extern volatile uint16_t stack_ptr;
45:                
46:                uint32_t getErrLoc(void);   // Get Address Error Loc
47:                
48:                void __attribute__((__interrupt__)) _OscillatorFail(void);
49:                void __attribute__((__interrupt__)) _AddressError(void);
50:                void __attribute__((__interrupt__)) _StackError(void);
51:                void __attribute__((__interrupt__)) _MathError(void);
52:                void __attribute__((__interrupt__)) _DMACError(void);
53:                
54:                extern volatile uint16_t JmpAddrLow;
55:                extern volatile uint16_t JmpAddrHgh;
56:                extern volatile uint16_t JmpStckPtr;
57:                
58:                void restart(uint16_t flags, uint32_t addrs)
59:                {
007E4E  FA0006     LNK #0x6
007E50  780F00     MOV W0, [W14]
007E52  980712     MOV W2, [W14+2]
007E54  980723     MOV W3, [W14+4]
60:                	trap_flags = flags;
007E56  78001E     MOV [W14], W0
007E58  884020     MOV W0, trap_flags
61:                	trap_source = addrs;
007E5A  90001E     MOV [W14+2], W0
007E5C  9000AE     MOV [W14+4], W1
007E5E  884000     MOV W0, trap_source
007E60  884011     MOV W1, .L50
62:                
63:                #ifdef USE_SETJMP
64:                	if (flags < TRAP_SRC_RESERVED)
65:                #else
66:                	if (1)
67:                #endif
68:                	{
69:                		// for certain exceptions a full reset seems like the best approach
70:                		asm("reset");
007E62  FE0000     RESET
71:                	}
72:                	else
73:                	{
74:                		// TODO: if we want to do more than simply modify the stack and retfie
75:                		//       then we need to clear the IPL3 bit first
76:                		//SRbits.IPL3 = 0;
77:                
78:                		// for less 'serious' exceptions just take the longjmp solution
79:                		asm("mov   _JmpStckPtr,w15");
80:                		asm("push  _JmpAddrLow");
81:                		asm("push  _JmpAddrHgh");
82:                		asm("mov   #1,w0");
83:                		asm("retfie");
84:                	}
85:                }
007E64  FA8000     ULNK
007E66  060000     RETURN
86:                
87:                void __attribute__((interrupt, no_auto_psv)) _OscillatorFail(void)
88:                {
007E68  F80036     PUSH RCOUNT
007E6A  BE9F80     MOV.D W0, [W15++]
007E6C  BE9F82     MOV.D W2, [W15++]
007E6E  BE9F84     MOV.D W4, [W15++]
007E70  BE9F86     MOV.D W6, [W15++]
007E72  FA0000     LNK #0x0
89:                	INTCON1bits.OSCFAIL = 0;        // Clear the trap flag
007E74  A92080     BCLR INTCON1, #1
90:                	osc_fail_count++;
007E76  804030     MOV osc_fail_count, W0
007E78  E80000     INC W0, W0
007E7A  884030     MOV W0, osc_fail_count
91:                	restart(TRAP_SRC_OSCFAIL, getErrLoc());
007E7C  02800A     CALL _getErrLoc
007E7E  000000     NOP
007E80  BE0100     MOV.D W0, W2
007E82  200010     MOV #0x1, W0
007E84  07FFE4     RCALL restart
92:                }
007E86  FA8000     ULNK
007E88  BE034F     MOV.D [--W15], W6
007E8A  BE024F     MOV.D [--W15], W4
007E8C  BE014F     MOV.D [--W15], W2
007E8E  BE004F     MOV.D [--W15], W0
007E90  F90036     POP RCOUNT
007E92  064000     RETFIE
93:                
94:                void __attribute__((interrupt, no_auto_psv)) _AddressError(void)
95:                {
007E94  F80036     PUSH RCOUNT
007E96  BE9F80     MOV.D W0, [W15++]
007E98  BE9F82     MOV.D W2, [W15++]
007E9A  BE9F84     MOV.D W4, [W15++]
007E9C  BE9F86     MOV.D W6, [W15++]
007E9E  FA0000     LNK #0x0
96:                	INTCON1bits.ADDRERR = 0;        // Clear the trap flag
007EA0  A96080     BCLR INTCON1, #3
97:                	restart(TRAP_SRC_ADDRSERR, getErrLoc());
007EA2  02800A     CALL _getErrLoc
007EA4  000000     NOP
007EA6  BE0100     MOV.D W0, W2
007EA8  200100     MOV #0x10, W0
007EAA  07FFD1     RCALL restart
98:                }
007EAC  FA8000     ULNK
007EAE  BE034F     MOV.D [--W15], W6
007EB0  BE024F     MOV.D [--W15], W4
007EB2  BE014F     MOV.D [--W15], W2
007EB4  BE004F     MOV.D [--W15], W0
007EB6  F90036     POP RCOUNT
007EB8  064000     RETFIE
99:                
100:               void __attribute__((interrupt, no_auto_psv)) _StackError(void)
101:               {
007EBA  F80036     PUSH RCOUNT
007EBC  BE9F80     MOV.D W0, [W15++]
007EBE  BE9F82     MOV.D W2, [W15++]
007EC0  BE9F84     MOV.D W4, [W15++]
007EC2  BE9F86     MOV.D W6, [W15++]
007EC4  FA0000     LNK #0x0
102:               	INTCON1bits.STKERR = 0;         // Clear the trap flag
007EC6  A94080     BCLR INTCON1, #2
103:               	restart(TRAP_SRC_STACKERR, getErrLoc());
007EC8  02800A     CALL _getErrLoc
007ECA  000000     NOP
007ECC  BE0100     MOV.D W0, W2
007ECE  200080     MOV #0x8, W0
007ED0  07FFBE     RCALL restart
104:               }
007ED2  FA8000     ULNK
007ED4  BE034F     MOV.D [--W15], W6
007ED6  BE024F     MOV.D [--W15], W4
007ED8  BE014F     MOV.D [--W15], W2
007EDA  BE004F     MOV.D [--W15], W0
007EDC  F90036     POP RCOUNT
007EDE  064000     RETFIE
105:               
106:               void __attribute__((interrupt, no_auto_psv)) _MathError(void)
107:               {
007EE0  F80036     PUSH RCOUNT
007EE2  BE9F80     MOV.D W0, [W15++]
007EE4  BE9F82     MOV.D W2, [W15++]
007EE6  BE9F84     MOV.D W4, [W15++]
007EE8  BE9F86     MOV.D W6, [W15++]
007EEA  FA0000     LNK #0x0
108:               	INTCON1bits.MATHERR = 0;        // Clear the trap flag
007EEC  A98080     BCLR INTCON1, #4
109:               	restart(TRAP_SRC_MATHERR, getErrLoc());
007EEE  02800A     CALL _getErrLoc
007EF0  000000     NOP
007EF2  BE0100     MOV.D W0, W2
007EF4  200020     MOV #0x2, W0
007EF6  07FFAB     RCALL restart
110:               }
007EF8  FA8000     ULNK
007EFA  BE034F     MOV.D [--W15], W6
007EFC  BE024F     MOV.D [--W15], W4
007EFE  BE014F     MOV.D [--W15], W2
007F00  BE004F     MOV.D [--W15], W0
007F02  F90036     POP RCOUNT
007F04  064000     RETFIE
111:               
112:               unsigned int dmaErrFlag = 0, dmaPWErrLoc = 0, dmaRWErrLoc;
113:               
114:               void __attribute__((interrupt, no_auto_psv)) _DMACError(void)
115:               {
007F06  F80036     PUSH RCOUNT
007F08  BE9F80     MOV.D W0, [W15++]
007F0A  BE9F82     MOV.D W2, [W15++]
007F0C  BE9F84     MOV.D W4, [W15++]
007F0E  BE9F86     MOV.D W6, [W15++]
007F10  FA0000     LNK #0x0
116:               	INTCON1bits.DMACERR = 0;        // Clear the trap flag
007F12  A9A080     BCLR INTCON1, #5
117:               #if defined(__dsPIC33E__)
118:               //	errLoc = getErrLoc();
119:               	dmaErrFlag = DMAPWC;
120:               	//dmaErrFlag = INTCON3bits.DAE;
121:               
122:               // Peripheral Write Collision Error Location
123:               	if (dmaErrFlag &0x1)
124:               		dmaPWErrLoc = DMA0STAL;
125:               
126:               	dmaErrFlag= DMARQC;
127:               
128:               // DMA RAM Write Collision Error Location
129:               	if (dmaErrFlag & 0x2)
130:               		dmaRWErrLoc = DMA1STAL;
131:               
132:               	DMARQC = 0;                     // Clear the DMA Request Collision Flag Bit
133:               	DMAPWC = 0;                     // Clear the Peripheral Write Collision Flag Bit
134:               #endif // __dsPIC33E__
135:               	restart(TRAP_SRC_DMACERR, getErrLoc());
007F14  02800A     CALL _getErrLoc
007F16  000000     NOP
007F18  BE0100     MOV.D W0, W2
007F1A  200400     MOV #0x40, W0
007F1C  07FF98     RCALL restart
136:               }
007F1E  FA8000     ULNK
007F20  BE034F     MOV.D [--W15], W6
007F22  BE024F     MOV.D [--W15], W4
007F24  BE014F     MOV.D [--W15], W2
007F26  BE004F     MOV.D [--W15], W0
007F28  F90036     POP RCOUNT
007F2A  064000     RETFIE
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/serialIO.c  ----------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "oscillator.h"
24:                #include "interrupt.h"
25:                #include "serialIO.h"
26:                
27:                // Baud Rate Generator -- See section 19.3.1 of datasheet.
28:                // Fcy = FREQOSC / CLK_PHASES
29:                // UXBRG = (Fcy/(16*BaudRate))-1
30:                // UXBRG = ((32000000/2)/(16*9600))-1
31:                // UXBRG = 103
32:                
33:                #define UDB_BAUD(x) ((int16_t)((FREQOSC / CLK_PHASES) / ((int32_t)4 * x) - 1))
34:                
35:                ////////////////////////////////////////////////////////////////////////////////
36:                //
37:                // GPS
38:                
39:                static int16_callback_fptr_t gps_callback_get_byte_to_send_fptr = NULL;
40:                static callback_uint8_fptr_t gps_callback_received_byte_fptr = NULL;
41:                
42:                //static boolean udb_serial_stop_sending_flag = 0;
43:                
44:                void udb_init_GPS(int16_callback_fptr_t tx_fptr, callback_uint8_fptr_t rx_fptr)
45:                {
006D28  FA0004     LNK #0x4
006D2A  780F00     MOV W0, [W14]
006D2C  980711     MOV W1, [W14+2]
46:                	gps_callback_get_byte_to_send_fptr = tx_fptr;
006D2E  78001E     MOV [W14], W0
006D30  88F4A0     MOV W0, gps_callback_get_byte_to_send_fptr
47:                	gps_callback_received_byte_fptr = rx_fptr;
006D32  90001E     MOV [W14+2], W0
006D34  88F4B0     MOV W0, gps_callback_received_byte_fptr
48:                
49:                	// configure U1MODE
50:                	U1MODEbits.UARTEN = 0;      // Bit15 TX, RX DISABLED, ENABLE at end of func
006D36  A9E221     BCLR 0x221, #7
51:                	//                          // Bit14
52:                	U1MODEbits.USIDL = 0;       // Bit13 Continue in Idle
006D38  A9A221     BCLR 0x221, #5
53:                	U1MODEbits.IREN = 0;        // Bit12 No IR translation
006D3A  A98221     BCLR 0x221, #4
54:                	U1MODEbits.RTSMD = 0;       // Bit11 Simplex Mode
006D3C  A96221     BCLR 0x221, #3
55:                	//                          // Bit10
56:                	U1MODEbits.UEN = 0;         // Bits8,9 TX,RX enabled, CTS,RTS not
006D3E  801101     MOV U1MODE, W1
006D40  2FCFF0     MOV #0xFCFF, W0
006D42  608000     AND W1, W0, W0
006D44  881100     MOV W0, U1MODE
57:                	U1MODEbits.WAKE = 0;        // Bit7 No Wake up (since we don't sleep here)
006D46  A9E220     BCLR U1MODE, #7
58:                	U1MODEbits.LPBACK = 0;      // Bit6 No Loop Back
006D48  A9C220     BCLR U1MODE, #6
59:                	U1MODEbits.ABAUD = 0;       // Bit5 No Autobaud (would require sending '55')
006D4A  A9A220     BCLR U1MODE, #5
60:                	U1MODEbits.URXINV = 0;      // Bit4 IdleState = 1  (for dsPIC)
006D4C  A98220     BCLR U1MODE, #4
61:                	U1MODEbits.BRGH = 1;        // Bit3 4 clocks per bit period
006D4E  A86220     BSET U1MODE, #3
62:                	U1MODEbits.PDSEL = 0;       // Bits1,2 8bit, No Parity
006D50  801101     MOV U1MODE, W1
006D52  2FFF90     MOV #0xFFF9, W0
006D54  608000     AND W1, W0, W0
006D56  881100     MOV W0, U1MODE
63:                	U1MODEbits.STSEL = 0;       // Bit0 One Stop Bit
006D58  A90220     BCLR U1MODE, #0
64:                
65:                	// Load all values in for U1STA SFR
66:                	U1STAbits.UTXISEL1 = 0;     //Bit15 Int when Char is transferred (1/2 config!)
006D5A  A9E223     BCLR 0x223, #7
67:                	U1STAbits.UTXINV = 0;       //Bit14 N/A, IRDA config
006D5C  A9C223     BCLR 0x223, #6
68:                	U1STAbits.UTXISEL0 = 1;     //Bit13 Other half of Bit15
006D5E  A8A223     BSET 0x223, #5
69:                	//                          //Bit12
70:                	U1STAbits.UTXBRK = 0;       //Bit11 Disabled
006D60  A96223     BCLR 0x223, #3
71:                	//U1STAbits.UTXEN = 1;        //Bit10 TX pins controlled by periph (handled below)
72:                	//U1STAbits.UTXBF = 0;        //Bit9 *Read Only Bit*
73:                	//U1STAbits.TRMT = 0;         //Bit8 *Read Only bit*
74:                	U1STAbits.URXISEL = 0;      //Bits6,7 Int. on character recieved
006D62  801111     MOV U1STA, W1
006D64  2FF3F0     MOV #0xFF3F, W0
006D66  608000     AND W1, W0, W0
006D68  881110     MOV W0, U1STA
75:                	U1STAbits.ADDEN = 0;        //Bit5 Address Detect Disabled
006D6A  A9A222     BCLR U1STA, #5
76:                	//U1STAbits.RIDLE = 0;        //Bit4 *Read Only Bit*
77:                	//U1STAbits.PERR = 0;         //Bit3 *Read Only Bit*
78:                	//U1STAbits.FERR = 0;         //Bit2 *Read Only Bit*
79:                	U1STAbits.OERR = 0;         //Bit1 *Read Only Bit*
006D6C  A92222     BCLR U1STA, #1
80:                	//U1STAbits.URXDA = 0;        //Bit0 *Read Only Bit*
81:                
82:                	_U1TXIP = INT_PRI_U1TX;     // Mid Range Interrupt Priority level, no urgent reason
006D6E  800551     MOV IPC3, W1
006D70  2FFF80     MOV #0xFFF8, W0
006D72  608000     AND W1, W0, W0
006D74  B30030     IOR #0x3, W0
006D76  880550     MOV W0, IPC3
83:                	_U1RXIP = INT_PRI_U1RX;     // Mid Range Interrupt Priority level, no urgent reason
006D78  800541     MOV IPC2, W1
006D7A  28FFF0     MOV #0x8FFF, W0
006D7C  608080     AND W1, W0, W1
006D7E  230000     MOV #0x3000, W0
006D80  708000     IOR W1, W0, W0
006D82  880540     MOV W0, IPC2
84:                
85:                	_U1TXIF = 0;                // Clear the Transmit Interrupt Flag
006D84  A98085     BCLR 0x85, #4
86:                	_U1TXIE = 1;                // Enable Transmit Interrupts
006D86  A88095     BSET 0x95, #4
87:                	_U1RXIF = 0;                // Clear the Receive Interrupt Flag
006D88  A96085     BCLR 0x85, #3
88:                	_U1RXIE = 1;                // Enable Receive Interrupts
006D8A  A86095     BSET 0x95, #3
89:                
90:                	U1MODEbits.UARTEN = 1;      // And turn the peripheral on
006D8C  A8E221     BSET 0x221, #7
91:                	U1STAbits.UTXEN = 1;
006D8E  A84223     BSET 0x223, #2
92:                }
006D90  FA8000     ULNK
006D92  060000     RETURN
93:                
94:                void udb_gps_set_rate(int32_t rate)
95:                {
006D94  FA0004     LNK #0x4
006D96  BE8F00     MOV.D W0, [W14]
96:                #if (CONSOLE_UART != 1)
97:                	U1BRG = UDB_BAUD(rate);
006D98  BE011E     MOV.D [W14], W2
006D9A  DD1842     SL W3, #2, W0
006D9C  DE10CE     LSR W2, #14, W1
006D9E  700081     IOR W0, W1, W1
006DA0  DD1042     SL W2, #2, W0
006DA2  BE0200     MOV.D W0, W4
006DA4  DE884F     ASR W1, #15, W0
006DA6  780300     MOV W0, W6
006DA8  780380     MOV W0, W7
006DAA  248000     MOV #0x4800, W0
006DAC  201E81     MOV #0x1E8, W1
006DAE  B81160     MUL.UU W2, #0, W2
006DB0  0213DC     CALL ___divdi3
006DB2  000000     NOP
006DB4  780000     MOV W0, W0
006DB6  E90000     DEC W0, W0
006DB8  881140     MOV W0, U1BRG
98:                #endif
99:                }
006DBA  FA8000     ULNK
006DBC  060000     RETURN
100:               
101:               boolean udb_gps_check_rate(int32_t rate)
102:               {
006DBE  FA0004     LNK #0x4
006DC0  BE8F00     MOV.D W0, [W14]
103:               	return (U1BRG == UDB_BAUD(rate));
006DC2  BE011E     MOV.D [W14], W2
006DC4  DD1842     SL W3, #2, W0
006DC6  DE10CE     LSR W2, #14, W1
006DC8  700081     IOR W0, W1, W1
006DCA  DD1042     SL W2, #2, W0
006DCC  BE0200     MOV.D W0, W4
006DCE  DE884F     ASR W1, #15, W0
006DD0  780300     MOV W0, W6
006DD2  780380     MOV W0, W7
006DD4  248000     MOV #0x4800, W0
006DD6  201E81     MOV #0x1E8, W1
006DD8  B81160     MUL.UU W2, #0, W2
006DDA  0213DC     CALL ___divdi3
006DDC  000000     NOP
006DDE  780000     MOV W0, W0
006DE0  E90100     DEC W0, W2
006DE2  801141     MOV U1BRG, W1
006DE4  B3C010     MOV.B #0x1, W0
006DE6  510F81     SUB W2, W1, [W15]
006DE8  320001     BRA Z, .L4, .LSM36
006DEA  EB4000     CLR.B W0
104:               }
006DEC  FA8000     ULNK
006DEE  060000     RETURN
105:               
106:               void udb_gps_start_sending_data(void)
107:               {
006DF0  FA0000     LNK #0x0
108:               	_U1TXIF = 1; // fire the tx interrupt
006DF2  A88085     BSET 0x85, #4
109:               }
006DF4  FA8000     ULNK
006DF6  060000     RETURN
110:               
111:               void __attribute__((__interrupt__,__no_auto_psv__)) _U1TXInterrupt(void)
112:               {
006DF8  F80036     PUSH RCOUNT
006DFA  BE9F80     MOV.D W0, [W15++]
006DFC  BE9F82     MOV.D W2, [W15++]
006DFE  BE9F84     MOV.D W4, [W15++]
006E00  BE9F86     MOV.D W6, [W15++]
006E02  FA0002     LNK #0x2
113:               	_U1TXIF = 0; // clear the interrupt
006E04  A98085     BCLR 0x85, #4
114:               	indicate_loading_inter;
115:               	set_ipl_on_output_pin;
116:               	interrupt_save_set_corcon;
006E06  F80044     PUSH CORCON
006E08  80F530     MOV 0x1EA6, W0
006E0A  880220     MOV W0, CORCON
117:               
118:               	int16_t txchar = -1;
006E0C  EB8000     SETM W0
006E0E  780F00     MOV W0, [W14]
119:               #if (HILSIM_USB != 1)
120:               //	txchar = udb_gps_callback_get_byte_to_send();
121:               	if (gps_callback_get_byte_to_send_fptr)
006E10  80F4A0     MOV gps_callback_get_byte_to_send_fptr, W0
006E12  500FE0     SUB W0, #0x0, [W15]
006E14  320003     BRA Z, .L7, .LSM46
122:               	{
123:               		txchar = gps_callback_get_byte_to_send_fptr();
006E16  80F4A0     MOV gps_callback_get_byte_to_send_fptr, W0
006E18  010000     CALL W0
006E1A  780F00     MOV W0, [W14]
124:               	}
125:               #endif // HILSIM_USB
126:               	if (txchar != -1)
006E1C  78001E     MOV [W14], W0
006E1E  400FE1     ADD W0, #0x1, [W15]
006E20  320004     BRA Z, .L8, .LSM48
127:               	{
128:               		U1TXREG = (uint8_t)txchar;
006E22  78001E     MOV [W14], W0
006E24  784000     MOV.B W0, W0
006E26  FB8000     ZE W0, W0
006E28  881120     MOV W0, U1TXREG
129:               	}
130:               	interrupt_restore_corcon;
006E2A  F90044     POP CORCON
131:               	unset_ipl_on_output_pin;
132:               }
006E2C  FA8000     ULNK
006E2E  BE034F     MOV.D [--W15], W6
006E30  BE024F     MOV.D [--W15], W4
006E32  BE014F     MOV.D [--W15], W2
006E34  BE004F     MOV.D [--W15], W0
006E36  F90036     POP RCOUNT
006E38  064000     RETFIE
133:               
134:               void __attribute__((__interrupt__, __no_auto_psv__)) _U1RXInterrupt(void)
135:               {
006E3A  F80036     PUSH RCOUNT
006E3C  BE9F80     MOV.D W0, [W15++]
006E3E  BE9F82     MOV.D W2, [W15++]
006E40  BE9F84     MOV.D W4, [W15++]
006E42  BE9F86     MOV.D W6, [W15++]
006E44  FA0002     LNK #0x2
136:               	_U1RXIF = 0; // clear the interrupt
006E46  A96085     BCLR 0x85, #3
137:               	indicate_loading_inter;
138:               	set_ipl_on_output_pin;
139:               	interrupt_save_set_corcon;
006E48  F80044     PUSH CORCON
006E4A  80F530     MOV 0x1EA6, W0
006E4C  880220     MOV W0, CORCON
140:               	
141:               	while (U1STAbits.URXDA)
006E4E  370008     BRA .L10, .LBE2, .LSM57
006E60  801110     MOV U1STA, W0
006E62  600061     AND W0, #0x1, W0
006E64  500FE0     SUB W0, #0x0, [W15]
006E66  3AFFF4     BRA NZ, .L11, .LBB2, .LSM54
142:               	{
143:               		uint8_t rxchar = U1RXREG;
006E50  801130     MOV U1RXREG, W0
006E52  784F00     MOV.B W0, [W14]
144:               #if (HILSIM_USB != 1)
145:               //		udb_gps_callback_received_byte(rxchar);
146:               		if (gps_callback_received_byte_fptr)
006E54  80F4B0     MOV gps_callback_received_byte_fptr, W0
006E56  500FE0     SUB W0, #0x0, [W15]
006E58  320003     BRA Z, .L10, .LBE2, .LSM57
147:               		{
148:               			gps_callback_received_byte_fptr(rxchar);
006E5A  80F4B1     MOV gps_callback_received_byte_fptr, W1
006E5C  78401E     MOV.B [W14], W0
006E5E  010001     CALL W1
149:               		}
150:               #endif // HILSIM_USB
151:               	}
152:               	U1STAbits.OERR = 0;
006E68  A92222     BCLR U1STA, #1
153:               	interrupt_restore_corcon;
006E6A  F90044     POP CORCON
154:               	unset_ipl_on_output_pin;
155:               }
006E6C  FA8000     ULNK
006E6E  BE034F     MOV.D [--W15], W6
006E70  BE024F     MOV.D [--W15], W4
006E72  BE014F     MOV.D [--W15], W2
006E74  BE004F     MOV.D [--W15], W0
006E76  F90036     POP RCOUNT
006E78  064000     RETFIE
156:               
157:               
158:               /////////////////////////////////////////////////////////////////////////////////////////
159:               // Serial
160:               
161:               int16_callback_fptr_t serial_callback_get_byte_to_send = NULL;
162:               callback_uint8_fptr_t serial_callback_received_byte = NULL;
163:               
164:               void udb_init_USART(int16_callback_fptr_t tx_fptr, callback_uint8_fptr_t rx_fptr)
165:               {
006E7A  FA0004     LNK #0x4
006E7C  780F00     MOV W0, [W14]
006E7E  980711     MOV W1, [W14+2]
166:               	serial_callback_get_byte_to_send = tx_fptr;
006E80  78001E     MOV [W14], W0
006E82  88F480     MOV W0, 0x1E90
167:               	serial_callback_received_byte = rx_fptr;
006E84  90001E     MOV [W14+2], W0
006E86  88F490     MOV W0, .L51
168:               
169:               	// configure U2MODE
170:               	U2MODEbits.UARTEN = 0;      // Bit15 TX, RX DISABLED, ENABLE at end of func
006E88  A9E231     BCLR 0x231, #7
171:               	//                          // Bit14
172:               	U2MODEbits.USIDL = 0;       // Bit13 Continue in Idle
006E8A  A9A231     BCLR 0x231, #5
173:               	U2MODEbits.IREN = 0;        // Bit12 No IR translation
006E8C  A98231     BCLR 0x231, #4
174:               	U2MODEbits.RTSMD = 0;       // Bit11 Simplex Mode
006E8E  A96231     BCLR 0x231, #3
175:               	//                          // Bit10
176:               	U2MODEbits.UEN = 0;         // Bits8,9 TX,RX enabled, CTS,RTS not
006E90  801181     MOV U2MODE, W1
006E92  2FCFF0     MOV #0xFCFF, W0
006E94  608000     AND W1, W0, W0
006E96  881180     MOV W0, U2MODE
177:               	U2MODEbits.WAKE = 0;        // Bit7 No Wake up (since we don't sleep here)
006E98  A9E230     BCLR U2MODE, #7
178:               	U2MODEbits.LPBACK = 0;      // Bit6 No Loop Back
006E9A  A9C230     BCLR U2MODE, #6
179:               	U2MODEbits.ABAUD = 0;       // Bit5 No Autobaud (would require sending '55')
006E9C  A9A230     BCLR U2MODE, #5
180:               	U2MODEbits.URXINV = 0;      // Bit4 IdleState = 1  (for dsPIC)
006E9E  A98230     BCLR U2MODE, #4
181:               	U2MODEbits.BRGH = 1;        // Bit3 4 clocks per bit period
006EA0  A86230     BSET U2MODE, #3
182:               	U2MODEbits.PDSEL = 0;       // Bits1,2 8bit, No Parity
006EA2  801181     MOV U2MODE, W1
006EA4  2FFF90     MOV #0xFFF9, W0
006EA6  608000     AND W1, W0, W0
006EA8  881180     MOV W0, U2MODE
183:               	U2MODEbits.STSEL = 0;       // Bit0 One Stop Bit
006EAA  A90230     BCLR U2MODE, #0
184:               
185:               	// Load all values in for U2STA SFR
186:               	U2STAbits.UTXISEL1 = 0;     //Bit15 Int when Char is transferred (1/2 config!)
006EAC  A9E233     BCLR 0x233, #7
187:               	U2STAbits.UTXINV = 0;       //Bit14 N/A, IRDA config
006EAE  A9C233     BCLR 0x233, #6
188:               	U2STAbits.UTXISEL0 = 1;     //Bit13 Other half of Bit15
006EB0  A8A233     BSET 0x233, #5
189:               	//                          //Bit12
190:               	U2STAbits.UTXBRK = 0;       //Bit11 Disabled
006EB2  A96233     BCLR 0x233, #3
191:               	//U2STAbits.UTXEN = 1;        //Bit10 TX pins controlled by periph (handled below)
192:               	//U2STAbits.UTXBF = 0;        //Bit9 *Read Only Bit*
193:               	//U2STAbits.TRMT = 0;         //Bit8 *Read Only bit*
194:               	U2STAbits.URXISEL = 0;      //Bits6,7 Int. on character recieved
006EB4  801191     MOV U2STA, W1
006EB6  2FF3F0     MOV #0xFF3F, W0
006EB8  608000     AND W1, W0, W0
006EBA  881190     MOV W0, U2STA
195:               	U2STAbits.ADDEN = 0;        //Bit5 Address Detect Disabled
006EBC  A9A232     BCLR U2STA, #5
196:               	//U2STAbits.RIDLE = 0;        //Bit4 *Read Only Bit*
197:               	//U2STAbits.PERR = 0;         //Bit3 *Read Only Bit*
198:               	//U2STAbits.FERR = 0;         //Bit2 *Read Only Bit*
199:               	U2STAbits.OERR = 0;         //Bit1 *Read Only Bit*
006EBE  A92232     BCLR U2STA, #1
200:               	//U2STAbits.URXDA = 0;        //Bit0 *Read Only Bit*
201:               
202:               	_U2TXIP = INT_PRI_U2TX;     // Mid Range Interrupt Priority level, no urgent reason
006EC0  800591     MOV IPC7, W1
006EC2  28FFF0     MOV #0x8FFF, W0
006EC4  608080     AND W1, W0, W1
006EC6  230000     MOV #0x3000, W0
006EC8  708000     IOR W1, W0, W0
006ECA  880590     MOV W0, IPC7
203:               	_U2RXIP = INT_PRI_U2RX;     // Mid Range Interrupt Priority level, no urgent reason
006ECC  800591     MOV IPC7, W1
006ECE  2F8FF0     MOV #0xF8FF, W0
006ED0  608080     AND W1, W0, W1
006ED2  203000     MOV #0x300, W0
006ED4  708000     IOR W1, W0, W0
006ED6  880590     MOV W0, IPC7
204:               
205:               	_U2TXIF = 0;                // Clear the Transmit Interrupt Flag
006ED8  A9E087     BCLR 0x87, #7
206:               	_U2TXIE = 1;                // Enable Transmit Interrupts
006EDA  A8E097     BSET 0x97, #7
207:               	_U2RXIF = 0;                // Clear the Receive Interrupt Flag
006EDC  A9C087     BCLR 0x87, #6
208:               	_U2RXIE = 1;                // Enable Receive Interrupts
006EDE  A8C097     BSET 0x97, #6
209:               
210:               	U2MODEbits.UARTEN = 1;      // And turn the peripheral on
006EE0  A8E231     BSET 0x231, #7
211:               	U2STAbits.UTXEN = 1;
006EE2  A84233     BSET 0x233, #2
212:               }
006EE4  FA8000     ULNK
006EE6  060000     RETURN
213:               
214:               void udb_serial_set_rate(int32_t rate)
215:               {
006EE8  FA0004     LNK #0x4
006EEA  BE8F00     MOV.D W0, [W14]
216:               	U2BRG = UDB_BAUD(rate);
006EEC  BE011E     MOV.D [W14], W2
006EEE  DD1842     SL W3, #2, W0
006EF0  DE10CE     LSR W2, #14, W1
006EF2  700081     IOR W0, W1, W1
006EF4  DD1042     SL W2, #2, W0
006EF6  BE0200     MOV.D W0, W4
006EF8  DE884F     ASR W1, #15, W0
006EFA  780300     MOV W0, W6
006EFC  780380     MOV W0, W7
006EFE  248000     MOV #0x4800, W0
006F00  201E81     MOV #0x1E8, W1
006F02  B81160     MUL.UU W2, #0, W2
006F04  0213DC     CALL ___divdi3
006F06  000000     NOP
006F08  780000     MOV W0, W0
006F0A  E90000     DEC W0, W0
006F0C  8811C0     MOV W0, U2BRG
217:               }
006F0E  FA8000     ULNK
006F10  060000     RETURN
218:               
219:               boolean udb_serial_check_rate(int32_t rate)
220:               {
006F12  FA0004     LNK #0x4
006F14  BE8F00     MOV.D W0, [W14]
221:               	return (U2BRG == UDB_BAUD(rate));
006F16  BE011E     MOV.D [W14], W2
006F18  DD1842     SL W3, #2, W0
006F1A  DE10CE     LSR W2, #14, W1
006F1C  700081     IOR W0, W1, W1
006F1E  DD1042     SL W2, #2, W0
006F20  BE0200     MOV.D W0, W4
006F22  DE884F     ASR W1, #15, W0
006F24  780300     MOV W0, W6
006F26  780380     MOV W0, W7
006F28  248000     MOV #0x4800, W0
006F2A  201E81     MOV #0x1E8, W1
006F2C  B81160     MUL.UU W2, #0, W2
006F2E  0213DC     CALL ___divdi3
006F30  000000     NOP
006F32  780000     MOV W0, W0
006F34  E90100     DEC W0, W2
006F36  8011C1     MOV U2BRG, W1
006F38  B3C010     MOV.B #0x1, W0
006F3A  510F81     SUB W2, W1, [W15]
006F3C  320001     BRA Z, .L15, .LSM97
006F3E  EB4000     CLR.B W0
222:               }
006F40  FA8000     ULNK
006F42  060000     RETURN
223:               /*
224:               void udb_serial_start_sending_data(void)
225:               {
226:               	 udb_serial_stop_sending_flag = false;
227:               	_U2TXIF = 1; // fire the tx interrupt
228:               }
229:               
230:               void udb_serial_stop_sending_data(void)
231:               {
232:               	udb_serial_stop_sending_flag  = true; 
233:               }
234:               */
235:               /*void __attribute__((__interrupt__, __no_auto_psv__)) _U2TXInterrupt(void)
236:               {
237:               	_U2TXIF = 0; // clear the interrupt
238:                   // prevent losing a character when stop and start sending data
239:                   if (U2STAbits.UTXBF == 0)
240:                   {
241:                       indicate_loading_inter;
242:                       set_ipl_on_output_pin;
243:                       interrupt_save_set_corcon;
244:               
245:               //	int16_t txchar = udb_serial_callback_get_byte_to_send();
246:                       int16_t txchar = -1;
247:                       if (serial_callback_get_byte_to_send && ! udb_serial_stop_sending_flag)
248:                       {
249:                           txchar = serial_callback_get_byte_to_send();
250:                       }
251:                       if (txchar != -1)
252:                       {
253:                           U2TXREG = (uint8_t)txchar;
254:                       }
255:                       interrupt_restore_corcon;
256:                       unset_ipl_on_output_pin;
257:                   }
258:               }
259:               */
260:               
261:               void __attribute__((__interrupt__, __no_auto_psv__)) _U2RXInterrupt(void)
262:               {
006F44  F80036     PUSH RCOUNT
006F46  BE9F80     MOV.D W0, [W15++]
006F48  BE9F82     MOV.D W2, [W15++]
006F4A  BE9F84     MOV.D W4, [W15++]
006F4C  BE9F86     MOV.D W6, [W15++]
006F4E  FA0002     LNK #0x2
263:               	_U2RXIF = 0; // clear the interrupt
006F50  A9C087     BCLR 0x87, #6
264:               	indicate_loading_inter;
265:               	set_ipl_on_output_pin;
266:               	interrupt_save_set_corcon;
006F52  F80044     PUSH CORCON
006F54  80F530     MOV 0x1EA6, W0
006F56  880220     MOV W0, CORCON
267:               
268:               	while (U2STAbits.URXDA)
006F58  370008     BRA .L17, .LBE3, .LSM105
006F6A  801190     MOV U2STA, W0
006F6C  600061     AND W0, #0x1, W0
006F6E  500FE0     SUB W0, #0x0, [W15]
006F70  3AFFF4     BRA NZ, .L18, .LBB3, .LSM102
269:               	{
270:               		uint8_t rxchar = U2RXREG;
006F5A  8011B0     MOV U2RXREG, W0
006F5C  784F00     MOV.B W0, [W14]
271:               //		udb_serial_callback_received_byte(rxchar);
272:               		if (serial_callback_received_byte)
006F5E  80F490     MOV .L51, W0
006F60  500FE0     SUB W0, #0x0, [W15]
006F62  320003     BRA Z, .L17, .LBE3, .LSM105
273:               		{
274:               			serial_callback_received_byte(rxchar);
006F64  80F491     MOV .L51, W1
006F66  78401E     MOV.B [W14], W0
006F68  010001     CALL W1
275:               		}
276:               	}
277:               	U2STAbits.OERR = 0;
006F72  A92232     BCLR U2STA, #1
278:               	interrupt_restore_corcon;
006F74  F90044     POP CORCON
279:               	unset_ipl_on_output_pin;
280:               }
006F76  FA8000     ULNK
006F78  BE034F     MOV.D [--W15], W6
006F7A  BE024F     MOV.D [--W15], W4
006F7C  BE014F     MOV.D [--W15], W2
006F7E  BE004F     MOV.D [--W15], W0
006F80  F90036     POP RCOUNT
006F82  064000     RETFIE
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/read.c  --------------------------------------------
1:                 #if defined(__dsPIC33E__)
2:                 #include <p33Exxxx.h>
3:                 #elif defined(__dsPIC33F__)
4:                 #include <p33Fxxxx.h>
5:                 #endif
6:                 
7:                 extern int __C30_UART;
8:                 
9:                 int __attribute__((__weak__, __section__(".libc")))
10:                read(int handle, void *buffer, unsigned int len)
11:                {
0003AA  FA0012     LNK #0x12
0003AC  980760     MOV W0, [W14+12]
0003AE  980771     MOV W1, [W14+14]
0003B0  980F02     MOV W2, [W14+16]
12:                	int i;
13:                	volatile UxMODEBITS *umode = &U1MODEbits;
0003B2  202200     MOV #0x220, W0
0003B4  980710     MOV W0, [W14+2]
14:                	volatile UxSTABITS *ustatus = &U1STAbits;
0003B6  202220     MOV #0x222, W0
0003B8  980720     MOV W0, [W14+4]
15:                	volatile unsigned int *rxreg = &U1RXREG;
0003BA  202260     MOV #0x226, W0
0003BC  980730     MOV W0, [W14+6]
16:                	volatile unsigned int *brg = &U1BRG;
0003BE  202280     MOV #0x228, W0
0003C0  980740     MOV W0, [W14+8]
17:                
18:                	switch (handle)
0003C2  90006E     MOV [W14+12], W0
0003C4  400060     ADD W0, #0x0, W0
0003C6  500FE2     SUB W0, #0x2, [W15]
0003C8  3E0042     BRA GTU, .LSM23, .L14
19:                	{
20:                		case 0:
21:                		case 1:
22:                		case 2:
23:                #ifdef __C30_LEGACY_LIBC__
24:                			if (_Files[0]->_Lockno == 0)
25:                #endif
26:                			{
27:                			if (__C30_UART == 2) {
0003CA  80F560     MOV 0x1EAC, W0
0003CC  500FE2     SUB W0, #0x2, [W15]
0003CE  3A0008     BRA NZ, .LSM11, .L4
28:                				umode = (UxMODEBITS*)&U2MODEbits;
0003D0  202300     MOV #0x230, W0
0003D2  980710     MOV W0, [W14+2]
29:                				ustatus = (UxSTABITS*)&U2STAbits;
0003D4  202320     MOV #0x232, W0
0003D6  980720     MOV W0, [W14+4]
30:                				rxreg = &U2RXREG;
0003D8  202360     MOV #0x236, W0
0003DA  980730     MOV W0, [W14+6]
31:                				brg = &U2BRG;
0003DC  202380     MOV #0x238, W0
0003DE  980740     MOV W0, [W14+8]
32:                			}
33:                #if defined (__dsPIC33E__)
34:                			if (__C30_UART == 3) {
35:                				umode = (UxMODEBITS*)&U3MODEbits;
36:                				ustatus = (UxSTABITS*)&U3STAbits;
37:                				rxreg = &U3RXREG;
38:                				brg = &U3BRG;
39:                			}
40:                			if (__C30_UART == 4) {
41:                				umode = (UxMODEBITS*)&U4MODEbits;
42:                				ustatus = (UxSTABITS*)&U4STAbits;
43:                				rxreg = &U4RXREG;
44:                				brg = &U4BRG;
45:                			}
46:                #endif // __dsPIC33E__
47:                				if ((umode->UARTEN) == 0)
0003E0  90001E     MOV [W14+2], W0
0003E2  780090     MOV [W0], W1
0003E4  280000     MOV #0x8000, W0
0003E6  608000     AND W1, W0, W0
0003E8  500FE0     SUB W0, #0x0, [W15]
0003EA  3A0008     BRA NZ, .LSM14, .L5
48:                				{
49:                					*brg = 0;
0003EC  90004E     MOV [W14+8], W0
0003EE  EB0080     CLR W1
0003F0  780801     MOV W1, [W0]
50:                					umode->UARTEN = 1;
0003F2  90001E     MOV [W14+2], W0
0003F4  780110     MOV [W0], W2
0003F6  280001     MOV #0x8000, W1
0003F8  710081     IOR W2, W1, W1
0003FA  780801     MOV W1, [W0]
51:                				}
52:                				for (i = len; i; --i)
0003FC  90080E     MOV [W14+16], W0
0003FE  780F00     MOV W0, [W14]
000400  37001C     BRA .L6
000438  E90F1E     DEC [W14], [W14]
00043A  78001E     MOV [W14], W0
00043C  500FE0     SUB W0, #0x0, [W15]
00043E  3AFFE1     BRA NZ, .LBB2, .LSM15, .L12
000440  370001     BRA .LSM21, .L11
53:                				{
54:                					int nTimeout;
55:                
56:                					// Timeout is 16 cycles per 10-bit char
57:                					nTimeout = 16*10;
000402  200A00     MOV #0xA0, W0
000404  980750     MOV W0, [W14+10]
58:                					while (((ustatus->URXDA) == 0) && nTimeout) --nTimeout;
000406  370003     BRA .L7
000408  90005E     MOV [W14+10], W0
00040A  E90000     DEC W0, W0
00040C  980750     MOV W0, [W14+10]
00040E  90002E     MOV [W14+4], W0
000410  780010     MOV [W0], W0
000412  600061     AND W0, #0x1, W0
000414  500FE0     SUB W0, #0x0, [W15]
000416  3A0003     BRA NZ, .LSM17, .L8
000418  90005E     MOV [W14+10], W0
00041A  500FE0     SUB W0, #0x0, [W15]
00041C  3AFFF5     BRA NZ, .L9
59:                					if ((ustatus->URXDA) == 0) break;
00041E  90002E     MOV [W14+4], W0
000420  780010     MOV [W0], W0
000422  600061     AND W0, #0x1, W0
000424  500FE0     SUB W0, #0x0, [W15]
000426  32000D     BRA Z, .LSM20, .L15
000442  000000     NOP
60:                					*(char*)buffer++ = *rxreg;
000428  9000FE     MOV [W14+14], W1
00042A  90003E     MOV [W14+6], W0
00042C  780010     MOV [W0], W0
00042E  784000     MOV.B W0, W0
000430  784880     MOV.B W0, [W1]
000432  90007E     MOV [W14+14], W0
000434  E80000     INC W0, W0
000436  980770     MOV W0, [W14+14]
61:                				}
62:                				len -= i;
000444  78001E     MOV [W14], W0
000446  90088E     MOV [W14+16], W1
000448  508000     SUB W1, W0, W0
00044A  980F00     MOV W0, [W14+16]
63:                				break;
00044C  370001     BRA .LSM24, .L13
64:                			}
65:                
66:                		default: {
67:                /*
68:                			SIMIO simio;
69:                			register PSIMIO psimio asm("w0");
70:                
71:                			psimio = &simio;
72:                			simio.method = SIM_READ;
73:                			simio.u.read.handle = handle;
74:                			simio.u.read.buffer = buffer;
75:                			simio.u.read.len = len;
76:                			doread(psimio);
77:                
78:                			len = simio.u.read.len;
79:                 */
80:                			break;
00044E  000000     NOP
81:                		}
82:                	}
83:                	return len;
000450  90080E     MOV [W14+16], W0
84:                }
000452  FA8000     ULNK
000454  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/mpu_spi.c  -----------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                
24:                #if (BOARD_TYPE != UDB4_BOARD)
25:                
26:                #include "oscillator.h"
27:                #include "interrupt.h"
28:                #include "mpu_spi.h"
29:                #include <delay.h>
30:                #include <spi.h>
31:                
32:                #if (MPU_SPI == 1)
33:                
34:                #define MPU_SS       SPI1_SS
35:                #define MPU_SS_TRIS  SPI1_TRIS
36:                #define _SPIRBF      SPI1STATbits.SPIRBF
37:                #define _SPIROV      SPI1STATbits.SPIROV
38:                #define _SRXMPT      SPI1STATbits.SRXMPT
39:                #define _SPIBEC      SPI1STATbits.SPIBEC
40:                #define _SRMPT       SPI1STATbits.SRMPT
41:                #define _SPIIF       _SPI1IF
42:                #define _SPIIP       _SPI1IP
43:                #define _SPIIE       _SPI1IE
44:                #define SPIBUF       SPI1BUF
45:                #define SPISTAT      SPI1STAT
46:                #define OpenSPI      OpenSPI1
47:                #define CloseSPI     CloseSPI1
48:                #define ConfigIntSPI ConfigIntSPI1
49:                #define SPIInterrupt _SPI1Interrupt
50:                
51:                #elif (MPU_SPI == 2)
52:                
53:                #define MPU_SS       SPI2_SS
54:                #define MPU_SS_TRIS  SPI2_TRIS
55:                #undef  _SPIRBF
56:                #define _SPIRBF      SPI2STATbits.SPIRBF
57:                #undef  _SPIROV
58:                #define _SPIROV      SPI2STATbits.SPIROV
59:                #define _SRXMPT      SPI2STATbits.SRXMPT
60:                #define _SPIBEC      SPI2STATbits.SPIBEC
61:                #define _SRMPT       SPI2STATbits.SRMPT
62:                #define _SPIIF       _SPI2IF
63:                #define _SPIIP       _SPI2IP
64:                #define _SPIIE       _SPI2IE
65:                #define SPIBUF       SPI2BUF
66:                #define SPISTAT      SPI2STAT
67:                #define OpenSPI      OpenSPI2
68:                #define CloseSPI     CloseSPI2
69:                #define ConfigIntSPI ConfigIntSPI2
70:                #define SPIInterrupt _SPI2Interrupt
71:                
72:                #else
73:                #error "Select either 1 or 2 for MPU SPI."
74:                #endif
75:                
76:                
77:                static void no_call_back(void);
78:                
79:                static void (*mpu_call_back)(void) = &no_call_back;
80:                static uint16_t* SPI_data;
81:                static uint8_t SPI_high;
82:                static uint8_t SPI_low;
83:                #ifndef __dsPIC33E__
84:                static int16_t SPI_i;
85:                static int16_t SPI_j;
86:                static int16_t SPI_n;
87:                #endif
88:                
89:                
90:                // Configure SPI module in 16-bit master mode
91:                void initMPUSPI_master16(uint16_t priPre, uint16_t secPre)
92:                {
007A0C  FA000A     LNK #0xA
007A0E  980730     MOV W0, [W14+6]
007A10  980741     MOV W1, [W14+8]
93:                	uint16_t SPICON1Value;      // holds the information about SPI configuration
94:                	uint16_t SPICON2Value;
95:                	uint16_t SPISTATValue;      // holds the information about SPI Enable/Disable
96:                
97:                	MPU_SS = 1;                 // deassert MPU SS
007A12  A822E9     BSET 0x2E9, #1
98:                	MPU_SS_TRIS = 0;            // make MPU SS an output
007A14  A922E5     BCLR 0x2E5, #1
99:                	CloseSPI();                 // turn off SPI module
007A16  020DB4     CALL _CloseSPI2
007A18  000000     NOP
100:               	ConfigIntSPI(SPI_INT_DIS & SPI_INT_PRI_6);
007A1A  2FFF60     MOV #0xFFF6, W0
007A1C  020DBC     CALL _ConfigIntSPI2
007A1E  000000     NOP
101:               
102:               #if defined(__dsPIC33E__)
103:               	SPICON1Value =
104:               	    ENABLE_SDO_PIN & SPI_MODE16_ON & ENABLE_SCK_PIN &
105:               	    SPI_SMP_OFF & SPI_CKE_OFF &
106:               	    SLAVE_ENABLE_OFF &
107:               	    CLK_POL_ACTIVE_LOW &
108:               	    MASTER_ENABLE_ON &
109:               	    secPre & priPre;
110:               	SPICON2Value = FRAME_ENABLE_OFF & FRAME_SYNC_OUTPUT; // & FIFO_BUFFER_DISABLE;
111:               	SPISTATValue = SPI_ENABLE & SPI_IDLE_CON & SPI_RX_OVFLOW_CLR & BUF_INT_SEL_5;
112:               	// BUF_INT_SEL_5 == Interrupt when the last bit is shifted out of SPIxSR, and the transmit is complete
113:               #else
114:               	SPICON1Value =
007A26  2E67F0     MOV #0xE67F, W0
007A28  608F00     AND W1, W0, [W14]
115:               	    ENABLE_SDO_PIN & SPI_MODE16_ON & ENABLE_SCK_PIN &
116:               	    SPI_SMP_ON & SPI_CKE_OFF &
117:               	    SLAVE_ENABLE_OFF &
118:               	    CLK_POL_ACTIVE_LOW &
119:               	    MASTER_ENABLE_ON &
120:               	    secPre & priPre;
007A20  9000CE     MOV [W14+8], W1
007A22  90003E     MOV [W14+6], W0
007A24  608080     AND W1, W0, W1
121:               	SPICON2Value = FRAME_ENABLE_OFF & FRAME_SYNC_OUTPUT;
007A2A  23FFF0     MOV #0x3FFF, W0
007A2C  980710     MOV W0, [W14+2]
122:               	SPISTATValue = SPI_ENABLE & SPI_IDLE_CON & SPI_RX_OVFLOW_CLR;
007A2E  2DFBF0     MOV #0xDFBF, W0
007A30  980720     MOV W0, [W14+4]
123:               #endif
124:               
125:               #ifdef __PIC32MX__
126:               //	 * Example: OpenSPI1(SPI_MODE32_ON|SPI_SMP_ON|MASTER_ENABLE_ON|SEC_PRESCAL_1_1|PRI_PRESCAL_1_1, SPI_ENABLE);
127:               	OpenSPI(SPICON1Value, SPISTATValue);
128:               #else
129:               	OpenSPI(SPICON1Value, SPICON2Value, SPISTATValue);
007A32  90012E     MOV [W14+4], W2
007A34  90009E     MOV [W14+2], W1
007A36  78001E     MOV [W14], W0
007A38  020DDE     CALL _OpenSPI2
007A3A  000000     NOP
130:               //	printf("SPI1STAT %04X, SPI1CON1 %04X, SPI1CON2 %04X\r\n", SPI1STAT, SPI1CON1, SPI1CON2);
131:               #endif
132:               
133:               	_SPIROV = 0;                // clear SPI receive overflow
007A3C  A9C260     BCLR SPI2STAT, #6
134:               	_SPIIF  = 0;                // clear any pending interrupts
007A3E  A92088     BCLR IFS2, #1
135:               	_SPIIP  = INT_PRI_MPUSPI;   // set interrupt priority
007A40  8005A1     MOV IPC8, W1
007A42  2FF8F0     MOV #0xFF8F, W0
007A44  608080     AND W1, W0, W1
007A46  200600     MOV #0x60, W0
007A48  708000     IOR W1, W0, W0
007A4A  8805A0     MOV W0, IPC8
136:               //	_SPIIE  = 1;                // turn on SPI interrupts
137:               }
007A4C  FA8000     ULNK
007A4E  060000     RETURN
138:               
139:               // Blocking 16 bit write to SPI
140:               void writeMPUSPIreg16(uint16_t addr, uint16_t data)
141:               {
007A50  FA0006     LNK #0x6
007A52  980710     MOV W0, [W14+2]
007A54  980721     MOV W1, [W14+4]
142:               	int16_t k;
143:               
144:               	MPU_SS = 0;                 // assert chip select
007A56  A922E9     BCLR 0x2E9, #1
145:               	k = SPIBUF;
007A58  801340     MOV SPI2BUF, W0
007A5A  780F00     MOV W0, [W14]
146:               	_SPIIE = 0;                 // ensure the interrupt is disabled
007A5C  A92098     BCLR IEC2, #1
147:               	_SPIIF = 0;                 // ensure the interrupt flag is clear
007A5E  A92088     BCLR IFS2, #1
148:               	SPIBUF = addr << 8 | data;  // send address and data
007A60  90001E     MOV [W14+2], W0
007A62  DD00C8     SL W0, #8, W1
007A64  90002E     MOV [W14+4], W0
007A66  708000     IOR W1, W0, W0
007A68  881340     MOV W0, SPI2BUF
149:               #if 1
150:               	while (!_SPIIF);            // wait for transfer to complete
007A6A  000000     NOP
007A6C  800440     MOV IFS2, W0
007A6E  600062     AND W0, #0x2, W0
007A70  500FE0     SUB W0, #0x0, [W15]
007A72  32FFFC     BRA Z, .L3
151:               	_SPIIF = 0;                 // clear interrupt flag
007A74  A92088     BCLR IFS2, #1
152:               #else
153:               	delay_us(32+2);             // allow 16 cycles at 500kHz for the write
154:               #endif
155:               	k = SPIBUF;                 // dump received data
007A76  801340     MOV SPI2BUF, W0
007A78  780F00     MOV W0, [W14]
156:               	MPU_SS = 1;                 // deassert chip select
007A7A  A822E9     BSET 0x2E9, #1
157:               	// this delay is necessary; it appears that SS must be deasserted for one or
158:               	// more SPI clock cycles between writes
159:               //	delayUs(1);
160:               	delay_us(1);
007A7C  200200     MOV #0x20, W0
007A7E  200001     MOV #0x0, W1
007A80  02806C     CALL ___delay32, .Letext0, .LFE1
007A82  000000     NOP
161:               }
007A84  FA8000     ULNK
007A86  060000     RETURN
162:               
163:               static void no_call_back(void)
164:               {
007A88  FA0000     LNK #0x0
165:               }
007A8A  FA8000     ULNK
007A8C  060000     RETURN
166:               
167:               #if defined(__dsPIC33E__)
168:               
169:               // SPI module has 8 word FIFOs
170:               // burst read 2n bytes starting at addr;
171:               // Since first byte is address, max of 15 data bytes may be transferred with n=7
172:               void readMPUSPI_burst16n(uint16_t data[], int16_t n, uint16_t addr, void (*call_back)(void))
173:               {
174:               	uint16_t i;
175:               
176:               	MPU_SS = 0;                 // assert chip select
177:               	mpu_call_back = call_back;  // store the address of the call back routine
178:               	SPI_data = &data[0];        // store address of data buffer
179:               	i = SPIBUF;                 // empty read buffer
180:               	addr |= 0x80;               // write address-1 in high byte + n-1 dummy words to TX FIFO
181:               	SPIBUF = addr << 8;         // issue read command
182:               	for (i = 0; i < n; i++) {
183:               		SPIBUF = 0;             // queue 'n' null words into the SPI transmit buffer
184:               	}
185:               	_SPIIE = 1;                 // turn on SPI interrupts
186:               }
187:               
188:               // this ISR empties the RX FIFO into the SPI_data buffer
189:               // no possibility of overrun if buffer length is at least 8 words
190:               void __attribute__((__interrupt__, __no_auto_psv__)) SPIInterrupt(void)
191:               {
192:               	uint16_t spibuf;
193:               
194:               	_SPIIF = 0;                 // clear interrupt flag as soon as possible so as to not miss any interrupts
195:               	indicate_loading_inter;
196:               	set_ipl_on_output_pin;
197:               	interrupt_save_set_corcon;
198:               	_SPIIE = 0;                 // turn off SPI interrupts
199:               	spibuf = SPIBUF;            // get first byte from first word
200:               	SPI_high = 0xFF & spibuf;
201:               
202:               	while (!_SRXMPT) {          // empty the FIFO
203:               		spibuf = SPIBUF;
204:               		SPI_low = spibuf >> 8;
205:               		*SPI_data++ = SPI_high << 8 | SPI_low;
206:               		SPI_high = 0xFF & spibuf;
207:               	}
208:               	MPU_SS = 1;
209:               	(*mpu_call_back)();
210:               	interrupt_restore_corcon;
211:               	unset_ipl_on_output_pin;
212:               }
213:               
214:               #else // no SPI FIFO
215:               
216:               // burst read 2n bytes starting at addr
217:               void readMPUSPI_burst16n(uint16_t data[], int16_t n, uint16_t addr, void (*call_back)(void))
218:               {
007A8E  FA000A     LNK #0xA
007A90  980710     MOV W0, [W14+2]
007A92  980721     MOV W1, [W14+4]
007A94  980732     MOV W2, [W14+6]
007A96  980743     MOV W3, [W14+8]
219:               	uint16_t spibuf;
220:               
221:               	MPU_SS = 0;                 // assert chip select
007A98  A922E9     BCLR 0x2E9, #1
222:               	mpu_call_back = call_back;  // save address of call back routine
007A9A  90004E     MOV [W14+8], W0
007A9C  88F540     MOV W0, 0x1EA8
223:               	SPI_i = 0;                  // initialize indices
007A9E  EB0000     CLR W0
007AA0  88F270     MOV W0, SPI_i
224:               	SPI_j = 0;
007AA2  EB0000     CLR W0
007AA4  88F280     MOV W0, SPI_j
225:               	SPI_n = n;
007AA6  90002E     MOV [W14+4], W0
007AA8  88F290     MOV W0, SPI_n
226:               	SPI_data = &data[0];        // save address of data buffer
007AAA  90001E     MOV [W14+2], W0
007AAC  88F250     MOV W0, SPI_data
227:               	addr |= 0x80;
007AAE  9000BE     MOV [W14+6], W1
007AB0  200800     MOV #0x80, W0
007AB2  708000     IOR W1, W0, W0
007AB4  980730     MOV W0, [W14+6]
228:               	spibuf = SPIBUF;
007AB6  801340     MOV SPI2BUF, W0
007AB8  780F00     MOV W0, [W14]
229:               	SPIBUF = addr << 8;         // issue read command
007ABA  90003E     MOV [W14+6], W0
007ABC  DD0048     SL W0, #8, W0
007ABE  881340     MOV W0, SPI2BUF
230:               	_SPIIE = 1;                 // turn on SPI interrupts
007AC0  A82098     BSET IEC2, #1
231:               }
007AC2  FA8000     ULNK
007AC4  060000     RETURN
232:               
233:               void __attribute__((__interrupt__, __no_auto_psv__)) SPIInterrupt(void)
234:               {
007AC6  F80036     PUSH RCOUNT
007AC8  BE9F80     MOV.D W0, [W15++]
007ACA  BE9F82     MOV.D W2, [W15++]
007ACC  BE9F84     MOV.D W4, [W15++]
007ACE  BE9F86     MOV.D W6, [W15++]
007AD0  FA0002     LNK #0x2
235:               	uint16_t spibuf;
236:               
237:               	_SPIIF = 0;                 // clear interrupt flag as soon as possible so as to not miss any interrupts
007AD2  A92088     BCLR IFS2, #1
238:               	indicate_loading_inter;
239:               	set_ipl_on_output_pin;
240:               	interrupt_save_set_corcon;
007AD4  F80044     PUSH CORCON
007AD6  80F530     MOV 0x1EA6, W0
007AD8  880220     MOV W0, CORCON
241:               #if 1
242:               	if (SPI_i == 0) {
007ADA  80F270     MOV SPI_i, W0
007ADC  500FE0     SUB W0, #0x0, [W15]
007ADE  3A000B     BRA NZ, .L7, .LSM48
243:               		spibuf = SPIBUF;                               // could move this to before the conditional
007AE0  801340     MOV SPI2BUF, W0
007AE2  780F00     MOV W0, [W14]
244:               		SPIBUF = 0x0000;
007AE4  EB0000     CLR W0
007AE6  881340     MOV W0, SPI2BUF
245:               		SPI_high = 0xFF & spibuf;                      // could move this to after the conditional
007AE8  78001E     MOV [W14], W0
007AEA  784000     MOV.B W0, W0
007AEC  21E4C1     MOV #0x1E4C, W1
007AEE  784880     MOV.B W0, [W1]
246:               		SPI_i = 1;
007AF0  200010     MOV #0x1, W0
007AF2  88F270     MOV W0, SPI_i
007AF4  37003D     BRA .L8, .LSM62
247:               	} else if (SPI_i < SPI_n) {
007AF6  80F271     MOV SPI_i, W1
007AF8  80F290     MOV SPI_n, W0
007AFA  508F80     SUB W1, W0, [W15]
007AFC  3D0021     BRA GE, .L9, .LSM56
248:               		spibuf = SPIBUF;                               // could move this to before the conditional
007AFE  801340     MOV SPI2BUF, W0
007B00  780F00     MOV W0, [W14]
249:               		SPIBUF = 0x0000;
007B02  EB0000     CLR W0
007B04  881340     MOV W0, SPI2BUF
250:               		SPI_low = spibuf >> 8;                         // could move this to before the conditional
007B06  78001E     MOV [W14], W0
007B08  DE0048     LSR W0, #8, W0
007B0A  784000     MOV.B W0, W0
007B0C  21E4D1     MOV #0x1E4D, W1
007B0E  784880     MOV.B W0, [W1]
251:               		*(SPI_data + SPI_j) = SPI_high << 8 | SPI_low; // could move this to before the conditional
007B10  80F251     MOV SPI_data, W1
007B12  80F280     MOV SPI_j, W0
007B14  400000     ADD W0, W0, W0
007B16  408080     ADD W1, W0, W1
007B18  21E4C0     MOV #0x1E4C, W0
007B1A  784010     MOV.B [W0], W0
007B1C  FB8000     ZE W0, W0
007B1E  DD0148     SL W0, #8, W2
007B20  21E4D0     MOV #0x1E4D, W0
007B22  784010     MOV.B [W0], W0
007B24  FB8000     ZE W0, W0
007B26  710000     IOR W2, W0, W0
007B28  780880     MOV W0, [W1]
252:               		SPI_high = 0xFF & spibuf;                      // could move this to after the conditional
007B2A  78001E     MOV [W14], W0
007B2C  784000     MOV.B W0, W0
007B2E  21E4C1     MOV #0x1E4C, W1
007B30  784880     MOV.B W0, [W1]
253:               		SPI_i++;
007B32  80F270     MOV SPI_i, W0
007B34  E80000     INC W0, W0
007B36  88F270     MOV W0, SPI_i
254:               		SPI_j++;
007B38  80F280     MOV SPI_j, W0
007B3A  E80000     INC W0, W0
007B3C  88F280     MOV W0, SPI_j
007B3E  370018     BRA .L8, .LSM62
255:               	} else {
256:               		spibuf = SPIBUF;                               // could move this to before the conditional
007B40  801340     MOV SPI2BUF, W0
007B42  780F00     MOV W0, [W14]
257:               		SPI_low = spibuf >> 8;                         // could move this to before the conditional
007B44  78001E     MOV [W14], W0
007B46  DE0048     LSR W0, #8, W0
007B48  784000     MOV.B W0, W0
007B4A  21E4D1     MOV #0x1E4D, W1
007B4C  784880     MOV.B W0, [W1]
258:               		*(SPI_data + SPI_j) = SPI_high << 8 | SPI_low; // could move this to before the conditional
007B4E  80F251     MOV SPI_data, W1
007B50  80F280     MOV SPI_j, W0
007B52  400000     ADD W0, W0, W0
007B54  408080     ADD W1, W0, W1
007B56  21E4C0     MOV #0x1E4C, W0
007B58  784010     MOV.B [W0], W0
007B5A  FB8000     ZE W0, W0
007B5C  DD0148     SL W0, #8, W2
007B5E  21E4D0     MOV #0x1E4D, W0
007B60  784010     MOV.B [W0], W0
007B62  FB8000     ZE W0, W0
007B64  710000     IOR W2, W0, W0
007B66  780880     MOV W0, [W1]
259:               		MPU_SS = 1;
007B68  A822E9     BSET 0x2E9, #1
260:               		_SPIIE = 0;             // turn off SPI interrupts
007B6A  A92098     BCLR IEC2, #1
261:               		(*mpu_call_back)();
007B6C  80F540     MOV 0x1EA8, W0
007B6E  010000     CALL W0
262:               	}
263:               #else
264:               	spibuf = SPIBUF;
265:               	SPI_low = spibuf >> 8;
266:               	*(SPI_data + SPI_j) = SPI_high << 8 | SPI_low;
267:               	SPI_i++;
268:               	if (SPI_i == 1) {
269:               		SPIBUF = 0x0000;
270:               	} else if (SPI_i <= SPI_n) {
271:               		SPIBUF = 0x0000;
272:               		SPI_j++;
273:               	} else {
274:               		MPU_SS = 1;
275:               		_SPIIE = 0;             // turn off SPI interrupts
276:               		(*mpu_call_back)();
277:               	}
278:               	SPI_high = 0xFF & spibuf;
279:               #endif // 0
280:               	interrupt_restore_corcon;
007B70  F90044     POP CORCON
281:               	unset_ipl_on_output_pin;
282:               }
007B72  FA8000     ULNK
007B74  BE034F     MOV.D [--W15], W6
007B76  BE024F     MOV.D [--W15], W4
007B78  BE014F     MOV.D [--W15], W2
007B7A  BE004F     MOV.D [--W15], W0
007B7C  F90036     POP RCOUNT
007B7E  064000     RETFIE
283:               
284:               #endif // (__dsPIC33E__)
285:               
286:               uint16_t readMPUSPIreg16(uint16_t addr)
287:               {
007B80  FA0004     LNK #0x4
007B82  980710     MOV W0, [W14+2]
288:               	int16_t data;
289:               
290:               #if defined(__dsPIC33E__)
291:               	while (_SRXMPT == 0)        // clear receive FIFO
292:               #endif
293:               	{
294:               		data = SPIBUF;          // empty receive buffer
007B84  801340     MOV SPI2BUF, W0
007B86  780F00     MOV W0, [W14]
295:               	}
296:               	MPU_SS = 0;                 // assert chip select
007B88  A922E9     BCLR 0x2E9, #1
297:               	_SPIIE = 0;                 // ensure the interrupt is disabled
007B8A  A92098     BCLR IEC2, #1
298:               	_SPIIF = 0;                 // ensure the interrupt flag is clear
007B8C  A92088     BCLR IFS2, #1
299:               	addr |= 0x80;               // set the read bit in addr byte
007B8E  90009E     MOV [W14+2], W1
007B90  200800     MOV #0x80, W0
007B92  708000     IOR W1, W0, W0
007B94  980710     MOV W0, [W14+2]
300:               	SPIBUF = addr << 8;         // issue read command
007B96  90001E     MOV [W14+2], W0
007B98  DD0048     SL W0, #8, W0
007B9A  881340     MOV W0, SPI2BUF
301:               //	while (!_SRMPT);            // wait for transfer to complete
302:               	while (!_SPIIF);            // wait for transfer to complete
007B9C  000000     NOP
007B9E  800440     MOV IFS2, W0
007BA0  600062     AND W0, #0x2, W0
007BA2  500FE0     SUB W0, #0x0, [W15]
007BA4  32FFFC     BRA Z, .L11
303:               	_SPIIF = 0;                 // clear interrupt flag
007BA6  A92088     BCLR IFS2, #1
304:               	data = SPIBUF;
007BA8  801340     MOV SPI2BUF, W0
007BAA  780F00     MOV W0, [W14]
305:               	MPU_SS = 1;
007BAC  A822E9     BSET 0x2E9, #1
306:               //	delayUs(40);
307:               	delay_us(40);
007BAE  205000     MOV #0x500, W0
007BB0  200001     MOV #0x0, W1
007BB2  02806C     CALL ___delay32, .Letext0, .LFE1
007BB4  000000     NOP
308:               	return data;
007BB6  78001E     MOV [W14], W0
309:               }
007BB8  FA8000     ULNK
007BBA  060000     RETURN
310:               
311:               #if 0 // experimental blocking 8 bit read for dsPIC33EP
312:               
313:               // FIXME: why doesn't this work? read FIFO is all zeros even though non-zero data is observed on MISO
314:               uint8_t readMPUSPIreg16(uint16_t addr)
315:               {
316:               	int16_t k, data[8];
317:               
318:               //	while (_SRXMPT == 0) {
319:               //		data[k] = SPIBUF;       // clear receive FIFO
320:               //	}
321:               	k = SPISTAT;
322:               	_SPIROV = 0;
323:               	MPU_SS = 0;                 // assert chip select
324:               	addr |= 0x80;               // set the read bit in addr byte
325:               	SPIBUF = addr << 8;         // issue read command
326:               	while (_SPIBEC);            // wait for TX FIFO to empty
327:               	while (!_SRMPT);            // wait for last transfer to complete
328:               	MPU_SS = 1;
329:               	delay_us(20);
330:               	MPU_SS = 0;
331:               	SPIBUF = addr << 8;         // issue read command
332:               	while (_SPIBEC);            // wait for TX FIFO to empty
333:               	while (!_SRMPT);            // wait for last transfer to complete
334:               	data[0] = SPIBUF;
335:               	data[1] = SPIBUF;
336:               //	for (k = 0; k < 8; k++) {
337:               //		data[k] = SPIBUF;       // read one word from FIFO
338:               //	}
339:               	MPU_SS = 1;                 // deassert chip select for a while
340:               	delay_us(40);
341:               	return 0xFF & data[0];
342:               }
343:               
344:               #endif // 0
345:               
346:               #endif // BOARD_TYPE
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/mpu6000.c  -----------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2012 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                // Internal MPU6000 axis definition
22:                // X axis pointing to right, Y axis pointing forward and Z axis pointing up
23:                
24:                
25:                #include "libUDB.h"
26:                #include "oscillator.h"
27:                #include "interrupt.h"
28:                #include "heartbeat.h"
29:                #include "ADchannel.h"
30:                #include "mpu_spi.h"
31:                #include "mpu6000.h"
32:                #include "../libDCM/matrix_vector_32_bit.h"
33:                //#include "../libUDB/udbTypes.h"
34:                
35:                boolean is_ICM_20689 = 0;
36:                //uint16_t mpu_whoami = 0;
37:                
38:                #if (BOARD_TYPE != UDB4_BOARD)
39:                
40:                #include <spi.h>
41:                
42:                //Sensor variables
43:                uint16_t mpu_data[8], mpuCnt = 0;
44:                boolean mpuDAV = false;
45:                
46:                //struct ADchannel udb_xaccel, udb_yaccel, udb_zaccel; // x, y, and z accelerometer channels
47:                //struct ADchannel udb_xrate,  udb_yrate,  udb_zrate;  // x, y, and z gyro channels
48:                struct ADchannel mpu_temp;
49:                int16_t vref_adj;
50:                
51:                // MPU6000 Initialization and configuration
52:                
53:                static callback_fptr_t callback = NULL;
54:                
55:                void MPU6000_init16(callback_fptr_t fptr)
56:                {
005CF6  FA0006     LNK #0x6
005CF8  980720     MOV W0, [W14+4]
57:                	callback = fptr;
005CFA  90002E     MOV [W14+4], W0
005CFC  88DC20     MOV W0, callback
58:                
59:                // MPU-6000 maximum SPI clock is specified as 1 MHz for all registers
60:                //    however the datasheet states that the sensor and interrupt registers
61:                //    may be read using an SPI clock of 20 Mhz
62:                //    NOTE!!: the SPI limit on the dsPIC is 9 Mhz
63:                
64:                // Primary prescaler options   1:1/4/16/64
65:                // Secondary prescaler options 1:1 to 1:8
66:                
67:                // As these register accesses are one time only during initial setup lets be
68:                //    conservative and only run the SPI bus at half the maximum specified speed
69:                
70:                #if (MIPS == 70)
71:                	// set prescaler for FCY/112 = 625 kHz at 70MIPS
72:                	initMPUSPI_master16(SEC_PRESCAL_7_1, PRI_PRESCAL_16_1);
73:                #elif (MIPS == 64)
74:                	// set prescaler for FCY/96 = 667 kHz at 64MIPS
75:                	initMPUSPI_master16(SEC_PRESCAL_6_1, PRI_PRESCAL_16_1);
76:                #elif (MIPS == 40)
77:                	// set prescaler for FCY/64 = 625 KHz at 40MIPS
78:                	initMPUSPI_master16(SEC_PRESCAL_4_1, PRI_PRESCAL_16_1);
79:                #elif (MIPS == 32)
80:                	// set prescaler for FCY/48 = 667 kHz at 32 MIPS
81:                //	initMPUSPI_master16(SEC_PRESCAL_3_1, PRI_PRESCAL_16_1);
82:                	// set prescaler for FCY/24 = 1.33 MHz at 32 MIPS
83:                	initMPUSPI_master16(SEC_PRESCAL_6_1, PRI_PRESCAL_4_1);	
005CFE  2FFFE1     MOV #0xFFFE, W1
005D00  2FFEB0     MOV #0xFFEB, W0
005D02  027A0C     CALL initMPUSPI_master16
005D04  000000     NOP
84:                #elif (MIPS == 16)
85:                	// set prescaler for FCY/24 = 667 kHz at 16MIPS
86:                	initMPUSPI_master16(SEC_PRESCAL_6_1, PRI_PRESCAL_4_1);
87:                #else
88:                #error Invalid MIPS Configuration
89:                #endif // MIPS
90:                
91:                	// need at least 60 msec delay here
92:                	delay_ms(60);
005D06  24C000     MOV #0x4C00, W0
005D08  2001D1     MOV #0x1D, W1
005D0A  02806C     CALL ___delay32, .Letext0, .LFE1
005D0C  000000     NOP
93:                	writeMPUSPIreg16(MPUREG_PWR_MGMT_1, BIT_H_RESET);
005D0E  200801     MOV #0x80, W1
005D10  2006B0     MOV #0x6B, W0
005D12  027A50     CALL writeMPUSPIreg16
005D14  000000     NOP
94:                
95:                	// 10msec delay seems to be needed for AUAV3 (MW's prototype)
96:                	delay_ms(10);
005D16  2E2000     MOV #0xE200, W0
005D18  200041     MOV #0x4, W1
005D1A  02806C     CALL ___delay32, .Letext0, .LFE1
005D1C  000000     NOP
97:                
98:                	// Wake up device and select GyroZ clock (better performance)
99:                	writeMPUSPIreg16(MPUREG_PWR_MGMT_1, MPU_CLK_SEL_PLLGYROZ);
005D1E  200031     MOV #0x3, W1
005D20  2006B0     MOV #0x6B, W0
005D22  027A50     CALL writeMPUSPIreg16
005D24  000000     NOP
100:               	
101:               	// Which chip is this?
102:               	uint16_t mpu_whoami = readMPUSPIreg16(MPUREG_WHOAMI) ;
005D26  200750     MOV #0x75, W0
005D28  027B80     CALL readMPUSPIreg16
005D2A  000000     NOP
005D2C  780F00     MOV W0, [W14]
103:               	is_ICM_20689 = (mpu_whoami == WHOAMI_ICM_20689) ;
005D2E  B3C010     MOV.B #0x1, W0
005D30  200981     MOV #0x98, W1
005D32  78011E     MOV [W14], W2
005D34  510F81     SUB W2, W1, [W15]
005D36  320001     BRA Z, .L2
005D38  EB4000     CLR.B W0
005D3A  27FCC1     MOV #0x7FCC, W1
005D3C  784880     MOV.B W0, [W1]
104:               //	mpu_whoami = readMPUSPIreg16(MPUREG_WHOAMI) ;
105:               
106:               	// Disable I2C bus (recommended on datasheet)
107:               	writeMPUSPIreg16(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
005D3E  200101     MOV #0x10, W1
005D40  2006A0     MOV #0x6A, W0
005D42  027A50     CALL writeMPUSPIreg16
005D44  000000     NOP
108:               	
109:               	if (is_ICM_20689) {
005D46  27FCC0     MOV #0x7FCC, W0
005D48  784010     MOV.B [W0], W0
005D4A  504FE0     SUB.B W0, #0x0, [W15]
005D4C  320010     BRA Z, .L3, .LBE2, .LSM14
110:               //	if (mpu_whoami == WHOAMI_ICM_20689 || mpu_whoami == WHOAMI_ICM_20600) {
111:               		// Disable I2C communications on the ICM_20689
112:               		uint8_t v = readMPUSPIreg16(MPUREG_INT_PIN_CFG) | BIT_INT_RD_CLEAR | BIT_LATCH_INT_EN;
005D4E  200370     MOV #0x37, W0
005D50  027B80     CALL readMPUSPIreg16
005D52  000000     NOP
005D54  784080     MOV.B W0, W1
005D56  B3C300     MOV.B #0x30, W0
005D58  70C000     IOR.B W1, W0, W0
005D5A  984720     MOV.B W0, [W14+2]
113:               		v &= BIT_I2C_BYPASS_EN;
005D5C  90402E     MOV.B [W14+2], W0
005D5E  604062     AND.B W0, #0x2, W0
005D60  984720     MOV.B W0, [W14+2]
114:               		writeMPUSPIreg16(MPUREG_INT_PIN_CFG, v);
005D62  90402E     MOV.B [W14+2], W0
005D64  FB8000     ZE W0, W0
005D66  780080     MOV W0, W1
005D68  200370     MOV #0x37, W0
005D6A  027A50     CALL writeMPUSPIreg16
005D6C  000000     NOP
115:               	}
116:               
117:               	// SAMPLE RATE
118:               //	writeMPUSPIreg16(MPUREG_SMPLRT_DIV, 4); // Sample rate = 200Hz  Fsample= 1Khz/(N+1) = 200Hz
119:               	writeMPUSPIreg16(MPUREG_SMPLRT_DIV, 0); // Sample_rate = 8000Hz
005D6E  EB0080     CLR W1
005D70  200190     MOV #0x19, W0
005D72  027A50     CALL writeMPUSPIreg16
005D74  000000     NOP
120:               	// scaling & DLPF
121:               #ifdef BUILD_OFFSET_TABLE
122:               	writeMPUSPIreg16(MPUREG_CONFIG, BITS_DLPF_CFG_5HZ);
123:               #else
124:               //	writeMPUSPIreg16(MPUREG_CONFIG, BITS_DLPF_CFG_188HZ);
125:               	writeMPUSPIreg16(MPUREG_CONFIG, 0); 
005D76  EB0080     CLR W1
005D78  2001A0     MOV #0x1A, W0
005D7A  027A50     CALL writeMPUSPIreg16
005D7C  000000     NOP
126:               #endif // BUILD_OFFSET_TABLE
127:               #if (GYRO_RANGE == 250 )
128:               	writeMPUSPIreg16(MPUREG_GYRO_CONFIG, BITS_FS_250DPS);  // Gyro scale 250/s
129:               #elif (GYRO_RANGE == 500 )
130:               	writeMPUSPIreg16(MPUREG_GYRO_CONFIG, BITS_FS_500DPS);  // Gyro scale 500/s
131:               #elif (GYRO_RANGE == 1000 )
132:               	writeMPUSPIreg16(MPUREG_GYRO_CONFIG, BITS_FS_1000DPS); // Gyro scale 1000/s
005D7E  200101     MOV #0x10, W1
005D80  2001B0     MOV #0x1B, W0
005D82  027A50     CALL writeMPUSPIreg16
005D84  000000     NOP
133:               #elif (GYRO_RANGE == 2000 )
134:               	writeMPUSPIreg16(MPUREG_GYRO_CONFIG, BITS_FS_2000DPS); // Gyro scale 2000/s
135:               #else
136:               #error "Invalid GYRO_RANGE"
137:               #endif // GYRO_RANGE 
138:               
139:               	
140:               	if (is_ICM_20689) {
005D86  27FCC0     MOV #0x7FCC, W0
005D88  784010     MOV.B [W0], W0
005D8A  504FE0     SUB.B W0, #0x0, [W15]
005D8C  320005     BRA Z, .L4, .LSM19
141:               //	if (mpu_whoami == WHOAMI_ICM_20689 || mpu_whoami == WHOAMI_ICM_20600) {
142:               	#if (ACCEL_RANGE == 2)
143:               		writeMPUSPIreg16(MPUREG_ACCEL_CONFIG, 0<<3); // Accel scele 2g, g = 8192
144:               	#elif (ACCEL_RANGE == 4)
145:               		writeMPUSPIreg16(MPUREG_ACCEL_CONFIG, 1<<3); // Accel scele 4g, g = 4096
146:               	#elif (ACCEL_RANGE == 8)
147:               		writeMPUSPIreg16(MPUREG_ACCEL_CONFIG, 2<<3); // Accel scele 8g, g = 2048
005D8E  200101     MOV #0x10, W1
005D90  2001C0     MOV #0x1C, W0
005D92  027A50     CALL writeMPUSPIreg16
005D94  000000     NOP
005D96  370004     BRA .L5, .LSM20
148:               	#else
149:               		#error "Invalid ACCEL_RANGE"
150:               	#endif
151:               	}
152:               	else {
153:               	#if (ACCEL_RANGE == 2)
154:               		writeMPUSPIreg16(MPUREG_ACCEL_CONFIG, BITS_FS_2G); // Accel scele 2g, g = 8192
155:               	#elif (ACCEL_RANGE == 4)
156:               		writeMPUSPIreg16(MPUREG_ACCEL_CONFIG, BITS_FS_4G); // Accel scale 4g = 4096
157:               	#elif (ACCEL_RANGE == 8)
158:               		writeMPUSPIreg16(MPUREG_ACCEL_CONFIG, BITS_FS_8G); // Accel scale 8g = 2048
005D98  200101     MOV #0x10, W1
005D9A  2001C0     MOV #0x1C, W0
005D9C  027A50     CALL writeMPUSPIreg16
005D9E  000000     NOP
159:               	#else
160:               		#error "Invalid ACCEL_RANGE"
161:               	#endif
162:               	}
163:               
164:               	// INT CFG => Interrupt on Data Ready, totem-pole (push-pull) output
165:               	writeMPUSPIreg16(MPUREG_INT_PIN_CFG, BIT_INT_LEVEL | BIT_INT_RD_CLEAR); // INT: Clear on any read
005DA0  200901     MOV #0x90, W1
005DA2  200370     MOV #0x37, W0
005DA4  027A50     CALL writeMPUSPIreg16
005DA6  000000     NOP
166:               	writeMPUSPIreg16(MPUREG_INT_ENABLE, BIT_DATA_RDY_EN); // INT: Raw data ready
005DA8  200011     MOV #0x1, W1
005DAA  200380     MOV #0x38, W0
005DAC  027A50     CALL writeMPUSPIreg16
005DAE  000000     NOP
167:               
168:               // Bump the SPI clock up towards 20 MHz for ongoing sensor and interrupt register reads
169:               // 20 MHz is the maximum specified for the MPU-6000
170:               // however 9 MHz is the maximum specified for the dsPIC33EP
171:               // Primary prescaler options   1:1/4/16/64
172:               // Secondary prescaler options 1:1 to 1:8
173:               #if (MIPS == 70)
174:               	// set prescaler for FCY/32 = 2.2 MHz at 70MIPS
175:               	initMPUSPI_master16(SEC_PRESCAL_2_1, PRI_PRESCAL_16_1);
176:               #elif (MIPS == 64)
177:               	// set prescaler for FCY/8 = 8 MHz at 64 MIPS
178:               	initMPUSPI_master16(SEC_PRESCAL_2_1, PRI_PRESCAL_4_1);
179:               #elif (MIPS == 40)
180:               	// UDB5 only
181:               	// set prescaler for FCY/5 = 8 MHz at 40MIPS
182:               	initMPUSPI_master16(SEC_PRESCAL_5_1, PRI_PRESCAL_1_1);
183:               #elif (MIPS == 32)
184:               	// set prescaler for FCY/4 = 8 MHz at 32 MIPS
185:               	initMPUSPI_master16(SEC_PRESCAL_1_1, PRI_PRESCAL_4_1);
005DB0  2FFFE1     MOV #0xFFFE, W1
005DB2  EB8000     SETM W0
005DB4  027A0C     CALL initMPUSPI_master16
005DB6  000000     NOP
186:               #elif (MIPS == 16)
187:               	// set prescaler for FCY/2 = 8 MHz at 16 MIPS
188:               	initMPUSPI_master16(SEC_PRESCAL_2_1, PRI_PRESCAL_1_1);
189:               #else
190:               #error Invalid MIPS Configuration
191:               #endif // MIPS
192:               
193:               	_TRISMPUINT = 1; // this is probably already taken care of in mcu.c for most boards
005DB8  A8C2C1     BSET 0x2C1, #6
194:               
195:               #if (MPU_SPI == 1)
196:               	_INT1EP = 1; // Setup INT1 pin to interrupt on falling edge
197:               	_INT1IP = INT_PRI_INT1;
198:               	_INT1IF = 0; // Reset INT1 interrupt flag
199:               	_INT1IE = 1; // Enable INT1 Interrupt Service Routine 
200:               #elif (MPU_SPI == 2)
201:               	_INT3EP = 1; // Setup INT3 pin to interrupt on falling edge
005DBA  A86082     BSET INTCON2, #3
202:               	_INT3IP = INT_PRI_INT3;
005DBC  8005F1     MOV IPC13, W1
005DBE  2FF8F0     MOV #0xFF8F, W0
005DC0  608080     AND W1, W0, W1
005DC2  200600     MOV #0x60, W0
005DC4  708000     IOR W1, W0, W0
005DC6  8805F0     MOV W0, IPC13
203:               	_INT3IF = 0; // Reset INT3 interrupt flag
005DC8  A9A08A     BCLR IFS3, #5
204:               	_INT3IE = 1; // Enable INT3 Interrupt Service Routine 
005DCA  A8A09A     BSET IEC3, #5
205:               #endif
206:               }
005DCC  FA8000     ULNK
005DCE  060000     RETURN
207:               
208:               #define SAMPLE_HZ 8000
209:               #define GGAINX_32 (double)CALIBRATIONX*(double)SCALEGYRO*(double)24*((double)RMAX*((double)1.0/(double)SAMPLE_HZ))
210:               #define GGAINY_32 (double)CALIBRATIONY*(double)SCALEGYRO*(double)24*((double)RMAX*((double)1.0/(double)SAMPLE_HZ))
211:               #define GGAINZ_32 (double)CALIBRATIONZ*(double)SCALEGYRO*(double)24*((double)RMAX*((double)1.0/(double)SAMPLE_HZ))
212:               
213:               int32_t ggain_32[] =  { (double)256*(double)256*(double)GGAINX_32 , 
214:               	(double)256*(double)256*GGAINY_32, 
215:               	(double)256*(double)256*GGAINZ_32 };
216:               
217:               
218:               union longww delta_coning_angle32[3] ;
219:               int16_t theta_16[3] ;
220:               union longww omega32[3] ;
221:               union longww theta_32[3] ;
222:               union longww _theta_32[3] ;
223:               union longww omega_dt[3];
224:               extern union longww omegagyro_filtered[];
225:               
226:               void compute_one_half_angle_cross_omega(void)
227:               {
005DD0  FA0000     LNK #0x0
228:               	cross_product_32(delta_coning_angle32,_theta_32,omega_dt );
005DD2  21BBC2     MOV #0x1BBC, W2
005DD4  21BB01     MOV #0x1BB0, W1
005DD6  21B860     MOV #0x1B86, W0
005DD8  027018     CALL cross_product_32
005DDA  000000     NOP
229:               	delta_coning_angle32[0].WW *= 2 ;
005DDC  80DC30     MOV delta_coning_angle32, W0
005DDE  80DC41     MOV 0x1B88, W1
005DE0  400000     ADD W0, W0, W0
005DE2  488081     ADDC W1, W1, W1
005DE4  88DC30     MOV W0, delta_coning_angle32
005DE6  88DC41     MOV W1, 0x1B88
230:               	delta_coning_angle32[1].WW *= 2 ;
005DE8  80DC50     MOV 0x1B8A, W0
005DEA  80DC61     MOV 0x1B8C, W1
005DEC  400000     ADD W0, W0, W0
005DEE  488081     ADDC W1, W1, W1
005DF0  88DC50     MOV W0, 0x1B8A
005DF2  88DC61     MOV W1, 0x1B8C
231:               	delta_coning_angle32[2].WW *= 2 ;
005DF4  80DC70     MOV 0x1B8E, W0
005DF6  80DC81     MOV 0x1B90, W1
005DF8  400000     ADD W0, W0, W0
005DFA  488081     ADDC W1, W1, W1
005DFC  88DC70     MOV W0, 0x1B8E
005DFE  88DC81     MOV W1, 0x1B90
232:               }
005E00  FA8000     ULNK
005E02  060000     RETURN
233:               
234:               void compute_coning_adjustment(void)
235:               {
005E04  FA0000     LNK #0x0
236:               	omega32[0]._.W1 = XRATE_SIGN_ORIENTED ((((int16_t)mpu_data[xrate_MPU_channel])>>1 )
005E06  80DB80     MOV 0x1B70, W0
005E08  D18080     ASR W0, W1
005E0E  508000     SUB W1, W0, W0
005E10  88DCD0     MOV W0, 0x1B9A
237:               			- (udb_xrate.offset>>1));
005E0A  80E570     MOV 0x1CAE, W0
005E0C  D18000     ASR W0, W0
238:               	omega32[1]._.W1 = YRATE_SIGN_ORIENTED ((((int16_t)mpu_data[yrate_MPU_channel])>>1 )
005E16  80DB90     MOV 0x1B72, W0
005E18  D18000     ASR W0, W0
005E1A  508000     SUB W1, W0, W0
005E1C  88DCF0     MOV W0, 0x1B9E
239:               			- (udb_yrate.offset>>1));
005E12  80E5C0     MOV 0x1CB8, W0
005E14  D18080     ASR W0, W1
240:               	omega32[2]._.W1 = ZRATE_SIGN_ORIENTED ((((int16_t)mpu_data[zrate_MPU_channel])>>1 )
005E22  80DBA0     MOV 0x1B74, W0
005E24  D18000     ASR W0, W0
005E26  508000     SUB W1, W0, W0
005E28  88DD10     MOV W0, 0x1BA2
241:               			- (udb_zrate.offset>>1));
005E1E  80E610     MOV 0x1CC2, W0
005E20  D18080     ASR W0, W1
242:               
243:               	omega32[0]._.W0 = 0 ;
005E2A  EB0000     CLR W0
005E2C  88DCC0     MOV W0, omega32
244:               	omega32[1]._.W0 = 0 ;
005E2E  EB0000     CLR W0
005E30  88DCE0     MOV W0, 0x1B9C
245:               	omega32[2]._.W0 = 0 ;
005E32  EB0000     CLR W0
005E34  88DD00     MOV W0, 0x1BA0
246:               	
247:               	omega32[0].WW += omegagyro_filtered[0].WW ;
005E36  80DCC2     MOV omega32, W2
005E38  80DCD3     MOV 0x1B9A, W3
005E3A  80D5B0     MOV .L10, W0
005E3C  80D5C1     MOV 0x1AB8, W1
005E3E  400002     ADD W0, W2, W0
005E40  488083     ADDC W1, W3, W1
005E42  88DCC0     MOV W0, omega32
005E44  88DCD1     MOV W1, 0x1B9A
248:               	omega32[1].WW += omegagyro_filtered[1].WW ;
005E46  80DCE2     MOV 0x1B9C, W2
005E48  80DCF3     MOV 0x1B9E, W3
005E4A  80D5D0     MOV 0x1ABA, W0
005E4C  80D5E1     MOV 0x1ABC, W1
005E4E  400002     ADD W0, W2, W0
005E50  488083     ADDC W1, W3, W1
005E52  88DCE0     MOV W0, 0x1B9C
005E54  88DCF1     MOV W1, 0x1B9E
249:               	omega32[2].WW += omegagyro_filtered[2].WW ;
005E56  80DD02     MOV 0x1BA0, W2
005E58  80DD13     MOV 0x1BA2, W3
005E5A  80D5F0     MOV 0x1ABE, W0
005E5C  80D601     MOV 0x1AC0, W1
005E5E  400002     ADD W0, W2, W0
005E60  488083     ADDC W1, W3, W1
005E62  88DD00     MOV W0, 0x1BA0
005E64  88DD11     MOV W1, 0x1BA2
250:               	
251:               	omega_dt[0].WW = fract_32_mpy(omega32[0].WW,ggain_32[0]);
005E66  83FE90     MOV .LSM20, W0
005E68  83FEA1     MOV 0x7FD4, W1
005E6A  80DCC4     MOV omega32, W4
005E6C  80DCD5     MOV 0x1B9A, W5
005E6E  BE0100     MOV.D W0, W2
005E70  BE0004     MOV.D W4, W0
005E72  026F84     CALL fract_32_mpy
005E74  000000     NOP
005E76  88DDE0     MOV W0, omega_dt
005E78  88DDF1     MOV W1, 0x1BBE
252:               	omega_dt[1].WW = fract_32_mpy(omega32[1].WW,ggain_32[1]);
005E7A  83FEB0     MOV .LSM21, W0
005E7C  83FEC1     MOV 0x7FD8, W1
005E7E  80DCE4     MOV 0x1B9C, W4
005E80  80DCF5     MOV 0x1B9E, W5
005E82  BE0100     MOV.D W0, W2
005E84  BE0004     MOV.D W4, W0
005E86  026F84     CALL fract_32_mpy
005E88  000000     NOP
005E8A  88DE00     MOV W0, 0x1BC0
005E8C  88DE11     MOV W1, 0x1BC2
253:               	omega_dt[2].WW = fract_32_mpy(omega32[2].WW,ggain_32[2]);
005E8E  83FED0     MOV 0x7FDA, W0
005E90  83FEE1     MOV 0x7FDC, W1
005E92  80DD04     MOV 0x1BA0, W4
005E94  80DD15     MOV 0x1BA2, W5
005E96  BE0100     MOV.D W0, W2
005E98  BE0004     MOV.D W4, W0
005E9A  026F84     CALL fract_32_mpy
005E9C  000000     NOP
005E9E  88DE20     MOV W0, 0x1BC4
005EA0  88DE31     MOV W1, 0x1BC6
254:               	
255:               	compute_one_half_angle_cross_omega();
005EA2  07FF96     RCALL compute_one_half_angle_cross_omega
256:               	
257:               	_theta_32[0].WW += 	omega_dt[0].WW + delta_coning_angle32[0].WW ;
005EA4  80DD82     MOV _theta_32, W2
005EA6  80DD93     MOV 0x1BB2, W3
005EA8  80DDE4     MOV omega_dt, W4
005EAA  80DDF5     MOV 0x1BBE, W5
005EAC  80DC30     MOV delta_coning_angle32, W0
005EAE  80DC41     MOV 0x1B88, W1
005EB0  400004     ADD W0, W4, W0
005EB2  488085     ADDC W1, W5, W1
005EB4  400002     ADD W0, W2, W0
005EB6  488083     ADDC W1, W3, W1
005EB8  88DD80     MOV W0, _theta_32
005EBA  88DD91     MOV W1, 0x1BB2
258:               	_theta_32[1].WW += 	omega_dt[1].WW + delta_coning_angle32[1].WW ;
005EBC  80DDA2     MOV 0x1BB4, W2
005EBE  80DDB3     MOV 0x1BB6, W3
005EC0  80DE04     MOV 0x1BC0, W4
005EC2  80DE15     MOV 0x1BC2, W5
005EC4  80DC50     MOV 0x1B8A, W0
005EC6  80DC61     MOV 0x1B8C, W1
005EC8  400004     ADD W0, W4, W0
005ECA  488085     ADDC W1, W5, W1
005ECC  400002     ADD W0, W2, W0
005ECE  488083     ADDC W1, W3, W1
005ED0  88DDA0     MOV W0, 0x1BB4
005ED2  88DDB1     MOV W1, 0x1BB6
259:               	_theta_32[2].WW += 	omega_dt[2].WW + delta_coning_angle32[2].WW ;	
005ED4  80DDC2     MOV .L3, W2
005ED6  80DDD3     MOV 0x1BBA, W3
005ED8  80DE24     MOV 0x1BC4, W4
005EDA  80DE35     MOV 0x1BC6, W5
005EDC  80DC70     MOV 0x1B8E, W0
005EDE  80DC81     MOV 0x1B90, W1
005EE0  400004     ADD W0, W4, W0
005EE2  488085     ADDC W1, W5, W1
005EE4  400002     ADD W0, W2, W0
005EE6  488083     ADDC W1, W3, W1
005EE8  88DDC0     MOV W0, .L3
005EEA  88DDD1     MOV W1, 0x1BBA
260:               }
005EEC  FA8000     ULNK
005EEE  060000     RETURN
261:               
262:               void reset_coning_adjustment(void)
263:               {
005EF0  FA0000     LNK #0x0
264:               	_theta_32[0].WW = 0 ;
005EF2  B80060     MUL.UU W0, #0, W0
005EF4  88DD80     MOV W0, _theta_32
005EF6  88DD91     MOV W1, 0x1BB2
265:               	_theta_32[1].WW = 0 ;
005EF8  B80060     MUL.UU W0, #0, W0
005EFA  88DDA0     MOV W0, 0x1BB4
005EFC  88DDB1     MOV W1, 0x1BB6
266:               	_theta_32[2].WW = 0 ;	
005EFE  B80060     MUL.UU W0, #0, W0
005F00  88DDC0     MOV W0, .L3
005F02  88DDD1     MOV W1, 0x1BBA
267:               }
005F04  FA8000     ULNK
005F06  060000     RETURN
268:               
269:               int16_t sample_counter = 0 ;
270:               
271:               int32_t xaccel32, yaccel32, zaccel32, temp32, xrate32, yrate32, zrate32 ;
272:               
273:               static void process_MPU_data(void)
274:               {
005F08  FA0000     LNK #0x0
275:               	mpuDAV = true;
005F0A  27FD01     MOV #0x7FD0, W1
005F0C  B3C010     MOV.B #0x1, W0
005F0E  784880     MOV.B W0, [W1]
276:               	
277:               	xaccel32 += ((int32_t)((int16_t)mpu_data[xaccel_MPU_channel])) ;
005F10  80DB40     MOV mpu_data, W0
005F12  B90161     MUL.SU W0, #1, W2
005F14  80DE40     MOV xaccel32, W0
005F16  80DE51     MOV 0x1BCA, W1
005F18  400002     ADD W0, W2, W0
005F1A  488083     ADDC W1, W3, W1
005F1C  88DE40     MOV W0, xaccel32
005F1E  88DE51     MOV W1, 0x1BCA
278:               	yaccel32 += ((int32_t)((int16_t)mpu_data[yaccel_MPU_channel])) ;
005F20  80DB50     MOV 0x1B6A, W0
005F22  B90161     MUL.SU W0, #1, W2
005F24  80DE60     MOV yaccel32, W0
005F26  80DE71     MOV .L2, W1
005F28  400002     ADD W0, W2, W0
005F2A  488083     ADDC W1, W3, W1
005F2C  88DE60     MOV W0, yaccel32
005F2E  88DE71     MOV W1, .L2
279:               	zaccel32 += ((int32_t)((int16_t)mpu_data[zaccel_MPU_channel])) ;
005F30  80DB60     MOV .L11, W0
005F32  B90161     MUL.SU W0, #1, W2
005F34  80DE80     MOV zaccel32, W0
005F36  80DE91     MOV 0x1BD2, W1
005F38  400002     ADD W0, W2, W0
005F3A  488083     ADDC W1, W3, W1
005F3C  88DE80     MOV W0, zaccel32
005F3E  88DE91     MOV W1, 0x1BD2
280:               	
281:               	temp32 += ((int32_t)((int16_t)mpu_data[temp_MPU_channel])) ;
005F40  80DB70     MOV .L6, W0
005F42  B90161     MUL.SU W0, #1, W2
005F44  80DEA0     MOV temp32, W0
005F46  80DEB1     MOV 0x1BD6, W1
005F48  400002     ADD W0, W2, W0
005F4A  488083     ADDC W1, W3, W1
005F4C  88DEA0     MOV W0, temp32
005F4E  88DEB1     MOV W1, 0x1BD6
282:               	
283:               	xrate32 += ((int32_t)((int16_t)mpu_data[xrate_MPU_channel])) ;
005F50  80DB80     MOV 0x1B70, W0
005F52  B90161     MUL.SU W0, #1, W2
005F54  80DEC0     MOV xrate32, W0
005F56  80DED1     MOV 0x1BDA, W1
005F58  400002     ADD W0, W2, W0
005F5A  488083     ADDC W1, W3, W1
005F5C  88DEC0     MOV W0, xrate32
005F5E  88DED1     MOV W1, 0x1BDA
284:               	yrate32 += ((int32_t)((int16_t)mpu_data[yrate_MPU_channel])) ;
005F60  80DB90     MOV 0x1B72, W0
005F62  B90161     MUL.SU W0, #1, W2
005F64  80DEE0     MOV yrate32, W0
005F66  80DEF1     MOV 0x1BDE, W1
005F68  400002     ADD W0, W2, W0
005F6A  488083     ADDC W1, W3, W1
005F6C  88DEE0     MOV W0, yrate32
005F6E  88DEF1     MOV W1, 0x1BDE
285:               	zrate32 += ((int32_t)((int16_t)mpu_data[zrate_MPU_channel])) ;
005F70  80DBA0     MOV 0x1B74, W0
005F72  B90161     MUL.SU W0, #1, W2
005F74  80DF00     MOV zrate32, W0
005F76  80DF11     MOV 0x1BE2, W1
005F78  400002     ADD W0, W2, W0
005F7A  488083     ADDC W1, W3, W1
005F7C  88DF00     MOV W0, zrate32
005F7E  88DF11     MOV W1, 0x1BE2
286:               
287:               #ifdef CONING_CORRECTION	
288:               	compute_coning_adjustment();
005F80  07FF41     RCALL compute_coning_adjustment
289:               #endif
290:               	//  trigger synchronous processing of sensor data
291:               	sample_counter = sample_counter+1 ;
005F82  83FEF0     MOV .L9, .LSM22, W0
005F84  E80000     INC W0, W0
005F86  8BFEF0     MOV W0, .L9, .LSM22
292:               	if (sample_counter == 40)
005F88  83FEF1     MOV .L9, .LSM22, W1
005F8A  200280     MOV #0x28, W0
005F8C  508F80     SUB W1, W0, [W15]
005F8E  3A008D     BRA NZ, .L9, .LSM100
293:               	{
294:               		udb_xaccel.value = __builtin_divsd(xaccel32+20,40);
005F90  80DE40     MOV xaccel32, W0
005F92  80DE51     MOV 0x1BCA, W1
005F94  400074     ADD W0, #0x14, W0
005F96  4880E0     ADDC W1, #0x0, W1
005F98  200282     MOV #0x28, W2
005F9A  781F81     MOV W1, [W15++]
005F9C  090011     REPEAT #0x11
005F9E  D80842     DIV.SD W0, W2
005FA0  7800CF     MOV [--W15], W1
005FA2  88E470     MOV W0, 0x1C8E
295:               		udb_yaccel.value = __builtin_divsd(yaccel32+20,40);
005FA4  80DE60     MOV yaccel32, W0
005FA6  80DE71     MOV .L2, W1
005FA8  400074     ADD W0, #0x14, W0
005FAA  4880E0     ADDC W1, #0x0, W1
005FAC  200282     MOV #0x28, W2
005FAE  781F81     MOV W1, [W15++]
005FB0  090011     REPEAT #0x11
005FB2  D80842     DIV.SD W0, W2
005FB4  7800CF     MOV [--W15], W1
005FB6  88E4C0     MOV W0, 0x1C98
296:               		udb_zaccel.value = __builtin_divsd(zaccel32+20,40);
005FB8  80DE80     MOV zaccel32, W0
005FBA  80DE91     MOV 0x1BD2, W1
005FBC  400074     ADD W0, #0x14, W0
005FBE  4880E0     ADDC W1, #0x0, W1
005FC0  200282     MOV #0x28, W2
005FC2  781F81     MOV W1, [W15++]
005FC4  090011     REPEAT #0x11
005FC6  D80842     DIV.SD W0, W2
005FC8  7800CF     MOV [--W15], W1
005FCA  88E510     MOV W0, 0x1CA2
297:               
298:               		mpu_temp.value = __builtin_divsd(temp32+20,40);
005FCC  80DEA0     MOV temp32, W0
005FCE  80DEB1     MOV 0x1BD6, W1
005FD0  400074     ADD W0, #0x14, W0
005FD2  4880E0     ADDC W1, #0x0, W1
005FD4  200282     MOV #0x28, W2
005FD6  781F81     MOV W1, [W15++]
005FD8  090011     REPEAT #0x11
005FDA  D80842     DIV.SD W0, W2
005FDC  7800CF     MOV [--W15], W1
005FDE  88DBD0     MOV W0, 0x1B7A
299:               
300:               		udb_xrate.value = __builtin_divsd(xrate32+20,40);
005FE0  80DEC0     MOV xrate32, W0
005FE2  80DED1     MOV 0x1BDA, W1
005FE4  400074     ADD W0, #0x14, W0
005FE6  4880E0     ADDC W1, #0x0, W1
005FE8  200282     MOV #0x28, W2
005FEA  781F81     MOV W1, [W15++]
005FEC  090011     REPEAT #0x11
005FEE  D80842     DIV.SD W0, W2
005FF0  7800CF     MOV [--W15], W1
005FF2  88E560     MOV W0, 0x1CAC
301:               		udb_yrate.value = __builtin_divsd(yrate32+20,40);
005FF4  80DEE0     MOV yrate32, W0
005FF6  80DEF1     MOV 0x1BDE, W1
005FF8  400074     ADD W0, #0x14, W0
005FFA  4880E0     ADDC W1, #0x0, W1
005FFC  200282     MOV #0x28, W2
005FFE  781F81     MOV W1, [W15++]
006000  090011     REPEAT #0x11
006002  D80842     DIV.SD W0, W2
006004  7800CF     MOV [--W15], W1
006006  88E5B0     MOV W0, 0x1CB6
302:               		udb_zrate.value = __builtin_divsd(zrate32+20,40);
006008  80DF00     MOV zrate32, W0
00600A  80DF11     MOV 0x1BE2, W1
00600C  400074     ADD W0, #0x14, W0
00600E  4880E0     ADDC W1, #0x0, W1
006010  200282     MOV #0x28, W2
006012  781F81     MOV W1, [W15++]
006014  090011     REPEAT #0x11
006016  D80842     DIV.SD W0, W2
006018  7800CF     MOV [--W15], W1
00601A  88E600     MOV W0, 0x1CC0
303:               		
304:               		xaccel32 = 0 ;
00601C  B80060     MUL.UU W0, #0, W0
00601E  88DE40     MOV W0, xaccel32
006020  88DE51     MOV W1, 0x1BCA
305:               		yaccel32 = 0 ;
006022  B80060     MUL.UU W0, #0, W0
006024  88DE60     MOV W0, yaccel32
006026  88DE71     MOV W1, .L2
306:               		zaccel32 = 0 ;
006028  B80060     MUL.UU W0, #0, W0
00602A  88DE80     MOV W0, zaccel32
00602C  88DE91     MOV W1, 0x1BD2
307:               		temp32 = 0 ;
00602E  B80060     MUL.UU W0, #0, W0
006030  88DEA0     MOV W0, temp32
006032  88DEB1     MOV W1, 0x1BD6
308:               		xrate32 = 0 ;
006034  B80060     MUL.UU W0, #0, W0
006036  88DEC0     MOV W0, xrate32
006038  88DED1     MOV W1, 0x1BDA
309:               		yrate32 = 0 ;
00603A  B80060     MUL.UU W0, #0, W0
00603C  88DEE0     MOV W0, yrate32
00603E  88DEF1     MOV W1, 0x1BDE
310:               		zrate32 = 0 ;
006040  B80060     MUL.UU W0, #0, W0
006042  88DF00     MOV W0, zrate32
006044  88DF11     MOV W1, 0x1BE2
311:               #ifdef 	CONING_CORRECTION			
312:               		theta_32[0].WW = _theta_32[0].WW ;
006046  80DD80     MOV _theta_32, W0
006048  80DD91     MOV 0x1BB2, W1
00604A  88DD20     MOV W0, theta_32
00604C  88DD31     MOV W1, 0x1BA6
313:               		theta_32[1].WW = _theta_32[1].WW ;
00604E  80DDA0     MOV 0x1BB4, W0
006050  80DDB1     MOV 0x1BB6, W1
006052  88DD40     MOV W0, 0x1BA8
006054  88DD51     MOV W1, 0x1BAA
314:               		theta_32[2].WW = _theta_32[2].WW ;
006056  80DDC0     MOV .L3, W0
006058  80DDD1     MOV 0x1BBA, W1
00605A  88DD60     MOV W0, 0x1BAC
00605C  88DD71     MOV W1, 0x1BAE
315:               		
316:               		_theta_32[0].WW += 0x00008000 ;
00605E  80DD82     MOV _theta_32, W2
006060  80DD93     MOV 0x1BB2, W3
006062  280000     MOV #0x8000, W0
006064  200001     MOV #0x0, W1
006066  400002     ADD W0, W2, W0
006068  488083     ADDC W1, W3, W1
00606A  88DD80     MOV W0, _theta_32
00606C  88DD91     MOV W1, 0x1BB2
317:               		_theta_32[1].WW += 0x00008000 ;
00606E  80DDA2     MOV 0x1BB4, W2
006070  80DDB3     MOV 0x1BB6, W3
006072  280000     MOV #0x8000, W0
006074  200001     MOV #0x0, W1
006076  400002     ADD W0, W2, W0
006078  488083     ADDC W1, W3, W1
00607A  88DDA0     MOV W0, 0x1BB4
00607C  88DDB1     MOV W1, 0x1BB6
318:               		_theta_32[2].WW += 0x00008000 ;
00607E  80DDC2     MOV .L3, W2
006080  80DDD3     MOV 0x1BBA, W3
006082  280000     MOV #0x8000, W0
006084  200001     MOV #0x0, W1
006086  400002     ADD W0, W2, W0
006088  488083     ADDC W1, W3, W1
00608A  88DDC0     MOV W0, .L3
00608C  88DDD1     MOV W1, 0x1BBA
319:               		
320:               		theta_16[0] = _theta_32[0]._.W1 ;
00608E  80DD90     MOV 0x1BB2, W0
006090  88DC90     MOV W0, theta_16
321:               		theta_16[1] = _theta_32[1]._.W1 ;
006092  80DDB0     MOV 0x1BB6, W0
006094  88DCA0     MOV W0, 0x1B94
322:               		theta_16[2] = _theta_32[2]._.W1 ;
006096  80DDD0     MOV 0x1BBA, W0
006098  88DCB0     MOV W0, 0x1B96
323:               		
324:               		reset_coning_adjustment();
00609A  07FF2A     RCALL reset_coning_adjustment
325:               #endif // CONING_CORRECTION		
326:               		sample_counter = 0 ;
00609C  EB0000     CLR W0
00609E  8BFEF0     MOV W0, .L9, .LSM22
327:               		if (callback) callback();   // was directly calling heartbeat()
0060A0  80DC20     MOV callback, W0
0060A2  500FE0     SUB W0, #0x0, [W15]
0060A4  320002     BRA Z, .L9, .LSM100
0060A6  80DC20     MOV callback, W0
0060A8  010000     CALL W0
328:               	}
329:               }
0060AA  FA8000     ULNK
0060AC  060000     RETURN
330:               
331:               static void MPU6000_read(void)
332:               {
0060AE  FA0000     LNK #0x0
333:               	// burst read guarantees that all registers represent the same sample interval
334:               	mpuCnt++;
0060B0  83FE70     MOV 0x7FCE, W0
0060B2  E80000     INC W0, W0
0060B4  8BFE70     MOV W0, 0x7FCE
335:               	// Non-blocking read of 7 words of data from MPU, starting with X acceleration, and then call process_MPU_data
336:               	readMPUSPI_burst16n(mpu_data, 7, MPUREG_ACCEL_XOUT_H, &process_MPU_data);
0060B6  25F083     MOV #0x5F08, W3
0060B8  2003B2     MOV #0x3B, W2
0060BA  200071     MOV #0x7, W1
0060BC  21B680     MOV #0x1B68, W0
0060BE  027A8E     CALL readMPUSPI_burst16n
0060C0  000000     NOP
337:               }
0060C2  FA8000     ULNK
0060C4  060000     RETURN
338:               
339:               #if (MPU_SPI == 1)
340:               void __attribute__((interrupt, no_auto_psv)) _INT1Interrupt(void)
341:               {
342:               	_INT1IF = 0; // Clear the INT1 interrupt flag
343:               	indicate_loading_inter;
344:               	interrupt_save_set_corcon;
345:               	MPU6000_read();
346:               	interrupt_restore_corcon;
347:               }
348:               #elif (MPU_SPI == 2)
349:               void __attribute__((interrupt, no_auto_psv)) _INT3Interrupt(void)
350:               {
0060C6  F80036     PUSH RCOUNT
0060C8  BE9F80     MOV.D W0, [W15++]
0060CA  BE9F82     MOV.D W2, [W15++]
0060CC  BE9F84     MOV.D W4, [W15++]
0060CE  BE9F86     MOV.D W6, [W15++]
0060D0  FA0000     LNK #0x0
351:               	_INT3IF = 0; // Clear the INT3 interrupt flag
0060D2  A9A08A     BCLR IFS3, #5
352:               	indicate_loading_inter;
353:               	interrupt_save_set_corcon;
0060D4  F80044     PUSH CORCON
0060D6  80F530     MOV 0x1EA6, W0
0060D8  880220     MOV W0, CORCON
354:               	MPU6000_read();
0060DA  07FFE9     RCALL _MPU6000_read, .LFE4, .LFB5, .LSM101
355:               	interrupt_restore_corcon;
0060DC  F90044     POP CORCON
356:               }
0060DE  FA8000     ULNK
0060E0  BE034F     MOV.D [--W15], W6
0060E2  BE024F     MOV.D [--W15], W4
0060E4  BE014F     MOV.D [--W15], W2
0060E6  BE004F     MOV.D [--W15], W0
0060E8  F90036     POP RCOUNT
0060EA  064000     RETFIE
357:               #else
358:               #error("invalid selection for MPU SPI port, must be 1 or 2")
359:               #endif
360:               
361:               // Used for debugging:
362:               void MPU6000_print(void)
363:               {
0060EC  FA0000     LNK #0x0
364:               	printf("%06u axyz %06i %06i %06i gxyz %06i %06i %06i t %u\r\n",
0060EE  80DB77     MOV .L6, W7
0060F0  80DBA6     MOV 0x1B74, W6
0060F2  80DB95     MOV 0x1B72, W5
0060F4  80DB84     MOV 0x1B70, W4
0060F6  80DB63     MOV .L11, W3
0060F8  80DB52     MOV 0x1B6A, W2
0060FA  80DB41     MOV mpu_data, W1
0060FC  83FE70     MOV 0x7FCE, W0
0060FE  781F87     MOV W7, [W15++]
006100  781F86     MOV W6, [W15++]
006102  781F85     MOV W5, [W15++]
006104  781F84     MOV W4, [W15++]
006106  781F83     MOV W3, [W15++]
006108  781F82     MOV W2, [W15++]
00610A  781F81     MOV W1, [W15++]
00610C  781F80     MOV W0, [W15++]
00610E  2B4740     MOV #0xB474, W0
006110  781F80     MOV W0, [W15++]
006112  02052A     CALL __printf_cdnopuxX
006114  000000     NOP
006116  5787F2     SUB W15, #0x12, W15
365:               	    mpuCnt,      mpu_data[0], mpu_data[1], mpu_data[2], 
366:               	    mpu_data[4], mpu_data[5], mpu_data[6], mpu_data[3]);
367:               }
006118  FA8000     ULNK
00611A  060000     RETURN
368:               
369:               #endif // (BOARD_TYPE != UDB4_BOARD)
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/mcu.c  ---------------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "oscillator.h"
24:                #include "interrupt.h"
25:                #include "uart.h"
26:                #include "mcu.h"
27:                #include "options_ports.h"
28:                #include <stdio.h>
29:                
30:                #if (BOARD_TYPE == UDB4_BOARD || BOARD_TYPE == UDB5_BOARD)
31:                #include <p33Fxxxx.h>
32:                #ifdef __XC16__
33:                #pragma config FNOSC = PRIPLL
34:                #pragma config FCKSM = CSDCMD
35:                #pragma config OSCIOFNC = OFF
36:                #pragma config POSCMD = XT
37:                #pragma config FWDTEN = OFF
38:                #pragma config WINDIS = OFF
39:                #pragma config GSS = OFF
40:                #pragma config GWRP = OFF
41:                #pragma config FPWRT = PWR1
42:                #pragma config JTAGEN = OFF
43:                #pragma config ICS = PGD2
44:                
45:                #else // Not __XC16__
46:                _FOSCSEL(FNOSC_PRIPLL); // pri plus PLL (primary osc  w/ PLL)
47:                _FOSC(FCKSM_CSDCMD &
48:                      OSCIOFNC_OFF &
49:                      POSCMD_XT);
50:                // Clock switching on startup is enabled, starts with fast RC.
51:                // Clock switching after startup is disabled.
52:                // Fail-Safe Clock Monitor is disabled.
53:                // OSC2 pin has clock out function.
54:                // Primary Oscillator XT mode.
55:                _FWDT(FWDTEN_OFF &
56:                      WINDIS_OFF);
57:                _FGS(GSS_OFF &
58:                     GCP_OFF &
59:                     GWRP_OFF);
60:                _FPOR(FPWRT_PWR1);
61:                _FICD(JTAGEN_OFF &
62:                      ICS_PGD2);
63:                #endif // __XC16__
64:                
65:                #elif (BOARD_TYPE == AUAV3_BOARD)
66:                
67:                // DSPIC33EP512MU810 Configuration Bit Settings
68:                
69:                #include <p33Exxxx.h>
70:                #ifdef __XC16__
71:                
72:                // FGS
73:                #pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
74:                #pragma config GSS = OFF                // General Segment Code-Protect bit (General Segment Code protect is disabled)
75:                #pragma config GSSK = OFF               // General Segment Key bits (General Segment Write Protection and Code Protection is Disabled)
76:                
77:                // FOSCSEL
78:                #pragma config FNOSC = FRC              // Initial Oscillator Source Selection Bits (Internal Fast RC) )
79:                #pragma config IESO = OFF               // Two-speed Oscillator Start-up Enable bit (Start up with user-selected oscillator source)
80:                
81:                // FOSC
82:                #pragma config POSCMD = XT              // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
83:                #pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
84:                #pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
85:                #pragma config FCKSM = CSECMD           // Clock Switching Mode bits ( Clock enabled and Fail-safe Clock Monitor disabled)
86:                
87:                // FWDT
88:                #pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler Bits (1:32,768)
89:                #pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
90:                #pragma config PLLKEN = ON              // PLL Lock Wait Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
91:                #pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
92:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable bit (Watchdog timer enabled/disabled by user software)
93:                
94:                // FPOR
95:                #pragma config FPWRT = PWR128           // Power-on Reset Timer Value Select bits (128ms)
96:                #pragma config BOREN = ON               // Brown-out Reset (BOR) Detection Enable bit (BOR is enabled)
97:                #pragma config ALTI2C1 = ON             // Alternate I2C pins for I2C1 (ASDA1/ASCK1 pins are selected as the I/O pins for I2C1)
98:                #pragma config ALTI2C2 = ON             // Alternate I2C pins for I2C2 (ASDA2/ASCK2 pins are selected as the I/O pins for I2C2)
99:                
100:               // FICD
101:               #pragma config ICS = PGD3               // ICD Communication Channel Select bits (Communicate on PGEC3 and PGED3)
102:               #pragma config RSTPRI = PF              // Reset Target Vector Select bit (Device will obtain reset instruction from Primary flash)
103:               #pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
104:               
105:               // FAS
106:               #pragma config AWRP = OFF               // Auxiliary Segment Write-protect bit (Auxiliary program memory is not write-protected)
107:               #pragma config APL = OFF                // Auxiliary Segment Code-protect bit (Aux Flash Code protect is disabled)
108:               #pragma config APLK = OFF               // Auxiliary Segment Key bits (Aux Flash Write Protection and Code Protection is Disabled)
109:               
110:               #else // __XC16__
111:               _FOSCSEL(FNOSC_FRC);
112:               //_FOSCSEL(FNOSC_PRIPLL & IESO_OFF);
113:               _FOSC(FCKSM_CSECMD & OSCIOFNC_OFF & POSCMD_XT & IOL1WAY_ON);
114:               //_FWDT(FWDTEN_OFF & WINDIS_OFF & PLLKEN_ON & WDTPRE_PRI128 & PDTPOST_PS32768);
115:               _FWDT(FWDTEN_OFF);
116:               _FICD(ICS_PGD3);
117:               _FPOR(ALTI2C1_ON & ALTI2C2_ON);
118:               /*
119:               //_FOSCSEL(FNOSC_FRC);
120:               _FOSCSEL(FNOSC_PRIPLL & IESO_OFF);
121:               _FOSC(FCKSM_CSECMD & OSCIOFNC_OFF & POSCMD_XT & IOL1WAY_ON);
122:               //_FWDT(FWDTEN_OFF & WINDIS_OFF & PLLKEN_ON & WDTPRE_PRI128 & PDTPOST_PS32768);
123:               _FWDT(FWDTEN_OFF & WINDIS_OFF & PLLKEN_ON);
124:               _FICD(ICS_PGD3);
125:               _FPOR(ALTI2C1_ON & ALTI2C2_ON);
126:                */
127:               #endif // __XC16__
128:               #endif // BOARD_TYPE
129:               
130:               #define INPUT_PIN  1
131:               #define OUTPUT_PIN 0
132:               
133:               int16_t defaultCorcon = 0;
134:               
135:               volatile uint16_t trap_flags __attribute__ ((persistent, near));
136:               volatile uint32_t trap_source __attribute__ ((persistent, near));
137:               volatile uint16_t osc_fail_count __attribute__ ((persistent, near));
138:               
139:               uint16_t get_reset_flags(void)
140:               {
007D2E  FA0002     LNK #0x2
141:               	uint16_t oldRCON = RCON;
007D30  803A00     MOV RCON, W0
007D32  780F00     MOV W0, [W14]
142:               	RCON = 0;
007D34  EB0000     CLR W0
007D36  883A00     MOV W0, RCON
143:               	trap_flags = 0;
007D38  EB0000     CLR W0
007D3A  884020     MOV W0, trap_flags
144:               	trap_source = 0;
007D3C  B80060     MUL.UU W0, #0, W0
007D3E  884000     MOV W0, trap_source
007D40  884011     MOV W1, .L50
145:               	osc_fail_count = 0;
007D42  EB0000     CLR W0
007D44  884030     MOV W0, osc_fail_count
146:               	return oldRCON;
007D46  78001E     MOV [W14], W0
147:               }
007D48  FA8000     ULNK
007D4A  060000     RETURN
148:               
149:               #if (BOARD_TYPE == AUAV3_BOARD)
150:               static void configureANS(void) // disable all analog inputs
151:               {
152:               	ANSELA = 0x0000;
153:               	ANSELB = 0x0000;
154:               	ANSELC = 0x0000;
155:               	ANSELD = 0x0000;
156:               	ANSELE = 0x0000;
157:               	ANSELG = 0x0000;
158:               }
159:               
160:               static void configurePPS(void)  // This method assigns all PPS registers
161:               {
162:               	// Unlock Registers
163:               	__builtin_write_OSCCONL(OSCCON & ~(1 << 6));
164:               
165:               	// CAN module 1 I/O
166:               	_C1RXR = 96;
167:               	_RP97R = 0b001110;
168:               
169:               	// SPI1 SS, SCK, SDI, SDO
170:               	//_RP84R = 0b000111;    // SS1 output RP84
171:               	// in master mode, SS is not used by the SPI module; configure as GP output instead
172:               	// LATE4 is SS1
173:               	_RP127R = 0b000110;     // SCK1 input/output RP127: T1 white
174:               	_SDI1R = 83;            // SDI1 input RPI83         T4 blue
175:               	_RP82R = 0b000101;      // SDO1 output RP82         T2 red
176:               
177:               	// SPI2: SCK2, SDI2, SDO2 are dedicated pins
178:               	//_RP87R = 0b001010;    // SS2 output RP87
179:               	// LATE7 is SS2
180:               
181:               	// SPI3 SS, SCK, SDI, SDO
182:               	//_RP66R = 0b100001;    // SS3 output RP66
183:               	// LATD2 is SS3
184:               	_RP65R = 0b100000;      // SCK3 output RP65
185:               	_SDI3R = 76;            // SDI3 input RPI76
186:               	_RP67R = 0b011111;      // SDO3 output RP67
187:               
188:               	// INTG (MPU6000 interrupt)
189:               	_INT1R = 124; // RPI124/RG12
190:               
191:               	// IC1:8 are Input Capture module inputs
192:               	_IC1R = IC_RPIN1;
193:               	_IC2R = IC_RPIN2;
194:               	_IC3R = IC_RPIN3;
195:               	_IC4R = IC_RPIN4;
196:               	_IC5R = IC_RPIN5;
197:               	_IC6R = IC_RPIN6;
198:               	_IC7R = IC_RPIN7;
199:               	_IC8R = IC_RPIN8;
200:               
201:               // OC1:8 are PWM module outputs
202:               /* OC modules not currently used, but will be needed for multirotor ESC control
203:               	OC_RPIN1 = 0b010000;
204:               	OC_RPIN2 = 0b010001;
205:               	OC_RPIN3 = 0b010010;
206:               	OC_RPIN4 = 0b010011;
207:               	OC_RPIN5 = 0b010100;
208:               	OC_RPIN6 = 0b010101;
209:               	OC_RPIN7 = 0b010110;
210:               	OC_RPIN8 = 0b010111;
211:               */
212:               
213:               	// UART mapping:
214:               	// #  MatrixPilot | AUAV3 silk          | AUAV3 Net | AUAV3 Port
215:               	// -------------------------------------------------------------
216:               	// 1: GPS           GPS                   GPS_RX,TX   PORT4
217:               	// 2: USART         OUART1 (optoisolated) U1RX,TX     PORT1
218:               	// 3: ---           UART3                 U3RX,TX     PORT3
219:               	// 4: ---           OUART2 (optoisolated) U2RX,TX     PORT2
220:               
221:               	#define _UART_TO_PORT(x, y) \
222:               		_U##x##RXR = PORT##y##_RP; \
223:               		PORT##y##_RPI = UART##x##_RP;
224:               	#define UART_TO_PORT(x, y) _UART_TO_PORT(x, y)
225:               
226:               	UART_TO_PORT(1, GPS_PORT)
227:               	UART_TO_PORT(2, TLM_PORT)
228:               	#if (CONSOLE_UART != 0) && (CONSOLE_UART != 9)
229:               		UART_TO_PORT(CONSOLE_UART, DBG_PORT)
230:               	#endif // CONSOLE_UART
231:               
232:               	#ifdef AUAV3
233:               		#if (OSD_UART != 0)
234:               			UART_TO_PORT(OSD_UART, OSD_PORT)
235:               		#endif // OSD_UART
236:               	#endif // AUAV3
237:               
238:               	// Lock Registers
239:               	__builtin_write_OSCCONL(OSCCON | (1 << 6));
240:               }
241:               
242:               // This method configures TRISx for the digital IOs
243:               static void configureDigitalIO(void)   // AUAV3 board
244:               {
245:               	// TRIS registers have no effect on pins mapped to peripherals
246:               	// TRIS assignments are made in the initialization methods for each function
247:               
248:               	// port A
249:               	TRISAbits.TRISA6  = INPUT_PIN;  // DIG2
250:               	TRISAbits.TRISA7  = INPUT_PIN;  // DIG1
251:               	TRISAbits.TRISA15 = INPUT_PIN;  // I4
252:               	TRISAbits.TRISA14 = INPUT_PIN;  // I5
253:               	TRISAbits.TRISA5  = INPUT_PIN;  // I6
254:               	TRISAbits.TRISA4  = INPUT_PIN;  // I7
255:               
256:               	// port B
257:               	TRISBbits.TRISB2  = OUTPUT_PIN; // LED1
258:               	TRISBbits.TRISB3  = OUTPUT_PIN; // LED2
259:               	TRISBbits.TRISB4  = OUTPUT_PIN; // LED3
260:               	TRISBbits.TRISB5  = OUTPUT_PIN; // LED4
261:               
262:               	// port D
263:               	TRISDbits.TRISD0  = INPUT_PIN;  // I1
264:               	TRISDbits.TRISD11 = INPUT_PIN;  // I2
265:               	TRISDbits.TRISD2  = OUTPUT_PIN; // SS3
266:               	TRISDbits.TRISD7  = OUTPUT_PIN; // O4
267:               	TRISDbits.TRISD8  = INPUT_PIN;  // I3
268:               
269:               	// port E
270:               	TRISEbits.TRISE0  = INPUT_PIN;  // O2
271:               	TRISEbits.TRISE1  = INPUT_PIN;  // DIG0
272:               	TRISEbits.TRISE2  = OUTPUT_PIN; // SD01 (MPU6000)
273:               	TRISEbits.TRISE3  = INPUT_PIN;  // SDI1 (MPU6000)
274:               	TRISEbits.TRISE4  = OUTPUT_PIN; // SS1  (MPU6000)
275:               	TRISEbits.TRISE5  = OUTPUT_PIN; // GPS_TX
276:               	TRISEbits.TRISE6  = INPUT_PIN;  // GPS_RX
277:               	TRISEbits.TRISE7  = OUTPUT_PIN; // SS2  (AT45)
278:               
279:               	// port F
280:               	TRISFbits.TRISF0  = INPUT_PIN;  // CAN_RX
281:               	TRISFbits.TRISF1  = OUTPUT_PIN; // CAN_TX
282:                
283:               	// Pins F2, F3, F3, F4 are initialized by the Peripheral Module hardware when it is enabled.
284:               	
285:               	TRISFbits.TRISF8  = INPUT_PIN;  // I8
286:               	TRISFbits.TRISF13 = OUTPUT_PIN; // O7
287:               	TRISFbits.TRISF12 = OUTPUT_PIN; // O8
288:               
289:               	// port G
290:               	TRISGbits.TRISG0  = OUTPUT_PIN; // O1
291:               	TRISGbits.TRISG13 = OUTPUT_PIN; // O3
292:               	TRISGbits.TRISG14 = OUTPUT_PIN; // O5
293:               	TRISGbits.TRISG1  = OUTPUT_PIN; // O6
294:               
295:               // Configure the DIGx pins as outputs for scope tracing
296:               //	TRISAbits.TRISA6  = OUTPUT_PIN; // DIG2
297:               	TRISAbits.TRISA7  = OUTPUT_PIN; // DIG1
298:               	TRISEbits.TRISE1  = OUTPUT_PIN; // DIG0
299:               
300:               	// any pin configured as an input which is not permanantly connected
301:               	// to a device should have an internal pullup or pulldown enabled
302:               
303:               	// CNPU bits enable input pin weak pull up resistors
304:               	CNPUAbits.CNPUA6  = 1;          // DIG2
305:               	CNPUAbits.CNPUA7  = 1;          // DIG1
306:               	CNPUEbits.CNPUE1  = 1;          // DIG0
307:               }
308:               #else
309:               static void configureDigitalIO(void) // UDB4 and UDB5 boards
310:               {
007D4C  FA0000     LNK #0x0
311:               	// TODO: this needs to be updated to support PPM input on user defined input channel
312:               	_TRISD8 = 1;
007D4E  A802D3     BSET 0x2D3, #0
313:               #if (USE_PPM_INPUT == 0)
314:               	_TRISD9 = _TRISD10 = _TRISD11 = _TRISD12 = _TRISD13 = _TRISD14 = _TRISD15 = _TRISD8;
007D50  801690     MOV TRISD, W0
007D52  DE0048     LSR W0, #8, W0
007D54  604061     AND.B W0, #0x1, W0
007D56  FB8000     ZE W0, W0
007D58  DD004F     SL W0, #15, W0
007D5A  801692     MOV TRISD, W2
007D5C  27FFF1     MOV #0x7FFF, W1
007D5E  610081     AND W2, W1, W1
007D60  708000     IOR W1, W0, W0
007D62  881690     MOV W0, TRISD
007D64  801690     MOV TRISD, W0
007D66  DE004F     LSR W0, #15, W0
007D68  784000     MOV.B W0, W0
007D6A  FB8000     ZE W0, W0
007D6C  600061     AND W0, #0x1, W0
007D6E  DD004E     SL W0, #14, W0
007D70  801692     MOV TRISD, W2
007D72  2BFFF1     MOV #0xBFFF, W1
007D74  610081     AND W2, W1, W1
007D76  708000     IOR W1, W0, W0
007D78  881690     MOV W0, TRISD
007D7A  801690     MOV TRISD, W0
007D7C  DE004E     LSR W0, #14, W0
007D7E  604061     AND.B W0, #0x1, W0
007D80  FB8000     ZE W0, W0
007D82  600061     AND W0, #0x1, W0
007D84  DD004D     SL W0, #13, W0
007D86  801692     MOV TRISD, W2
007D88  2DFFF1     MOV #0xDFFF, W1
007D8A  610081     AND W2, W1, W1
007D8C  708000     IOR W1, W0, W0
007D8E  881690     MOV W0, TRISD
007D90  801690     MOV TRISD, W0
007D92  DE004D     LSR W0, #13, W0
007D94  604061     AND.B W0, #0x1, W0
007D96  FB8000     ZE W0, W0
007D98  600061     AND W0, #0x1, W0
007D9A  DD004C     SL W0, #12, W0
007D9C  801692     MOV TRISD, W2
007D9E  2EFFF1     MOV #0xEFFF, W1
007DA0  610081     AND W2, W1, W1
007DA2  708000     IOR W1, W0, W0
007DA4  881690     MOV W0, TRISD
007DA6  801690     MOV TRISD, W0
007DA8  DE004C     LSR W0, #12, W0
007DAA  604061     AND.B W0, #0x1, W0
007DAC  FB8000     ZE W0, W0
007DAE  600061     AND W0, #0x1, W0
007DB0  DD004B     SL W0, #11, W0
007DB2  801692     MOV TRISD, W2
007DB4  2F7FF1     MOV #0xF7FF, W1
007DB6  610081     AND W2, W1, W1
007DB8  708000     IOR W1, W0, W0
007DBA  881690     MOV W0, TRISD
007DBC  801690     MOV TRISD, W0
007DBE  DE004B     LSR W0, #11, W0
007DC0  604061     AND.B W0, #0x1, W0
007DC2  FB8000     ZE W0, W0
007DC4  600061     AND W0, #0x1, W0
007DC6  DD004A     SL W0, #10, W0
007DC8  801692     MOV TRISD, W2
007DCA  2FBFF1     MOV #0xFBFF, W1
007DCC  610081     AND W2, W1, W1
007DCE  708000     IOR W1, W0, W0
007DD0  881690     MOV W0, TRISD
007DD2  801690     MOV TRISD, W0
007DD4  DE004A     LSR W0, #10, W0
007DD6  604061     AND.B W0, #0x1, W0
007DD8  FB8000     ZE W0, W0
007DDA  600061     AND W0, #0x1, W0
007DDC  DD0049     SL W0, #9, W0
007DDE  801692     MOV TRISD, W2
007DE0  2FDFF1     MOV #0xFDFF, W1
007DE2  610081     AND W2, W1, W1
007DE4  708000     IOR W1, W0, W0
007DE6  881690     MOV W0, TRISD
315:               #endif
316:               	TRISF = 0b1111111111101100;
007DE8  2FFEC0     MOV #0xFFEC, W0
007DEA  8816F0     MOV W0, TRISF
317:               }
007DEC  FA8000     ULNK
007DEE  060000     RETURN
318:               #endif // BOARD_TYPE
319:               
320:               static void init_leds(void)
321:               {
007DF0  FA0000     LNK #0x0
322:               #if (BOARD_TYPE == AUAV3_BOARD)
323:               	_LATB2 = LED_OFF; _LATB3 = LED_OFF; _LATB4 = LED_OFF; _LATB5 = LED_OFF; 
324:               	_TRISB2 = 0; _TRISB3 = 0; _TRISB4 = 0; _TRISB5 = 0;
325:               #elif (BOARD_TYPE == UDB4_BOARD || BOARD_TYPE == UDB5_BOARD)
326:               	_LATE1 = LED_OFF; _LATE2 = LED_OFF; _LATE3 = LED_OFF; _LATE4 = LED_OFF;
007DF2  A822DC     BSET LATE, #1
007DF4  A842DC     BSET LATE, #2
007DF6  A862DC     BSET LATE, #3
007DF8  A882DC     BSET LATE, #4
327:               	_TRISE1 = 0; _TRISE2 = 0; _TRISE3 = 0; _TRISE4 = 0;
007DFA  A922D8     BCLR TRISE, #1
007DFC  A942D8     BCLR TRISE, #2
007DFE  A962D8     BCLR TRISE, #3
007E00  A982D8     BCLR TRISE, #4
328:               #else
329:               #error Invalid BOARD_TYPE
330:               #endif // BOARD_TYPE
331:               }
007E02  FA8000     ULNK
007E04  060000     RETURN
332:               
333:               static void init_pll(void)
334:               {
007E06  FA0000     LNK #0x0
335:               #if (BOARD_TYPE == UDB4_BOARD || BOARD_TYPE == UDB5_BOARD)
336:               #if (MIPS == 16)
337:               //No warning given for default MIPS speed
338:               	CLKDIVbits.PLLPRE = 0;  // PLL prescaler: N1 = 2 (default)
339:               	CLKDIVbits.PLLPOST = 1; // PLL postscaler: N2 = 4 (default)
340:               	PLLFBDbits.PLLDIV = 30; // FOSC = 32 MHz (XTAL=8MHz, N1=2, N2=4, M = 32)
341:               #elif (MIPS == 32)
342:               #warning 32 MIPS selected
343:               	CLKDIVbits.PLLPRE = 0;  // PLL prescaler: N1 = 2 (default)
007E08  803A21     MOV CLKDIV, W1
007E0A  2FFE00     MOV #0xFFE0, W0
007E0C  608000     AND W1, W0, W0
007E0E  883A20     MOV W0, CLKDIV
344:               	CLKDIVbits.PLLPOST = 0; // PLL postscaler: N2 = 2
007E10  803A21     MOV CLKDIV, W1
007E12  2FF3F0     MOV #0xFF3F, W0
007E14  608000     AND W1, W0, W0
007E16  883A20     MOV W0, CLKDIV
345:               	PLLFBDbits.PLLDIV = 30; // FOSC = 64 MHz (XTAL=8MHz, N1=2, N2=2, M = 32)
007E18  803A31     MOV PLLFBD, W1
007E1A  2FE000     MOV #0xFE00, W0
007E1C  608000     AND W1, W0, W0
007E1E  B301E0     IOR #0x1E, W0
007E20  883A30     MOV W0, PLLFBD
346:               #elif (MIPS == 40)
347:               #warning 40 MIPS selected
348:               	CLKDIVbits.PLLPRE = 0;  // PLL prescaler: N1 = 2 (default)
349:               	CLKDIVbits.PLLPOST = 0; // PLL postscaler: N2 = 2
350:               	PLLFBDbits.PLLDIV = 38; // FOSC = 80 MHz (XTAL=8MHz, N1=2, N2=2, M = 40)
351:               #else
352:               #error "invalid MIPS Configuration"
353:               #endif // MIPS
354:               #endif // BOARD_TYPE
355:               
356:               #if (BOARD_TYPE == AUAV3_BOARD)
357:               #if (MIPS == 70)
358:               #warning 70 MIPS selected
359:               	// Configure the device PLL to obtain 70 MIPS operation. The crystal
360:               	// frequency is 8MHz. Divide 8MHz by 2, multiply by 70 and divide by
361:               	// 2. This results in Fosc of 140MHz. The CPU clock frequency is
362:               	// Fcy = Fosc/2 = 70MHz.
363:               	PLLFBD = 68;                // M  = 70
364:               #elif (MIPS == 64)
365:               #warning 64 MIPS selected
366:               	PLLFBD = 62;                // M  = 64
367:               #elif (MIPS == 40)
368:               #warning 40 MIPS selected
369:               	PLLFBD = 38;                // M  = 40
370:               #elif (MIPS == 32)
371:               #warning 32 MIPS selected
372:               	PLLFBD = 30;                // M  = 32
373:               #elif (MIPS == 16)
374:               // No warning given for default MIPS speed
375:               	PLLFBD = 14;                // M  = 16
376:               #else
377:               #error Invalid MIPS Configuration
378:               #endif // MIPS
379:               	CLKDIVbits.PLLPOST = 0;     // N1 = 2
380:               	CLKDIVbits.PLLPRE = 0;      // N2 = 2
381:               	OSCTUN = 0;
382:               
383:               	// Initiate Clock Switch to Primary Oscillator with PLL (NOSC= 0x3)
384:               	__builtin_write_OSCCONH(0x03);
385:               	__builtin_write_OSCCONL(0x01);
386:               	while (OSCCONbits.COSC != 0x3);     // Wait for the Primary PLL to lock
387:               #if (USE_USB == 1)
388:               	// Configuring the auxiliary PLL.
389:               	// Since the primary oscillator provides the source clock to the
390:               	// auxiliary PLL, the auxiliary oscillator is disabled.
391:               	// Note that the AUX PLL is enabled. The input 8MHz clock is divided
392:               	// by 2, multiplied by 24 and then divided by 2.
393:               	ACLKCON3 = 0x24C1;
394:               	ACLKDIV3 = 0x7;
395:               	ACLKCON3bits.ENAPLL = 1;
396:               	while (ACLKCON3bits.APLLCK != 1);   // Wait till the AUX PLL locks.
397:               #endif // USE_USB
398:               #endif // BOARD_TYPE
399:               }
007E22  FA8000     ULNK
007E24  060000     RETURN
400:               
401:               void mcu_init(void)
402:               {
007E26  FA0000     LNK #0x0
403:               	defaultCorcon = CORCON;
007E28  800220     MOV CORCON, W0
007E2A  88F530     MOV W0, 0x1EA6
404:               
405:               	if (_SWR == 0)  // if there was not a software reset (trap error) clear the trap data
007E2C  803A01     MOV RCON, W1
007E2E  200400     MOV #0x40, W0
007E30  608000     AND W1, W0, W0
007E32  500FE0     SUB W0, #0x0, [W15]
007E34  3A0007     BRA NZ, .L6, .LSM28
406:               	{
407:               		trap_flags = 0;
007E36  EB0000     CLR W0
007E38  884020     MOV W0, trap_flags
408:               		trap_source = 0;
007E3A  B80060     MUL.UU W0, #0, W0
007E3C  884000     MOV W0, trap_source
007E3E  884011     MOV W1, .L50
409:               		osc_fail_count = 0;
007E40  EB0000     CLR W0
007E42  884030     MOV W0, osc_fail_count
410:               	}
411:               	init_pll();
007E44  07FFE0     RCALL _init_pll, .LFE2, .LFB3, .LSM17
412:               #if (BOARD_TYPE == AUAV3_BOARD)
413:               	configureANS();
414:               	configurePPS();
415:               #endif // BOARD_TYPE
416:               	configureDigitalIO();
007E46  07FF82     RCALL _configureDigitalIO, .LFE0, .LFB1, .LSM8
417:               	init_leds();
007E48  07FFD3     RCALL _init_leds, .LFE1, .LFB2, .LSM13
418:               #if (CONSOLE_UART != 0)
419:               	init_uart();
420:               	DPRINT("\r\n\r\nMatrixPilot " __TIME__ " " __DATE__ " @ %u mips\r\n", MIPS);
421:               	if (_SWR == 1)
422:               	{
423:               		DPRINT("S/W Reset: trap_flags %04x, trap_source %04x%04x, osc_fail_count %u\r\n", 
424:               		    trap_flags, 
425:               		    (unsigned int)(trap_source >> 16), 
426:               		    (unsigned int)(trap_source & 0xffff), 
427:               		    osc_fail_count);
428:               	}
429:               #endif // CONSOLE_UART
430:               }
007E4A  FA8000     ULNK
007E4C  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/libUDB.c  ------------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "oscillator.h"
24:                #include "interrupt.h"
25:                #include "heartbeat.h"
26:                #include "serialIO.h"
27:                #include "servoOut.h"
28:                #include "radioIn.h"
29:                #include "eeprom_udb4.h"
30:                #include "ADchannel.h"
31:                #include "mpu6000.h"
32:                #include "analogs.h"
33:                #include "events.h"
34:                #include "osd.h"
35:                #include "options_ports.h"
36:                
37:                #if (USE_I2C1_DRIVER == 1)
38:                #include "I2C.h"
39:                #endif
40:                
41:                // Include the NV memory services if required
42:                #if (USE_NV_MEMORY == 1)
43:                #include "NV_memory.h"
44:                #include "../MatrixPilot/data_storage.h"
45:                #include "../MatrixPilot/data_services.h"
46:                #endif
47:                
48:                // Include flexifunction mixers if required
49:                #if (USE_FLEXIFUNCTION_MIXING == 1)
50:                #include "../libflexifunctions/flexifunctionservices.h"
51:                #endif
52:                
53:                //#include "../MatrixPilot/telemetry.h"
54:                //#include "../libDCM/gpsParseCommon.h"
55:                
56:                // TODO: do something about these declarations being here - RobD
57:                void udb_init_ADC(void);
58:                void udb_init_clock(void);
59:                
60:                union udb_fbts_byte udb_flags;
61:                
62:                // Functions only included with nv memory.
63:                #if (USE_NV_MEMORY == 1)
64:                UDB_SKIP_FLAGS udb_skip_flags = {0, 0, 0};
65:                
66:                void udb_skip_radio_trim(boolean b)
67:                {
68:                	udb_skip_flags.skip_radio_trim = 1;
69:                }
70:                
71:                void udb_skip_imu_calibration(boolean b)
72:                {
73:                	udb_skip_flags.skip_imu_cal = 1;
74:                }
75:                #endif // (USE_NV_MEMORY == 1)
76:                
77:                void udb_init(void)
78:                {
00803E  FA0000     LNK #0x0
79:                	udb_flags.B = 0;
008040  21EA41     MOV #0x1EA4, W1
008042  EB4000     CLR.B W0
008044  784880     MOV.B W0, [W1]
80:                
81:                	init_analogs();
008046  028088     CALL init_analogs
008048  000000     NOP
82:                
83:                	udb_init_ADC();
00804A  0271D2     CALL udb_init_ADC
00804C  000000     NOP
84:                	init_events();
00804E  0278D6     CALL init_events
008050  000000     NOP
85:                #if (USE_I2C1_DRIVER == 1)
86:                	I2C1_Init();
87:                #endif
88:                #if (USE_NV_MEMORY == 1)
89:                	nv_memory_init();
90:                	data_storage_init();
91:                	data_services_init();
92:                #endif
93:                #if (USE_FLEXIFUNCTION_MIXING == 1)
94:                	flexiFunctionServiceInit();
95:                #endif
96:                	udb_init_clock();
008052  027C54     CALL udb_init_clock
008054  000000     NOP
97:                //	radioIn_init(); // was udb_init_capture();
98:                #if (MAG_YAW_DRIFT == 1 && HILSIM != 1)
99:                //	udb_init_I2C();
100:               #endif
101:               //	servoOut_init(); // was udb_init_pwm()
102:               //	osd_init();
103:               
104:               //FIXME: add AUAV3 support
105:               #if (BOARD_TYPE == UDB4_BOARD || BOARD_TYPE == UDB5_BOARD)
106:               //	udb_eeprom_init();
107:               #endif
108:               
109:               #if (BOARD_TYPE == UDB5_BOARD || BOARD_TYPE == AUAV3_BOARD)
110:               	MPU6000_init16(&heartbeat);
008056  27F600     MOV #0x7F60, W0
008058  025CF6     CALL MPU6000_init16
00805A  000000     NOP
111:               #endif
112:               
113:               	udb_init_irq(); // turn on all interrupt priorities
00805C  027C62     CALL udb_init_irq
00805E  000000     NOP
114:               }
008060  FA8000     ULNK
008062  060000     RETURN
115:               
116:               void udb_run(void)
117:               {
008064  FA0000     LNK #0x0
118:               #if (USE_MCU_IDLE == 1)
119:               	Idle();
008066  FE4001     PWRSAV #1
120:               #else
121:               	// pause cpu counting timer while not in an ISR
122:               	indicate_loading_main;
123:               #endif
124:               }
008068  FA8000     ULNK
00806A  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/heartbeat.c  ---------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "oscillator.h"
24:                #include "interrupt.h"
25:                #include "heartbeat.h"
26:                #include "servoOut.h"
27:                #include "analogs.h"
28:                #include "radioIn.h"
29:                #include "../libDCM/rmat.h"
30:                #if (BOARD_TYPE == UDB4_BOARD)
31:                #include "../libDCM/libDCM.h"
32:                #endif
33:                #if (USE_I2C1_DRIVER == 1)
34:                #include "I2C.h"
35:                #endif
36:                #if (USE_NV_MEMORY == 1)
37:                #include "NV_memory.h"
38:                #include "../MatrixPilot/data_services.h"
39:                #include "../MatrixPilot/data_storage.h"
40:                #endif
41:                
42:                int one_hertz_flag = 0;
43:                uint16_t udb_heartbeat_counter = 0;
44:                uint16_t udb_pulse_counter = 0;
45:                #define HEARTBEAT_MAX 57600 // Evenly divisible by many common values: 2^8 * 3^2 * 5^2
46:                
47:                static void heartbeat_pulse(void);    // forward declaration
48:                
49:                //#define HEARTBEAT_FREQ(x) (udb_heartbeat_counter % (HEARTBEAT_HZ/x) == 0)
50:                //#define HEARTBEAT_CHK(x) (udb_heartbeat_counter % (HEARTBEAT_HZ/x) == 0)
51:                
52:                #if (BOARD_TYPE == UDB4_BOARD)
53:                boolean udb_gyros_autozero_latched_up = false ;
54:                boolean udb_gyros_autozero_latched_down = false ;
55:                void udb_gyros_auto_zero_latch_up(void);
56:                void udb_gyros_auto_zero_latch_down(void);
57:                #endif
58:                
59:                inline boolean heartbeat_chk(uint16_t freq)
60:                {
007F2C  FA0002     LNK #0x2
007F2E  780F00     MOV W0, [W14]
61:                	return (udb_pulse_counter % (HEARTBEAT_HZ/freq) == 0);
007F30  80F411     MOV 0x1E82, W1
007F32  200C82     MOV #0xC8, W2
007F34  78001E     MOV [W14], W0
007F36  780180     MOV W0, W3
007F38  781F81     MOV W1, [W15++]
007F3A  090011     REPEAT #0x11
007F3C  D88103     DIV.UW W2, W3
007F3E  780101     MOV W1, W2
007F40  7800CF     MOV [--W15], W1
007F42  780100     MOV W0, W2
007F44  090011     REPEAT #0x11
007F46  D88082     DIV.UW W1, W2
007F48  FD0080     EXCH W0, W1
007F4A  780080     MOV W0, W1
007F4C  B3C010     MOV.B #0x1, W0
007F4E  508FE0     SUB W1, #0x0, [W15]
007F50  320001     BRA Z, .L2, .LSM2
007F52  EB4000     CLR.B W0
62:                //	return HEARTBEAT_CHK(freq);
63:                }
007F54  FA8000     ULNK
007F56  060000     RETURN
64:                
65:                inline uint16_t heartbeat_cnt(void)
66:                {
007F58  FA0000     LNK #0x0
67:                	return udb_pulse_counter;
007F5A  80F410     MOV 0x1E82, W0
68:                }
007F5C  FA8000     ULNK
007F5E  060000     RETURN
69:                
70:                // NOTE: RobD - udb_heartbeat_counter is not being used at the libUDB layer
71:                //              outside of this module, so it could be moved up.
72:                inline void heartbeat(void) // called from ISR
73:                {
007F60  FA0000     LNK #0x0
74:                	// Capture cpu_timer once per second.
75:                	if (udb_heartbeat_counter % (HEARTBEAT_HZ/1) == 0)
007F62  80F401     MOV .L47, W1
007F64  200C80     MOV #0xC8, W0
007F66  780100     MOV W0, W2
007F68  090011     REPEAT #0x11
007F6A  D88082     DIV.UW W1, W2
007F6C  FD0080     EXCH W0, W1
007F6E  500FE0     SUB W0, #0x0, [W15]
007F70  3A0004     BRA NZ, .L5, .LSM10
76:                	{
77:                		cpu_load_calc();
007F72  027C18     CALL cpu_load_calc
007F74  000000     NOP
78:                		one_hertz_flag = 1;
007F76  200010     MOV #0x1, W0
007F78  88F3F0     MOV W0, 0x1E7E
79:                	}
80:                
81:                	// TODO: determine why this is called from the high priority interrupt handler? is it req?
82:                	// This calls the state machine implemented in MatrixPilot/states.c
83:                	// it is called at high priority to ensure manual control takeover can
84:                	// occur, even if the lower priority tasks hang
85:                	// Call the periodic callback at 40 Hz
86:                	if (udb_heartbeat_counter % (HEARTBEAT_HZ/40) == 0)
007F7A  80F401     MOV .L47, W1
007F7C  200050     MOV #0x5, W0
007F7E  780100     MOV W0, W2
007F80  090011     REPEAT #0x11
007F82  D88082     DIV.UW W1, W2
007F84  FD0080     EXCH W0, W1
007F86  500FE0     SUB W0, #0x0, [W15]
007F88  3A0002     BRA NZ, .L6, .LSM12
87:                	{
88:                		// by default runs the MatrixPilot state machine in states.c
89:                		udb_heartbeat_40hz_callback(); // this was called udb_background_callback_periodic()
007F8A  026B26     CALL udb_heartbeat_40hz_callback
007F8C  000000     NOP
90:                	}
91:                
92:                	// Trigger the HEARTBEAT_HZ calculations, but at a lower priority
93:                //	_T6IF = 1;
94:                	udb_background_trigger_pulse(&heartbeat_pulse);
007F8E  27FB00     MOV #0x7FB0, W0
007F90  027CE4     CALL udb_background_trigger_pulse
007F92  000000     NOP
95:                	// TODO: RobD - potential inversion issue here with incrementing the counter
96:                	//              before versus after the pulse occurs, depending on the
97:                	//              trigger implementation..
98:                	udb_heartbeat_counter = (udb_heartbeat_counter+1) % HEARTBEAT_MAX;
007F94  80F400     MOV .L47, W0
007F96  E80100     INC W0, W2
007F98  200010     MOV #0x1, W0
007F9A  2E1001     MOV #0xE100, W1
007F9C  510F81     SUB W2, W1, [W15]
007F9E  310001     BRA C, .L7
007FA0  EB0000     CLR W0
007FA2  2E1001     MOV #0xE100, W1
007FA4  B98001     MUL.SS W0, W1, W0
007FA6  780000     MOV W0, W0
007FA8  510000     SUB W2, W0, W0
007FAA  88F400     MOV W0, .L47
99:                }
007FAC  FA8000     ULNK
007FAE  060000     RETURN
100:               
101:               // Executes whatever lower priority calculation needs to be done every heartbeat (default: 25 milliseconds)
102:               // This is a good place to eventually compute pulse widths for servos.
103:               static void heartbeat_pulse(void)
104:               {
007FB0  FA0000     LNK #0x0
105:               
106:               	udb_flags._.radio_on = 1;
007FB2  80F521     MOV udb_flags, W1
007FB4  220000     MOV #0x2000, W0
007FB6  708000     IOR W1, W0, W0
007FB8  88F520     MOV W0, udb_flags
107:               
108:               	vref_adj = 0;
007FBA  EB0000     CLR W0
007FBC  88DC10     MOV W0, vref_adj
109:               
110:               	udb_callback_read_sensors();
007FBE  023770     CALL udb_callback_read_sensors
007FC0  000000     NOP
111:               	if ((udb_pulse_counter % (HEARTBEAT_HZ/40)) == 0)
007FC2  80F411     MOV 0x1E82, W1
007FC4  200050     MOV #0x5, W0
007FC6  780100     MOV W0, W2
007FC8  090011     REPEAT #0x11
007FCA  D88082     DIV.UW W1, W2
007FCC  FD0080     EXCH W0, W1
007FCE  500FE0     SUB W0, #0x0, [W15]
007FD0  3A0006     BRA NZ, .L9, .LSM22
112:                	{
113:                		calculate_analog_sensor_values();
007FD2  02808E     CALL calculate_analog_sensor_values
007FD4  000000     NOP
114:                		udb_flags._.a2d_read = 1; // signal the A/D to start the next summation
007FD6  80F521     MOV udb_flags, W1
007FD8  210000     MOV #0x1000, W0
007FDA  708000     IOR W1, W0, W0
007FDC  88F520     MOV W0, udb_flags
115:                	}
116:               
117:               	// process sensor data, run flight controller, generate outputs. implemented in libDCM.c
118:               	udb_heartbeat_callback(); // this was called udb_servo_callback_prepare_outputs()
007FDE  0274BC     CALL udb_heartbeat_callback
007FE0  000000     NOP
119:               
120:               	if (udb_pulse_counter % (HEARTBEAT_HZ/40) == 0)
121:               	{
122:               #if (USE_I2C1_DRIVER == 1)
123:               		I2C1_trigger_service();
124:               #endif
125:               
126:               #if (USE_NV_MEMORY == 1)
127:               		nv_memory_service_trigger();
128:               		storage_service_trigger();
129:               		data_services_trigger();
130:               #endif
131:               
132:               #if (USE_FLEXIFUNCTION_MIXING == 1)
133:               		flexiFunctionServiceTrigger();
134:               #endif
135:               	}
136:               	udb_pulse_counter = (udb_pulse_counter+1) % HEARTBEAT_MAX;
007FE2  80F410     MOV 0x1E82, W0
007FE4  E80100     INC W0, W2
007FE6  200010     MOV #0x1, W0
007FE8  2E1001     MOV #0xE100, W1
007FEA  510F81     SUB W2, W1, [W15]
007FEC  310001     BRA C, .L10
007FEE  EB0000     CLR W0
007FF0  2E1001     MOV #0xE100, W1
007FF2  B98001     MUL.SS W0, W1, W0
007FF4  780000     MOV W0, W0
007FF6  510000     SUB W2, W0, W0
007FF8  88F410     MOV W0, 0x1E82
137:               }
007FFA  FA8000     ULNK
007FFC  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/gyro_offsets_table.c  ------------------------------
1:                 /* 
2:                  * File:   gyro_offsets_table.h
3:                  * Author: bill
4:                  *
5:                  * Created on December 20, 2022, 9:35 AM
6:                  */
7:                 
8:                 #include <stdint.h>
9:                 #include "../libDCM/libDCM.h"
10:                #include "../libDCM/libDCM_defines.h"
11:                #include "../libDCM/mathlibNAV.h"
12:                #include "../libDCM/gpsData.h"
13:                #include "../libDCM/gpsParseCommon.h"
14:                #include "../libDCM/rmat.h"
15:                #include "../libUDB/heartbeat.h"
16:                #include "../libUDB/serialIO.h"
17:                #include "../libUDB/servoOut.h"
18:                #include "../libUDB/ADchannel.h"
19:                #include <math.h>
20:                
21:                
22:                typedef struct gyro_offset_table_entry { int16_t x ; int16_t y ; int16_t z ; } gyro_offset_table_entry ;
23:                
24:                #include GYRO_OFFSET_TABLE
25:                
26:                #if (STEP_SIZE == 1024)
27:                #define LOOKUP_LSB_MASK 0x03FF
28:                #define MSB_SHIFT 10
29:                #eliif ( STEP_SIZE == 256 )
30:                #define LOOKUP_LSB_MASK 0x00FF
31:                #define MSB_SHIFT 8
32:                #elif ( STEP_SIZE == 64 )
33:                #define LOOKUP_LSB_MASK 0x003F
34:                #define MSB_SHIFT 6
35:                #else
36:                #error "unsupported or undefine STEP_SIZE"
37:                #endif // STEP_SIZE
38:                
39:                extern struct ADchannel mpu_temp;
40:                
41:                int16_t temperature_index ;
42:                
43:                int16_t gyro_offset[3] ;
44:                
45:                uint16_t index_msb = 0 ;
46:                uint16_t index_lsb = 0 ;
47:                int16_t left_entry[3];
48:                int16_t right_minus_left[3];
49:                uint16_t number_entries ;
50:                
51:                void lookup_gyro_offsets(void)
52:                {
003FEE  FA0000     LNK #0x0
53:                	temperature_index = mpu_temp.value - TABLE_ORIGIN ;
003FF0  80DBD1     MOV 0x1B7A, W1
003FF2  24D150     MOV #0x4D15, W0
003FF4  408000     ADD W1, W0, W0
003FF6  88EA10     MOV W0, temperature_index
54:                	if (temperature_index < 0)
003FF8  80EA10     MOV temperature_index, W0
003FFA  500FE0     SUB W0, #0x0, [W15]
003FFC  3D0011     BRA GE, .L2, .LSM8
55:                	{
56:                		index_msb = 0 ;
003FFE  EB0000     CLR W0
004000  8877A0     MOV W0, 0xEF4
57:                		index_lsb = 0 ;
004002  EB0000     CLR W0
004004  8877B0     MOV W0, 0xEF6
58:                		gyro_offset[0] = residual_offset[0]+ gyro_offset_table[0].x ;
004006  804051     MOV 0x80A, W1
004008  804080     MOV 0x810, W0
00400A  408000     ADD W1, W0, W0
00400C  88EA20     MOV W0, gyro_offset
59:                		gyro_offset[1] = residual_offset[1]+ gyro_offset_table[0].y ;
00400E  804061     MOV 0x80C, W1
004010  804090     MOV 0x812, W0
004012  408000     ADD W1, W0, W0
004014  88EA30     MOV W0, .L29
60:                		gyro_offset[2] = residual_offset[2]+ gyro_offset_table[0].z ;
004016  804071     MOV 0x80E, W1
004018  8040A0     MOV 0x814, W0
00401A  408000     ADD W1, W0, W0
00401C  88EA40     MOV W0, 0x1D48
00401E  370091     BRA .L1, .LSM34
61:                	}
62:                	else
63:                	{
64:                		index_lsb = temperature_index & LOOKUP_LSB_MASK ;
004020  80EA10     MOV temperature_index, W0
004022  780080     MOV W0, W1
004024  2003F0     MOV #0x3F, W0
004026  608000     AND W1, W0, W0
004028  8877B0     MOV W0, 0xEF6
65:                		index_msb = temperature_index >> MSB_SHIFT ; 
00402A  80EA10     MOV temperature_index, W0
00402C  DE8046     ASR W0, #6, W0
00402E  8877A0     MOV W0, 0xEF4
66:                		number_entries = (sizeof (gyro_offset_table))/(sizeof (gyro_offset_table_entry)) ;
004030  201260     MOV #0x126, W0
004032  88EAB0     MOV W0, number_entries
67:                		if ( index_msb >= (number_entries - 1 ))
004034  80EAB0     MOV number_entries, W0
004036  E90080     DEC W0, W1
004038  8077A0     MOV 0xEF4, W0
00403A  508F80     SUB W1, W0, [W15]
00403C  3E0021     BRA GTU, .L4, .LSM15
68:                		{
69:                			gyro_offset[0] = residual_offset[0]+ gyro_offset_table[number_entries - 1].x ;
00403E  804052     MOV 0x80A, W2
004040  80EAB0     MOV number_entries, W0
004042  E90000     DEC W0, W0
004044  B90066     MUL.SU W0, #6, W0
004046  780080     MOV W0, W1
004048  208100     MOV #0x810, W0
00404A  408000     ADD W1, W0, W0
00404C  780010     MOV [W0], W0
00404E  410000     ADD W2, W0, W0
004050  88EA20     MOV W0, gyro_offset
70:                			gyro_offset[1] = residual_offset[1]+ gyro_offset_table[number_entries - 1].y ;
004052  804062     MOV 0x80C, W2
004054  80EAB0     MOV number_entries, W0
004056  E90000     DEC W0, W0
004058  B90066     MUL.SU W0, #6, W0
00405A  780000     MOV W0, W0
00405C  E88080     INC2 W0, W1
00405E  208100     MOV #0x810, W0
004060  408000     ADD W1, W0, W0
004062  780010     MOV [W0], W0
004064  410000     ADD W2, W0, W0
004066  88EA30     MOV W0, .L29
71:                			gyro_offset[2] = residual_offset[2]+ gyro_offset_table[number_entries - 1].z ;
004068  804072     MOV 0x80E, W2
00406A  80EAB0     MOV number_entries, W0
00406C  E90000     DEC W0, W0
00406E  B90066     MUL.SU W0, #6, W0
004070  780000     MOV W0, W0
004072  4000E4     ADD W0, #0x4, W1
004074  208100     MOV #0x810, W0
004076  408000     ADD W1, W0, W0
004078  780010     MOV [W0], W0
00407A  410000     ADD W2, W0, W0
00407C  88EA40     MOV W0, 0x1D48
00407E  370061     BRA .L1, .LSM34
72:                		}
73:                		else
74:                		{
75:                			left_entry[0]= gyro_offset_table[index_msb].x ;
004080  8077A0     MOV 0xEF4, W0
004082  B90066     MUL.SU W0, #6, W0
004084  780080     MOV W0, W1
004086  208100     MOV #0x810, W0
004088  408000     ADD W1, W0, W0
00408A  780010     MOV [W0], W0
00408C  88EA50     MOV W0, left_entry
76:                			left_entry[1]= gyro_offset_table[index_msb].y ;
00408E  8077A0     MOV 0xEF4, W0
004090  B90066     MUL.SU W0, #6, W0
004092  780000     MOV W0, W0
004094  E88080     INC2 W0, W1
004096  208100     MOV #0x810, W0
004098  408000     ADD W1, W0, W0
00409A  780010     MOV [W0], W0
00409C  88EA60     MOV W0, 0x1D4C
77:                			left_entry[2]= gyro_offset_table[index_msb].z ;
00409E  8077A0     MOV 0xEF4, W0
0040A0  B90066     MUL.SU W0, #6, W0
0040A2  780000     MOV W0, W0
0040A4  4000E4     ADD W0, #0x4, W1
0040A6  208100     MOV #0x810, W0
0040A8  408000     ADD W1, W0, W0
0040AA  780010     MOV [W0], W0
0040AC  88EA70     MOV W0, 0x1D4E
78:                			
79:                			right_minus_left[0]= gyro_offset_table[index_msb+1].x - left_entry[0] ;
0040AE  8077A0     MOV 0xEF4, W0
0040B0  E80000     INC W0, W0
0040B2  B90066     MUL.SU W0, #6, W0
0040B4  780080     MOV W0, W1
0040B6  208100     MOV #0x810, W0
0040B8  408000     ADD W1, W0, W0
0040BA  780090     MOV [W0], W1
0040BC  80EA50     MOV left_entry, W0
0040BE  508000     SUB W1, W0, W0
0040C0  88EA80     MOV W0, right_minus_left
80:                			right_minus_left[1]= gyro_offset_table[index_msb+1].y - left_entry[1] ;
0040C2  8077A0     MOV 0xEF4, W0
0040C4  E80000     INC W0, W0
0040C6  B90066     MUL.SU W0, #6, W0
0040C8  780000     MOV W0, W0
0040CA  E88080     INC2 W0, W1
0040CC  208100     MOV #0x810, W0
0040CE  408000     ADD W1, W0, W0
0040D0  780090     MOV [W0], W1
0040D2  80EA60     MOV 0x1D4C, W0
0040D4  508000     SUB W1, W0, W0
0040D6  88EA90     MOV W0, 0x1D52
81:                			right_minus_left[2]= gyro_offset_table[index_msb+1].z - left_entry[2] ;
0040D8  8077A0     MOV 0xEF4, W0
0040DA  E80000     INC W0, W0
0040DC  B90066     MUL.SU W0, #6, W0
0040DE  780000     MOV W0, W0
0040E0  4000E4     ADD W0, #0x4, W1
0040E2  208100     MOV #0x810, W0
0040E4  408000     ADD W1, W0, W0
0040E6  780090     MOV [W0], W1
0040E8  80EA70     MOV 0x1D4E, W0
0040EA  508000     SUB W1, W0, W0
0040EC  88EAA0     MOV W0, 0x1D54
82:                			
83:                			gyro_offset[0] = residual_offset[0] 
0040EE  804051     MOV 0x80A, W1
004108  88EA20     MOV W0, gyro_offset
84:                					+ left_entry[0] 
0040F0  80EA50     MOV left_entry, W0
0040F2  408100     ADD W1, W0, W2
85:                					+ __builtin_divsd(__builtin_mulss(right_minus_left[0],index_lsb),1024);
0040F4  8077B0     MOV 0xEF6, W0
0040F6  780080     MOV W0, W1
0040F8  80EA80     MOV right_minus_left, W0
0040FA  B98001     MUL.SS W0, W1, W0
0040FC  204003     MOV #0x400, W3
0040FE  781F81     MOV W1, [W15++]
004100  090011     REPEAT #0x11
004102  D80843     DIV.SD W0, W3
004104  7800CF     MOV [--W15], W1
004106  410000     ADD W2, W0, W0
86:                			gyro_offset[1] = residual_offset[1] 
00410A  804061     MOV 0x80C, W1
004124  88EA30     MOV W0, .L29
87:                					+ left_entry[1] 
00410C  80EA60     MOV 0x1D4C, W0
00410E  408100     ADD W1, W0, W2
88:                					+ __builtin_divsd(__builtin_mulss(right_minus_left[1],index_lsb),1024);
004110  8077B0     MOV 0xEF6, W0
004112  780080     MOV W0, W1
004114  80EA90     MOV 0x1D52, W0
004116  B98001     MUL.SS W0, W1, W0
004118  204003     MOV #0x400, W3
00411A  781F81     MOV W1, [W15++]
00411C  090011     REPEAT #0x11
00411E  D80843     DIV.SD W0, W3
004120  7800CF     MOV [--W15], W1
004122  410000     ADD W2, W0, W0
89:                			gyro_offset[2] = residual_offset[2] 
004126  804071     MOV 0x80E, W1
004140  88EA40     MOV W0, 0x1D48
90:                					+ left_entry[2] + 
004128  80EA70     MOV 0x1D4E, W0
00412A  408100     ADD W1, W0, W2
00413E  410000     ADD W2, W0, W0
91:                					__builtin_divsd(__builtin_mulss(right_minus_left[2],index_lsb),1024);
00412C  8077B0     MOV 0xEF6, W0
00412E  780080     MOV W0, W1
004130  80EAA0     MOV 0x1D54, W0
004132  B98001     MUL.SS W0, W1, W0
004134  204003     MOV #0x400, W3
004136  781F81     MOV W1, [W15++]
004138  090011     REPEAT #0x11
00413A  D80843     DIV.SD W0, W3
00413C  7800CF     MOV [--W15], W1
92:                		}
93:                	}
94:                }
004142  FA8000     ULNK
004144  060000     RETURN
95:                
96:                int64_t samples_64t = 0 ;
97:                int32_t samples_32t = 0 ;
98:                int16_t gyro_offset_entry[] = { 0 , 0 , 0 } ;
99:                int64_t xx_sum = 0 ;
100:               int64_t xy_sum[] = { 0 , 0 , 0  } ;
101:               int32_t x_sum = 0 ;
102:               int32_t y_sum[] = { 0 , 0 , 0  } ;
103:               int32_t xx_bar = 0 ;
104:               int32_t xy_bar[] = { 0 , 0 , 0  } ;
105:               int16_t x_bar = 0 ;
106:               int16_t y_bar[] = { 0 , 0 , 0  } ;
107:               int64_t xx_bar_minus_x_bar_x_bar ;
108:               int16_t offset_left[3] ;
109:               int16_t offset_right[3] ;
110:               int16_t offset_previous[3];
111:               
112:               int16_t adjusted_temperature = 0 ;
113:               int16_t temperature_offset = 0 ;
114:               int16_t initial_temperature = 0 ;
115:               int16_t reported_temperature = -8000 ;
116:               
117:               int16_t initial_temp_recorded = 0 ;
118:               int16_t initial_temp_reported = 0 ;
119:               
120:               extern uint8_t udb_cpu_load(void);
121:               extern void serial_output(const char* format, ...);
122:               
123:               void update_offset_table(void)
124:               {
004146  FA0098     LNK #0x98
004148  BE9F88     MOV.D W8, [W15++]
00414A  BE9F8A     MOV.D W10, [W15++]
125:               	reported_temperature = mpu_temp.value ;
00414C  80DBD0     MOV 0x1B7A, W0
00414E  887AC0     MOV W0, 0xF58
126:               	if ( initial_temp_recorded == 0 )
004150  807AD0     MOV 0xF5A, W0
004152  500FE0     SUB W0, #0x0, [W15]
004154  3A0008     BRA NZ, .L6, .LSM43
127:               	{
128:               		initial_temperature = reported_temperature ;
004156  807AC0     MOV 0xF58, W0
004158  887AB0     MOV W0, 0xF56
129:               		temperature_offset = initial_temperature ;
00415A  807AB0     MOV 0xF56, W0
00415C  887AA0     MOV W0, 0xF54
130:               		initial_temp_recorded = 1 ;
00415E  200010     MOV #0x1, W0
004160  887AD0     MOV W0, 0xF5A
131:               		LED_RED = LED_ON ;
004162  A922DC     BCLR LATE, #1
132:               		LED_GREEN = LED_OFF ;
004164  A842DC     BSET LATE, #2
133:               	}
134:               	adjusted_temperature = reported_temperature - temperature_offset ;
004166  807AC1     MOV 0xF58, W1
004168  807AA0     MOV 0xF54, W0
00416A  508000     SUB W1, W0, W0
00416C  887A90     MOV W0, 0xF52
135:               	{
136:               		gyro_offset_entry[0]= 64*udb_xrate.value ;
00416E  80E560     MOV 0x1CAC, W0
004170  DD0046     SL W0, #6, W0
004172  887820     MOV W0, 0xF04
137:               		gyro_offset_entry[1]= 64*udb_yrate.value ;
004174  80E5B0     MOV 0x1CB6, W0
004176  DD0046     SL W0, #6, W0
004178  887830     MOV W0, 0xF06
138:               		gyro_offset_entry[2]= 64*udb_zrate.value ;
00417A  80E600     MOV 0x1CC0, W0
00417C  DD0046     SL W0, #6, W0
00417E  887840     MOV W0, 0xF08
139:               		
140:               		xx_sum += (uint64_t) __builtin_mulss( adjusted_temperature,adjusted_temperature) ;
004180  807A91     MOV 0xF52, W1
004182  807A90     MOV 0xF52, W0
004184  B98001     MUL.SS W0, W1, W0
004186  BE0200     MOV.D W0, W4
004188  DE884F     ASR W1, #15, W0
00418A  780300     MOV W0, W6
00418C  780380     MOV W0, W7
00418E  20F0A0     MOV #0xF0A, W0
004190  BE0150     MOV.D [++W0], W2
004192  BE0040     MOV.D [--W0], W0
004194  400004     ADD W0, W4, W0
004196  488085     ADDC W1, W5, W1
004198  490106     ADDC W2, W6, W2
00419A  498187     ADDC W3, W7, W3
00419C  20F0A4     MOV #0xF0A, W4
00419E  BE9A00     MOV.D W0, [W4++]
0041A0  BE9202     MOV.D W2, [W4--]
141:               		
142:               		xy_sum[0] += (int64_t)	__builtin_mulss( adjusted_temperature,gyro_offset_entry[0]) ;
0041A2  20F120     MOV #0xF12, W0
0041A4  BE0230     MOV.D [W0++], W4
0041A6  BE0320     MOV.D [W0--], W6
0041A8  807821     MOV 0xF04, W1
0041AA  807A90     MOV 0xF52, W0
0041AC  B98001     MUL.SS W0, W1, W0
0041AE  BE0400     MOV.D W0, W8
0041B0  DE884F     ASR W1, #15, W0
0041B2  780500     MOV W0, W10
0041B4  780580     MOV W0, W11
0041B6  440004     ADD W8, W4, W0
0041B8  4C8085     ADDC W9, W5, W1
0041BA  4D0106     ADDC W10, W6, W2
0041BC  4D8187     ADDC W11, W7, W3
0041BE  20F124     MOV #0xF12, W4
0041C0  BE9A00     MOV.D W0, [W4++]
0041C2  BE9202     MOV.D W2, [W4--]
143:               		xy_sum[1] += (int64_t)	__builtin_mulss( adjusted_temperature,gyro_offset_entry[1]) ;
0041C4  20F1A0     MOV #0xF1A, W0
0041C6  BE0230     MOV.D [W0++], W4
0041C8  BE0320     MOV.D [W0--], W6
0041CA  807831     MOV 0xF06, W1
0041CC  807A90     MOV 0xF52, W0
0041CE  B98001     MUL.SS W0, W1, W0
0041D0  BE0100     MOV.D W0, W2
0041D2  BE8F02     MOV.D W2, [W14]
0041D4  DE884F     ASR W1, #15, W0
0041D6  780180     MOV W0, W3
0041D8  980723     MOV W3, [W14+4]
0041DA  980730     MOV W0, [W14+6]
0041DC  BE043E     MOV.D [W14++], W8
0041DE  BE052E     MOV.D [W14--], W10
0041E0  440004     ADD W8, W4, W0
0041E2  4C8085     ADDC W9, W5, W1
0041E4  4D0106     ADDC W10, W6, W2
0041E6  4D8187     ADDC W11, W7, W3
0041E8  20F1A4     MOV #0xF1A, W4
0041EA  BE9A00     MOV.D W0, [W4++]
0041EC  BE9202     MOV.D W2, [W4--]
144:               		xy_sum[2] += (int64_t)	__builtin_mulss( adjusted_temperature,gyro_offset_entry[2]) ;
0041EE  20F220     MOV #0xF22, W0
0041F0  BE0230     MOV.D [W0++], W4
0041F2  BE0320     MOV.D [W0--], W6
0041F4  807841     MOV 0xF08, W1
0041F6  807A90     MOV 0xF52, W0
0041F8  B98001     MUL.SS W0, W1, W0
0041FA  BE0500     MOV.D W0, W10
0041FC  98074A     MOV W10, [W14+8]
0041FE  98075B     MOV W11, [W14+10]
004200  DE884F     ASR W1, #15, W0
004202  780580     MOV W0, W11
004204  98076B     MOV W11, [W14+12]
004206  980770     MOV W0, [W14+14]
004208  90044E     MOV [W14+8], W8
00420A  9004DE     MOV [W14+10], W9
00420C  90056E     MOV [W14+12], W10
00420E  9005FE     MOV [W14+14], W11
004210  440004     ADD W8, W4, W0
004212  4C8085     ADDC W9, W5, W1
004214  4D0106     ADDC W10, W6, W2
004216  4D8187     ADDC W11, W7, W3
004218  20F224     MOV #0xF22, W4
00421A  BE9A00     MOV.D W0, [W4++]
00421C  BE9202     MOV.D W2, [W4--]
145:               		
146:               		x_sum += (int32_t ) adjusted_temperature ;
00421E  807A90     MOV 0xF52, W0
004220  B90161     MUL.SU W0, #1, W2
004222  807950     MOV 0xF2A, W0
004224  807961     MOV 0xF2C, W1
004226  400002     ADD W0, W2, W0
004228  488083     ADDC W1, W3, W1
00422A  887950     MOV W0, 0xF2A
00422C  887961     MOV W1, 0xF2C
147:               		
148:               		y_sum[0] += (int32_t ) gyro_offset_entry[0] ;
00422E  807972     MOV 0xF2E, W2
004230  807983     MOV 0xF30, W3
004232  807820     MOV 0xF04, W0
004234  DE80CF     ASR W0, #15, W1
004236  400002     ADD W0, W2, W0
004238  488083     ADDC W1, W3, W1
00423A  887970     MOV W0, 0xF2E
00423C  887981     MOV W1, 0xF30
149:               		y_sum[1] += (int32_t ) gyro_offset_entry[1] ;
00423E  807992     MOV 0xF32, W2
004240  8079A3     MOV 0xF34, W3
004242  807830     MOV 0xF06, W0
004244  DE80CF     ASR W0, #15, W1
004246  400002     ADD W0, W2, W0
004248  488083     ADDC W1, W3, W1
00424A  887990     MOV W0, 0xF32
00424C  8879A1     MOV W1, 0xF34
150:               		y_sum[2] += (int32_t ) gyro_offset_entry[2] ;
00424E  8079B2     MOV 0xF36, W2
004250  8079C3     MOV 0xF38, W3
004252  807840     MOV 0xF08, W0
004254  DE80CF     ASR W0, #15, W1
004256  400002     ADD W0, W2, W0
004258  488083     ADDC W1, W3, W1
00425A  8879B0     MOV W0, 0xF36
00425C  8879C1     MOV W1, 0xF38
151:               		
152:               		samples_32t ++ ;
00425E  807800     MOV 0xF00, W0
004260  807811     MOV 0xF02, W1
004262  400061     ADD W0, #0x1, W0
004264  4880E0     ADDC W1, #0x0, W1
004266  887800     MOV W0, 0xF00
004268  887811     MOV W1, 0xF02
153:               		
154:               		if ( adjusted_temperature >= STEP_SIZE )
00426A  807A91     MOV 0xF52, W1
00426C  2003F0     MOV #0x3F, W0
00426E  508F80     SUB W1, W0, [W15]
004270  34031D     BRA LE, .L5, .LSM138
155:               		{
156:               			udb_led_toggle(LED_GREEN);
004272  8016E0     MOV LATE, W0
004274  6000E4     AND W0, #0x4, W1
004276  B3C010     MOV.B #0x1, W0
004278  508FE0     SUB W1, #0x0, [W15]
00427A  320001     BRA Z, .L8
00427C  EB4000     CLR.B W0
00427E  FB8000     ZE W0, W0
004280  600061     AND W0, #0x1, W0
004282  DD0142     SL W0, #2, W2
004284  8016E1     MOV LATE, W1
004286  2FFFB0     MOV #0xFFFB, W0
004288  608000     AND W1, W0, W0
00428A  700002     IOR W0, W2, W0
00428C  8816E0     MOV W0, LATE
157:               			udb_led_toggle(LED_RED);
00428E  8016E0     MOV LATE, W0
004290  6000E2     AND W0, #0x2, W1
004292  B3C010     MOV.B #0x1, W0
004294  508FE0     SUB W1, #0x0, [W15]
004296  320001     BRA Z, .L9
004298  EB4000     CLR.B W0
00429A  FB8000     ZE W0, W0
00429C  600061     AND W0, #0x1, W0
00429E  400100     ADD W0, W0, W2
0042A0  8016E1     MOV LATE, W1
0042A2  2FFFD0     MOV #0xFFFD, W0
0042A4  608000     AND W1, W0, W0
0042A6  700002     IOR W0, W2, W0
0042A8  8816E0     MOV W0, LATE
158:               			temperature_offset += STEP_SIZE ;
0042AA  807AA0     MOV 0xF54, W0
0042AC  B00400     ADD #0x40, W0
0042AE  887AA0     MOV W0, 0xF54
159:               			samples_64t = (int64_t)samples_32t ;
0042B0  807800     MOV 0xF00, W0
0042B2  807811     MOV 0xF02, W1
0042B4  BE0500     MOV.D W0, W10
0042B6  980F0A     MOV W10, [W14+16]
0042B8  980F1B     MOV W11, [W14+18]
0042BA  DE884F     ASR W1, #15, W0
0042BC  780580     MOV W0, W11
0042BE  980F2B     MOV W11, [W14+20]
0042C0  980F30     MOV W0, [W14+22]
0042C2  20EF80     MOV #0xEF8, W0
0042C4  900A0E     MOV [W14+16], W4
0042C6  900A9E     MOV [W14+18], W5
0042C8  900B2E     MOV [W14+20], W6
0042CA  900BBE     MOV [W14+22], W7
0042CC  BE9804     MOV.D W4, [W0++]
0042CE  BE9006     MOV.D W6, [W0--]
160:               			if (samples_32t>0)
0042D0  807800     MOV 0xF00, W0
0042D2  807811     MOV 0xF02, W1
0042D4  500FE0     SUB W0, #0x0, [W15]
0042D6  588FE0     SUBB W1, #0x0, [W15]
0042D8  340260     BRA LE, .L10, .LSM99
161:               			{
162:               				xx_bar = (int32_t)(xx_sum /samples_64t) ;
0042DA  20F0A0     MOV #0xF0A, W0
0042DC  BE0430     MOV.D [W0++], W8
0042DE  BE0520     MOV.D [W0--], W10
0042E0  20EF80     MOV #0xEF8, W0
0042E2  BE0150     MOV.D [++W0], W2
0042E4  BE0040     MOV.D [--W0], W0
0042E6  BE0302     MOV.D W2, W6
0042E8  BE0200     MOV.D W0, W4
0042EA  BE0008     MOV.D W8, W0
0042EC  BE010A     MOV.D W10, W2
0042EE  0213DC     CALL ___divdi3
0042F0  000000     NOP
0042F2  BE0000     MOV.D W0, W0
0042F4  8879D0     MOV W0, 0xF3A
0042F6  8879E1     MOV W1, 0xF3C
163:               			
164:               				xy_bar[0] = (int32_t)(xy_sum[0] /samples_64t) ;
0042F8  20F120     MOV #0xF12, W0
0042FA  BE0430     MOV.D [W0++], W8
0042FC  BE0520     MOV.D [W0--], W10
0042FE  20EF80     MOV #0xEF8, W0
004300  BE0150     MOV.D [++W0], W2
004302  BE0040     MOV.D [--W0], W0
004304  BE0302     MOV.D W2, W6
004306  BE0200     MOV.D W0, W4
004308  BE0008     MOV.D W8, W0
00430A  BE010A     MOV.D W10, W2
00430C  0213DC     CALL ___divdi3
00430E  000000     NOP
004310  BE0000     MOV.D W0, W0
004312  8879F0     MOV W0, 0xF3E
004314  887A01     MOV W1, 0xF40
165:               				xy_bar[1] = (int32_t)(xy_sum[1] /samples_64t) ;
004316  20F1A0     MOV #0xF1A, W0
004318  BE0430     MOV.D [W0++], W8
00431A  BE0520     MOV.D [W0--], W10
00431C  20EF80     MOV #0xEF8, W0
00431E  BE0150     MOV.D [++W0], W2
004320  BE0040     MOV.D [--W0], W0
004322  BE0302     MOV.D W2, W6
004324  BE0200     MOV.D W0, W4
004326  BE0008     MOV.D W8, W0
004328  BE010A     MOV.D W10, W2
00432A  0213DC     CALL ___divdi3
00432C  000000     NOP
00432E  BE0000     MOV.D W0, W0
004330  887A10     MOV W0, 0xF42
004332  887A21     MOV W1, 0xF44
166:               				xy_bar[2] = (int32_t)(xy_sum[2] /samples_64t) ;
004334  20F220     MOV #0xF22, W0
004336  BE0430     MOV.D [W0++], W8
004338  BE0520     MOV.D [W0--], W10
00433A  20EF80     MOV #0xEF8, W0
00433C  BE0150     MOV.D [++W0], W2
00433E  BE0040     MOV.D [--W0], W0
004340  BE0302     MOV.D W2, W6
004342  BE0200     MOV.D W0, W4
004344  BE0008     MOV.D W8, W0
004346  BE010A     MOV.D W10, W2
004348  0213DC     CALL ___divdi3
00434A  000000     NOP
00434C  BE0000     MOV.D W0, W0
00434E  887A30     MOV W0, reduced
004350  887A41     MOV W1, 0xF48
167:               			
168:               				x_bar = (int16_t)(x_sum/samples_32t);
004352  807954     MOV 0xF2A, W4
004354  807965     MOV 0xF2C, W5
004356  807800     MOV 0xF00, W0
004358  807811     MOV 0xF02, W1
00435A  BE0100     MOV.D W0, W2
00435C  BE0004     MOV.D W4, W0
00435E  02102A     CALL ___divsi3
004360  000000     NOP
004362  780000     MOV W0, W0
004364  887A50     MOV W0, 0xF4A
169:               			
170:               				y_bar[0] = (int16_t)(y_sum[0]/samples_32t);
004366  807974     MOV 0xF2E, W4
004368  807985     MOV 0xF30, W5
00436A  807800     MOV 0xF00, W0
00436C  807811     MOV 0xF02, W1
00436E  BE0100     MOV.D W0, W2
004370  BE0004     MOV.D W4, W0
004372  02102A     CALL ___divsi3
004374  000000     NOP
004376  780000     MOV W0, W0
004378  887A60     MOV W0, 0xF4C
171:               				y_bar[1] = (int16_t)(y_sum[1]/samples_32t);
00437A  807994     MOV 0xF32, W4
00437C  8079A5     MOV 0xF34, W5
00437E  807800     MOV 0xF00, W0
004380  807811     MOV 0xF02, W1
004382  BE0100     MOV.D W0, W2
004384  BE0004     MOV.D W4, W0
004386  02102A     CALL ___divsi3
004388  000000     NOP
00438A  780000     MOV W0, W0
00438C  887A70     MOV W0, 0xF4E
172:               				y_bar[2] = (int16_t)(y_sum[2]/samples_32t);
00438E  8079B4     MOV 0xF36, W4
004390  8079C5     MOV 0xF38, W5
004392  807800     MOV 0xF00, W0
004394  807811     MOV 0xF02, W1
004396  BE0100     MOV.D W0, W2
004398  BE0004     MOV.D W4, W0
00439A  02102A     CALL ___divsi3
00439C  000000     NOP
00439E  780000     MOV W0, W0
0043A0  887A80     MOV W0, 0xF50
173:               			
174:               				xx_bar_minus_x_bar_x_bar = (int64_t)(((int64_t)xx_bar) - ((int64_t)x_bar)*((int64_t)x_bar)) ;
0043A2  8079D0     MOV 0xF3A, W0
0043A4  8079E1     MOV 0xF3C, W1
0043A6  BE0300     MOV.D W0, W6
0043A8  980F46     MOV W6, [W14+24]
0043AA  980F57     MOV W7, [W14+26]
0043AC  DE884F     ASR W1, #15, W0
0043AE  780380     MOV W0, W7
0043B0  980F67     MOV W7, [W14+28]
0043B2  980F70     MOV W0, [W14+30]
0043B4  807A50     MOV 0xF4A, W0
0043B6  780400     MOV W0, W8
0043B8  DEC4CF     ASR W8, #15, W9
0043BA  780509     MOV W9, W10
0043BC  78058A     MOV W10, W11
0043BE  807A50     MOV 0xF4A, W0
0043C0  DE80CF     ASR W0, #15, W1
0043C2  780101     MOV W1, W2
0043C4  780182     MOV W2, W3
0043C6  BE0302     MOV.D W2, W6
0043C8  BE0200     MOV.D W0, W4
0043CA  BE0008     MOV.D W8, W0
0043CC  BE010A     MOV.D W10, W2
0043CE  02149E     CALL ___muldi3
0043D0  000000     NOP
0043D2  900C4E     MOV [W14+24], W8
0043D4  900CDE     MOV [W14+26], W9
0043D6  900D6E     MOV [W14+28], W10
0043D8  900DFE     MOV [W14+30], W11
0043DA  540000     SUB W8, W0, W0
0043DC  5C8081     SUBB W9, W1, W1
0043DE  5D0102     SUBB W10, W2, W2
0043E0  5D8183     SUBB W11, W3, W3
0043E2  21D584     MOV #0x1D58, W4
0043E4  BE9A00     MOV.D W0, [W4++]
0043E6  BE9202     MOV.D W2, [W4--]
175:               			
176:               				// prevent division by 0, also, in theory xx_bar_minus_x_bar_x_bar must be positive
177:               				if (xx_bar_minus_x_bar_x_bar <= ((int64_t)0)) xx_bar_minus_x_bar_x_bar = 1 ;
0043E8  21D580     MOV #0x1D58, W0
0043EA  BE0150     MOV.D [++W0], W2
0043EC  BE0040     MOV.D [--W0], W0
0043EE  500FE0     SUB W0, #0x0, [W15]
0043F0  588FE0     SUBB W1, #0x0, [W15]
0043F2  590FE0     SUBB W2, #0x0, [W15]
0043F4  598FE0     SUBB W3, #0x0, [W15]
0043F6  3C0006     BRA GT, .L11, .LSM72
0043F8  21D584     MOV #0x1D58, W4
0043FA  200010     MOV #0x1, W0
0043FC  200001     MOV #0x0, W1
0043FE  B81160     MUL.UU W2, #0, W2
004400  BE9A00     MOV.D W0, [W4++]
004402  BE9202     MOV.D W2, [W4--]
178:               			
179:               				offset_left[0] = (int16_t) ((
00448A  780000     MOV W0, W0
00448C  88EB00     MOV W0, offset_left
180:               					((int64_t)y_bar[0])*((int64_t)xx_bar)
004404  807A60     MOV 0xF4C, W0
004406  780400     MOV W0, W8
004408  DEC4CF     ASR W8, #15, W9
00440A  780509     MOV W9, W10
00440C  78058A     MOV W10, W11
00440E  8079D0     MOV 0xF3A, W0
004410  8079E1     MOV 0xF3C, W1
004412  BE0100     MOV.D W0, W2
004414  981702     MOV W2, [W14+32]
004416  981713     MOV W3, [W14+34]
004418  DE884F     ASR W1, #15, W0
00441A  780180     MOV W0, W3
00441C  981723     MOV W3, [W14+36]
00441E  981730     MOV W0, [W14+38]
004420  90120E     MOV [W14+32], W4
004422  90129E     MOV [W14+34], W5
004424  90132E     MOV [W14+36], W6
004426  9013BE     MOV [W14+38], W7
004428  BE0008     MOV.D W8, W0
00442A  BE010A     MOV.D W10, W2
00442C  02149E     CALL ___muldi3
00442E  000000     NOP
004430  BE0302     MOV.D W2, W6
004432  BE0200     MOV.D W0, W4
004434  981744     MOV W4, [W14+40]
004436  981755     MOV W5, [W14+42]
004438  981766     MOV W6, [W14+44]
00443A  981777     MOV W7, [W14+46]
181:               					-((int64_t)x_bar)*((int64_t)xy_bar[0])		
00443C  807A50     MOV 0xF4A, W0
00443E  780400     MOV W0, W8
004440  DEC4CF     ASR W8, #15, W9
004442  780509     MOV W9, W10
004444  78058A     MOV W10, W11
004446  8079F0     MOV 0xF3E, W0
004448  807A01     MOV 0xF40, W1
00444A  BE0300     MOV.D W0, W6
00444C  981F06     MOV W6, [W14+48]
00444E  981F17     MOV W7, [W14+50]
004450  DE884F     ASR W1, #15, W0
004452  780380     MOV W0, W7
004454  981F27     MOV W7, [W14+52]
004456  981F30     MOV W0, [W14+54]
004458  901A0E     MOV [W14+48], W4
00445A  901A9E     MOV [W14+50], W5
00445C  901B2E     MOV [W14+52], W6
00445E  901BBE     MOV [W14+54], W7
004460  BE0008     MOV.D W8, W0
004462  BE010A     MOV.D W10, W2
004464  02149E     CALL ___muldi3
004466  000000     NOP
004468  90124E     MOV [W14+40], W4
00446A  9012DE     MOV [W14+42], W5
00446C  90136E     MOV [W14+44], W6
00446E  9013FE     MOV [W14+46], W7
004470  520400     SUB W4, W0, W8
004472  5A8481     SUBB W5, W1, W9
004474  5B0502     SUBB W6, W2, W10
004476  5B8583     SUBB W7, W3, W11
182:               					)/xx_bar_minus_x_bar_x_bar );
004478  21D580     MOV #0x1D58, W0
00447A  BE0150     MOV.D [++W0], W2
00447C  BE0040     MOV.D [--W0], W0
00447E  BE0302     MOV.D W2, W6
004480  BE0200     MOV.D W0, W4
004482  BE0008     MOV.D W8, W0
004484  BE010A     MOV.D W10, W2
004486  0213DC     CALL ___divdi3
004488  000000     NOP
183:               			
184:               				offset_left[1] = (int16_t) ((
004514  780000     MOV W0, W0
004516  88EB10     MOV W0, 0x1D62
185:               					((int64_t)y_bar[1])*((int64_t)xx_bar)
00448E  807A70     MOV 0xF4E, W0
004490  780400     MOV W0, W8
004492  DEC4CF     ASR W8, #15, W9
004494  780509     MOV W9, W10
004496  78058A     MOV W10, W11
004498  8079D0     MOV 0xF3A, W0
00449A  8079E1     MOV 0xF3C, W1
00449C  BE0300     MOV.D W0, W6
00449E  981F46     MOV W6, [W14+56]
0044A0  981F57     MOV W7, [W14+58]
0044A2  DE884F     ASR W1, #15, W0
0044A4  780380     MOV W0, W7
0044A6  981F67     MOV W7, [W14+60]
0044A8  981F70     MOV W0, [W14+62]
0044AA  901A4E     MOV [W14+56], W4
0044AC  901ADE     MOV [W14+58], W5
0044AE  901B6E     MOV [W14+60], W6
0044B0  901BFE     MOV [W14+62], W7
0044B2  BE0008     MOV.D W8, W0
0044B4  BE010A     MOV.D W10, W2
0044B6  02149E     CALL ___muldi3
0044B8  000000     NOP
0044BA  BE0502     MOV.D W2, W10
0044BC  BE0400     MOV.D W0, W8
0044BE  982708     MOV W8, [W14+64]
0044C0  982719     MOV W9, [W14+66]
0044C2  98272A     MOV W10, [W14+68]
0044C4  98273B     MOV W11, [W14+70]
186:               					-((int64_t)x_bar)*((int64_t)xy_bar[1])		
0044C6  807A50     MOV 0xF4A, W0
0044C8  780400     MOV W0, W8
0044CA  DEC4CF     ASR W8, #15, W9
0044CC  780509     MOV W9, W10
0044CE  78058A     MOV W10, W11
0044D0  807A10     MOV 0xF42, W0
0044D2  807A21     MOV 0xF44, W1
0044D4  BE0100     MOV.D W0, W2
0044D6  982742     MOV W2, [W14+72]
0044D8  982753     MOV W3, [W14+74]
0044DA  DE884F     ASR W1, #15, W0
0044DC  780180     MOV W0, W3
0044DE  982763     MOV W3, [W14+76]
0044E0  982770     MOV W0, [W14+78]
0044E2  90224E     MOV [W14+72], W4
0044E4  9022DE     MOV [W14+74], W5
0044E6  90236E     MOV [W14+76], W6
0044E8  9023FE     MOV [W14+78], W7
0044EA  BE0008     MOV.D W8, W0
0044EC  BE010A     MOV.D W10, W2
0044EE  02149E     CALL ___muldi3
0044F0  000000     NOP
0044F2  90220E     MOV [W14+64], W4
0044F4  90229E     MOV [W14+66], W5
0044F6  90232E     MOV [W14+68], W6
0044F8  9023BE     MOV [W14+70], W7
0044FA  520400     SUB W4, W0, W8
0044FC  5A8481     SUBB W5, W1, W9
0044FE  5B0502     SUBB W6, W2, W10
004500  5B8583     SUBB W7, W3, W11
187:               					)/xx_bar_minus_x_bar_x_bar );
004502  21D580     MOV #0x1D58, W0
004504  BE0150     MOV.D [++W0], W2
004506  BE0040     MOV.D [--W0], W0
004508  BE0302     MOV.D W2, W6
00450A  BE0200     MOV.D W0, W4
00450C  BE0008     MOV.D W8, W0
00450E  BE010A     MOV.D W10, W2
004510  0213DC     CALL ___divdi3
004512  000000     NOP
188:               			
189:               				offset_left[2] = (int16_t) ((
00459E  780000     MOV W0, W0
0045A0  88EB20     MOV W0, 0x1D64
190:               					((int64_t)y_bar[2])*((int64_t)xx_bar)
004518  807A80     MOV 0xF50, W0
00451A  780400     MOV W0, W8
00451C  DEC4CF     ASR W8, #15, W9
00451E  780509     MOV W9, W10
004520  78058A     MOV W10, W11
004522  8079D0     MOV 0xF3A, W0
004524  8079E1     MOV 0xF3C, W1
004526  BE0300     MOV.D W0, W6
004528  982F06     MOV W6, [W14+80]
00452A  982F17     MOV W7, [W14+82]
00452C  DE884F     ASR W1, #15, W0
00452E  780380     MOV W0, W7
004530  982F27     MOV W7, [W14+84]
004532  982F30     MOV W0, [W14+86]
004534  902A0E     MOV [W14+80], W4
004536  902A9E     MOV [W14+82], W5
004538  902B2E     MOV [W14+84], W6
00453A  902BBE     MOV [W14+86], W7
00453C  BE0008     MOV.D W8, W0
00453E  BE010A     MOV.D W10, W2
004540  02149E     CALL ___muldi3
004542  000000     NOP
004544  BE0502     MOV.D W2, W10
004546  BE0400     MOV.D W0, W8
004548  982F48     MOV W8, [W14+88]
00454A  982F59     MOV W9, [W14+90]
00454C  982F6A     MOV W10, [W14+92]
00454E  982F7B     MOV W11, [W14+94]
191:               					-((int64_t)x_bar)*((int64_t)xy_bar[2])		
004550  807A50     MOV 0xF4A, W0
004552  780400     MOV W0, W8
004554  DEC4CF     ASR W8, #15, W9
004556  780509     MOV W9, W10
004558  78058A     MOV W10, W11
00455A  807A30     MOV reduced, W0
00455C  807A41     MOV 0xF48, W1
00455E  BE0100     MOV.D W0, W2
004560  983702     MOV W2, [W14+96]
004562  983713     MOV W3, [W14+98]
004564  DE884F     ASR W1, #15, W0
004566  780180     MOV W0, W3
004568  983723     MOV W3, [W14+100]
00456A  983730     MOV W0, [W14+102]
00456C  90320E     MOV [W14+96], W4
00456E  90329E     MOV [W14+98], W5
004570  90332E     MOV [W14+100], W6
004572  9033BE     MOV [W14+102], W7
004574  BE0008     MOV.D W8, W0
004576  BE010A     MOV.D W10, W2
004578  02149E     CALL ___muldi3
00457A  000000     NOP
00457C  902A4E     MOV [W14+88], W4
00457E  902ADE     MOV [W14+90], W5
004580  902B6E     MOV [W14+92], W6
004582  902BFE     MOV [W14+94], W7
004584  520400     SUB W4, W0, W8
004586  5A8481     SUBB W5, W1, W9
004588  5B0502     SUBB W6, W2, W10
00458A  5B8583     SUBB W7, W3, W11
192:               					)/xx_bar_minus_x_bar_x_bar );
00458C  21D580     MOV #0x1D58, W0
00458E  BE0150     MOV.D [++W0], W2
004590  BE0040     MOV.D [--W0], W0
004592  BE0302     MOV.D W2, W6
004594  BE0200     MOV.D W0, W4
004596  BE0008     MOV.D W8, W0
004598  BE010A     MOV.D W10, W2
00459A  0213DC     CALL ___divdi3
00459C  000000     NOP
193:               			
194:               				offset_right[0] = (int16_t)((
004646  780000     MOV W0, W0
004648  88EB30     MOV W0, offset_right
195:               					
196:               					((int64_t)y_bar[0])*(((int64_t)xx_bar)-(((int64_t)STEP_SIZE)*((int64_t)x_bar)))
0045A2  807A60     MOV 0xF4C, W0
0045A4  780400     MOV W0, W8
0045A6  DEC4CF     ASR W8, #15, W9
0045A8  780509     MOV W9, W10
0045AA  78058A     MOV W10, W11
0045AC  8079D0     MOV 0xF3A, W0
0045AE  8079E1     MOV 0xF3C, W1
0045B0  BE0300     MOV.D W0, W6
0045B2  983746     MOV W6, [W14+104]
0045B4  983757     MOV W7, [W14+106]
0045B6  DE884F     ASR W1, #15, W0
0045B8  780380     MOV W0, W7
0045BA  983767     MOV W7, [W14+108]
0045BC  983770     MOV W0, [W14+110]
0045BE  807A50     MOV 0xF4A, W0
0045C0  DE80CF     ASR W0, #15, W1
0045C2  780101     MOV W1, W2
0045C4  780182     MOV W2, W3
0045C6  2FFC04     MOV #0xFFC0, W4
0045C8  2FFFF5     MOV #0xFFFF, W5
0045CA  2FFFF6     MOV #0xFFFF, W6
0045CC  2FFFF7     MOV #0xFFFF, W7
0045CE  02149E     CALL ___muldi3
0045D0  000000     NOP
0045D2  90324E     MOV [W14+104], W4
0045D4  9032DE     MOV [W14+106], W5
0045D6  90336E     MOV [W14+108], W6
0045D8  9033FE     MOV [W14+110], W7
0045DA  400004     ADD W0, W4, W0
0045DC  488085     ADDC W1, W5, W1
0045DE  490106     ADDC W2, W6, W2
0045E0  498187     ADDC W3, W7, W3
0045E2  BE0302     MOV.D W2, W6
0045E4  BE0200     MOV.D W0, W4
0045E6  BE0008     MOV.D W8, W0
0045E8  BE010A     MOV.D W10, W2
0045EA  02149E     CALL ___muldi3
0045EC  000000     NOP
0045EE  BE0502     MOV.D W2, W10
0045F0  BE0400     MOV.D W0, W8
197:               					-
00462C  400408     ADD W0, W8, W8
00462E  488489     ADDC W1, W9, W9
004630  49050A     ADDC W2, W10, W10
004632  49858B     ADDC W3, W11, W11
198:               					((int64_t)xy_bar[0])*(((int64_t)x_bar)-((int64_t)STEP_SIZE))
0045F2  8079F0     MOV 0xF3E, W0
0045F4  807A01     MOV 0xF40, W1
0045F6  BE0300     MOV.D W0, W6
0045F8  983F06     MOV W6, [W14+112]
0045FA  983F17     MOV W7, [W14+114]
0045FC  DE884F     ASR W1, #15, W0
0045FE  780380     MOV W0, W7
004600  983F27     MOV W7, [W14+116]
004602  983F30     MOV W0, [W14+118]
004604  807A50     MOV 0xF4A, W0
004606  780200     MOV W0, W4
004608  DEA2CF     ASR W4, #15, W5
00460A  780305     MOV W5, W6
00460C  780386     MOV W6, W7
00460E  200400     MOV #0x40, W0
004610  200001     MOV #0x0, W1
004612  B81160     MUL.UU W2, #0, W2
004614  500004     SUB W0, W4, W0
004616  588085     SUBB W1, W5, W1
004618  590106     SUBB W2, W6, W2
00461A  598187     SUBB W3, W7, W3
00461C  BE0302     MOV.D W2, W6
00461E  BE0200     MOV.D W0, W4
004620  90380E     MOV [W14+112], W0
004622  90389E     MOV [W14+114], W1
004624  90392E     MOV [W14+116], W2
004626  9039BE     MOV [W14+118], W3
004628  02149E     CALL ___muldi3
00462A  000000     NOP
199:               					)/xx_bar_minus_x_bar_x_bar);
004634  21D580     MOV #0x1D58, W0
004636  BE0150     MOV.D [++W0], W2
004638  BE0040     MOV.D [--W0], W0
00463A  BE0302     MOV.D W2, W6
00463C  BE0200     MOV.D W0, W4
00463E  BE0008     MOV.D W8, W0
004640  BE010A     MOV.D W10, W2
004642  0213DC     CALL ___divdi3
004644  000000     NOP
200:               			
201:               				offset_right[1] = (int16_t)((
0046EE  780000     MOV W0, W0
0046F0  88EB40     MOV W0, 0x1D68
202:               					
203:               					((int64_t)y_bar[1])*(((int64_t)xx_bar)-(((int64_t)STEP_SIZE)*((int64_t)x_bar)))
00464A  807A70     MOV 0xF4E, W0
00464C  780400     MOV W0, W8
00464E  DEC4CF     ASR W8, #15, W9
004650  780509     MOV W9, W10
004652  78058A     MOV W10, W11
004654  8079D0     MOV 0xF3A, W0
004656  8079E1     MOV 0xF3C, W1
004658  BE0100     MOV.D W0, W2
00465A  983F42     MOV W2, [W14+120]
00465C  983F53     MOV W3, [W14+122]
00465E  DE884F     ASR W1, #15, W0
004660  780180     MOV W0, W3
004662  983F63     MOV W3, [W14+124]
004664  983F70     MOV W0, [W14+126]
004666  807A50     MOV 0xF4A, W0
004668  DE80CF     ASR W0, #15, W1
00466A  780101     MOV W1, W2
00466C  780182     MOV W2, W3
00466E  2FFC04     MOV #0xFFC0, W4
004670  2FFFF5     MOV #0xFFFF, W5
004672  2FFFF6     MOV #0xFFFF, W6
004674  2FFFF7     MOV #0xFFFF, W7
004676  02149E     CALL ___muldi3
004678  000000     NOP
00467A  903A4E     MOV [W14+120], W4
00467C  903ADE     MOV [W14+122], W5
00467E  903B6E     MOV [W14+124], W6
004680  903BFE     MOV [W14+126], W7
004682  400004     ADD W0, W4, W0
004684  488085     ADDC W1, W5, W1
004686  490106     ADDC W2, W6, W2
004688  498187     ADDC W3, W7, W3
00468A  BE0302     MOV.D W2, W6
00468C  BE0200     MOV.D W0, W4
00468E  BE0008     MOV.D W8, W0
004690  BE010A     MOV.D W10, W2
004692  02149E     CALL ___muldi3
004694  000000     NOP
004696  BE0502     MOV.D W2, W10
004698  BE0400     MOV.D W0, W8
204:               					-
0046D4  400408     ADD W0, W8, W8
0046D6  488489     ADDC W1, W9, W9
0046D8  49050A     ADDC W2, W10, W10
0046DA  49858B     ADDC W3, W11, W11
205:               					((int64_t)xy_bar[1])*(((int64_t)x_bar)-((int64_t)STEP_SIZE))
00469A  807A10     MOV 0xF42, W0
00469C  807A21     MOV 0xF44, W1
00469E  BE0300     MOV.D W0, W6
0046A0  988706     MOV W6, [W14+128]
0046A2  988717     MOV W7, [W14+130]
0046A4  DE884F     ASR W1, #15, W0
0046A6  780380     MOV W0, W7
0046A8  988727     MOV W7, [W14+132]
0046AA  988730     MOV W0, [W14+134]
0046AC  807A50     MOV 0xF4A, W0
0046AE  780200     MOV W0, W4
0046B0  DEA2CF     ASR W4, #15, W5
0046B2  780305     MOV W5, W6
0046B4  780386     MOV W6, W7
0046B6  200400     MOV #0x40, W0
0046B8  200001     MOV #0x0, W1
0046BA  B81160     MUL.UU W2, #0, W2
0046BC  500004     SUB W0, W4, W0
0046BE  588085     SUBB W1, W5, W1
0046C0  590106     SUBB W2, W6, W2
0046C2  598187     SUBB W3, W7, W3
0046C4  BE0302     MOV.D W2, W6
0046C6  BE0200     MOV.D W0, W4
0046C8  90800E     MOV [W14+128], W0
0046CA  90809E     MOV [W14+130], W1
0046CC  90812E     MOV [W14+132], W2
0046CE  9081BE     MOV [W14+134], W3
0046D0  02149E     CALL ___muldi3
0046D2  000000     NOP
206:               					)/xx_bar_minus_x_bar_x_bar);
0046DC  21D580     MOV #0x1D58, W0
0046DE  BE0150     MOV.D [++W0], W2
0046E0  BE0040     MOV.D [--W0], W0
0046E2  BE0302     MOV.D W2, W6
0046E4  BE0200     MOV.D W0, W4
0046E6  BE0008     MOV.D W8, W0
0046E8  BE010A     MOV.D W10, W2
0046EA  0213DC     CALL ___divdi3
0046EC  000000     NOP
207:               			
208:               				offset_right[2] = (int16_t)((
004794  780000     MOV W0, W0
004796  88EB50     MOV W0, 0x1D6A
004798  370025     BRA .L12, .LSM114
209:               					
210:               					((int64_t)y_bar[2])*(((int64_t)xx_bar)-(((int64_t)STEP_SIZE)*((int64_t)x_bar)))
0046F2  807A80     MOV 0xF50, W0
0046F4  780400     MOV W0, W8
0046F6  DEC4CF     ASR W8, #15, W9
0046F8  780509     MOV W9, W10
0046FA  78058A     MOV W10, W11
0046FC  8079D0     MOV 0xF3A, W0
0046FE  8079E1     MOV 0xF3C, W1
004700  BE0100     MOV.D W0, W2
004702  988742     MOV W2, [W14+136]
004704  988753     MOV W3, [W14+138]
004706  DE884F     ASR W1, #15, W0
004708  780180     MOV W0, W3
00470A  988763     MOV W3, [W14+140]
00470C  988770     MOV W0, [W14+142]
00470E  807A50     MOV 0xF4A, W0
004710  DE80CF     ASR W0, #15, W1
004712  780101     MOV W1, W2
004714  780182     MOV W2, W3
004716  2FFC04     MOV #0xFFC0, W4
004718  2FFFF5     MOV #0xFFFF, W5
00471A  2FFFF6     MOV #0xFFFF, W6
00471C  2FFFF7     MOV #0xFFFF, W7
00471E  02149E     CALL ___muldi3
004720  000000     NOP
004722  90824E     MOV [W14+136], W4
004724  9082DE     MOV [W14+138], W5
004726  90836E     MOV [W14+140], W6
004728  9083FE     MOV [W14+142], W7
00472A  400004     ADD W0, W4, W0
00472C  488085     ADDC W1, W5, W1
00472E  490106     ADDC W2, W6, W2
004730  498187     ADDC W3, W7, W3
004732  BE0302     MOV.D W2, W6
004734  BE0200     MOV.D W0, W4
004736  BE0008     MOV.D W8, W0
004738  BE010A     MOV.D W10, W2
00473A  02149E     CALL ___muldi3
00473C  000000     NOP
00473E  BE0502     MOV.D W2, W10
004740  BE0400     MOV.D W0, W8
211:               					-
00477A  400408     ADD W0, W8, W8
00477C  488489     ADDC W1, W9, W9
00477E  49050A     ADDC W2, W10, W10
004780  49858B     ADDC W3, W11, W11
212:               					((int64_t)xy_bar[2])*(((int64_t)x_bar)-((int64_t)STEP_SIZE))
004742  807A30     MOV reduced, W0
004744  807A41     MOV 0xF48, W1
004746  BE0300     MOV.D W0, W6
004748  988F06     MOV W6, [W14+144]
00474A  988F17     MOV W7, [W14+146]
00474C  DE884F     ASR W1, #15, W0
00474E  780380     MOV W0, W7
004750  988F27     MOV W7, [W14+148]
004752  988F30     MOV W0, [W14+150]
004754  807A50     MOV 0xF4A, W0
004756  DE80CF     ASR W0, #15, W1
004758  780101     MOV W1, W2
00475A  780182     MOV W2, W3
00475C  200404     MOV #0x40, W4
00475E  200005     MOV #0x0, W5
004760  B83360     MUL.UU W6, #0, W6
004762  520000     SUB W4, W0, W0
004764  5A8081     SUBB W5, W1, W1
004766  5B0102     SUBB W6, W2, W2
004768  5B8183     SUBB W7, W3, W3
00476A  BE0302     MOV.D W2, W6
00476C  BE0200     MOV.D W0, W4
00476E  90880E     MOV [W14+144], W0
004770  90889E     MOV [W14+146], W1
004772  90892E     MOV [W14+148], W2
004774  9089BE     MOV [W14+150], W3
004776  02149E     CALL ___muldi3
004778  000000     NOP
213:               					)/xx_bar_minus_x_bar_x_bar);
004782  21D580     MOV #0x1D58, W0
004784  BE0150     MOV.D [++W0], W2
004786  BE0040     MOV.D [--W0], W0
004788  BE0302     MOV.D W2, W6
00478A  BE0200     MOV.D W0, W4
00478C  BE0008     MOV.D W8, W0
00478E  BE010A     MOV.D W10, W2
004790  0213DC     CALL ___divdi3
004792  000000     NOP
214:               			}
215:               			else
216:               			{
217:               				x_bar = 0 ;
00479A  EB0000     CLR W0
00479C  887A50     MOV W0, 0xF4A
218:               				y_bar[0] = 0 ;
00479E  EB0000     CLR W0
0047A0  887A60     MOV W0, 0xF4C
219:               				y_bar[1] = 0 ;
0047A2  EB0000     CLR W0
0047A4  887A70     MOV W0, 0xF4E
220:               				y_bar[2] = 0 ;
0047A6  EB0000     CLR W0
0047A8  887A80     MOV W0, 0xF50
221:               				xx_bar = 0 ;
0047AA  B80060     MUL.UU W0, #0, W0
0047AC  8879D0     MOV W0, 0xF3A
0047AE  8879E1     MOV W1, 0xF3C
222:               				xy_bar[0] = 0 ;
0047B0  B80060     MUL.UU W0, #0, W0
0047B2  8879F0     MOV W0, 0xF3E
0047B4  887A01     MOV W1, 0xF40
223:               				xy_bar[1] = 0 ;
0047B6  B80060     MUL.UU W0, #0, W0
0047B8  887A10     MOV W0, 0xF42
0047BA  887A21     MOV W1, 0xF44
224:               				xy_bar[2] = 0 ;
0047BC  B80060     MUL.UU W0, #0, W0
0047BE  887A30     MOV W0, reduced
0047C0  887A41     MOV W1, 0xF48
225:               				xx_bar_minus_x_bar_x_bar = 0 ;
0047C2  21D584     MOV #0x1D58, W4
0047C4  B80060     MUL.UU W0, #0, W0
0047C6  B81160     MUL.UU W2, #0, W2
0047C8  BE9A00     MOV.D W0, [W4++]
0047CA  BE9202     MOV.D W2, [W4--]
226:               				offset_left[0] = 0 ;
0047CC  EB0000     CLR W0
0047CE  88EB00     MOV W0, offset_left
227:               				offset_left[1] = 0 ;
0047D0  EB0000     CLR W0
0047D2  88EB10     MOV W0, 0x1D62
228:               				offset_left[2] = 0 ;
0047D4  EB0000     CLR W0
0047D6  88EB20     MOV W0, 0x1D64
229:               				offset_right[0] = 0 ;
0047D8  EB0000     CLR W0
0047DA  88EB30     MOV W0, offset_right
230:               				offset_right[1] = 0 ;
0047DC  EB0000     CLR W0
0047DE  88EB40     MOV W0, 0x1D68
231:               				offset_right[2] = 0 ;
0047E0  EB0000     CLR W0
0047E2  88EB50     MOV W0, 0x1D6A
232:               			}
233:               			if (initial_temp_reported == 1)
0047E4  807AE0     MOV 0xF5C, W0
0047E6  500FE1     SUB W0, #0x1, [W15]
0047E8  3A0029     BRA NZ, .L13, .LSM124
234:               			{
235:               #ifdef DEBUG_TABLE_BUILD
236:               				serial_output("%i,%li,%i,%i,%i,%i,%li,%li,%li,%li,%li,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n",
237:               					udb_cpu_load(),
238:               					samples_32t,
239:               					x_bar,
240:               					y_bar[0],y_bar[1],y_bar[2],
241:               					xx_bar,
242:               					xy_bar[0], xy_bar[1],xy_bar[2],
243:               					(int32_t)xx_bar_minus_x_bar_x_bar ,
244:               					offset_left[0],offset_left[1],offset_left[2],
245:               					offset_right[0],offset_right[1],offset_right[2],
246:               					(offset_previous[0]+ offset_left[0])/2 ,
247:               					(offset_previous[1]+ offset_left[1])/2 ,
248:               					(offset_previous[2]+ offset_left[2])/2 ) ;
249:               #else
250:               				serial_output("{ %i , %i , %i } , \r\n",
0047F0  200020     MOV #0x2, W0
0047F2  780400     MOV W0, W8
0047F4  090011     REPEAT #0x11
0047F6  D80088     DIV.SW W1, W8
0047F8  780100     MOV W0, W2
004800  200020     MOV #0x2, W0
004802  780480     MOV W0, W9
004804  090011     REPEAT #0x11
004806  D80089     DIV.SW W1, W9
004808  780080     MOV W0, W1
004810  200020     MOV #0x2, W0
004812  780500     MOV W0, W10
004814  781F81     MOV W1, [W15++]
004816  090011     REPEAT #0x11
004818  D8018A     DIV.SW W3, W10
00481A  780181     MOV W1, W3
00481C  7800CF     MOV [--W15], W1
00481E  781F82     MOV W2, [W15++]
004820  781F81     MOV W1, [W15++]
004822  781F80     MOV W0, [W15++]
004824  2B42E0     MOV #0xB42E, W0
004826  781F80     MOV W0, [W15++]
004828  020336     CALL serial_output
00482A  000000     NOP
00482C  5787E8     SUB W15, #0x8, W15
251:               					(offset_previous[0]+ offset_left[0])/2 ,
00480A  80EB63     MOV offset_previous, W3
00480C  80EB00     MOV offset_left, W0
00480E  418180     ADD W3, W0, W3
252:               					(offset_previous[1]+ offset_left[1])/2 ,
0047FA  80EB71     MOV 0x1D6E, W1
0047FC  80EB10     MOV 0x1D62, W0
0047FE  408080     ADD W1, W0, W1
253:               					(offset_previous[2]+ offset_left[2])/2 ) ;	
0047EA  80EB81     MOV 0x1D70, W1
0047EC  80EB20     MOV 0x1D64, W0
0047EE  408080     ADD W1, W0, W1
254:               		
255:               				offset_previous[0] = offset_right[0] ;
00482E  80EB30     MOV offset_right, W0
004830  88EB60     MOV W0, offset_previous
256:               				offset_previous[1] = offset_right[1] ;
004832  80EB40     MOV 0x1D68, W0
004834  88EB70     MOV W0, 0x1D6E
257:               				offset_previous[2] = offset_right[2] ;
004836  80EB50     MOV 0x1D6A, W0
004838  88EB80     MOV W0, 0x1D70
00483A  370015     BRA .L14, .LSM129
258:               #endif // 	DEBUG_TABLE_BUILD					
259:               			}
260:               			else
261:               			{
262:               				initial_temp_reported = 1 ;
00483C  200010     MOV #0x1, W0
00483E  887AE0     MOV W0, 0xF5C
263:               #ifdef DEBUG_TABLE_BUILD
264:               				serial_output("initial temperature = %i\r\n%i,%li,%i,%i,%i,%i,%li,%li,%li,%li,%li,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n",
265:               					initial_temperature ,
266:               					udb_cpu_load(),
267:               					samples_32t,
268:               					x_bar,
269:               					y_bar[0],y_bar[1],y_bar[2],
270:               					xx_bar,
271:               					xy_bar[0], xy_bar[1],xy_bar[2],
272:               					(int32_t)xx_bar_minus_x_bar_x_bar ,
273:               					offset_left[0],offset_left[1],offset_left[2],
274:               					offset_right[0],offset_right[1],offset_right[2],
275:               					offset_left[0],offset_left[1],offset_left[2]);
276:               #else
277:               				serial_output("initial temperature = %i\r\n{ %i , %i , %i } , \r\n",
004840  80EB23     MOV 0x1D64, W3
004842  80EB12     MOV 0x1D62, W2
004844  80EB01     MOV offset_left, W1
004846  807AB0     MOV 0xF56, W0
004848  781F83     MOV W3, [W15++]
00484A  781F82     MOV W2, [W15++]
00484C  781F81     MOV W1, [W15++]
00484E  781F80     MOV W0, [W15++]
004850  2B4440     MOV #0xB444, W0
004852  781F80     MOV W0, [W15++]
004854  020336     CALL serial_output
004856  000000     NOP
004858  5787EA     SUB W15, #0xA, W15
278:               					initial_temperature ,
279:               					offset_left[0],offset_left[1],offset_left[2]	
280:               						);
281:               #endif // DEBUG_TABLE_BUILD
282:               				offset_previous[0] = offset_right[0] ;
00485A  80EB30     MOV offset_right, W0
00485C  88EB60     MOV W0, offset_previous
283:               				offset_previous[1] = offset_right[1] ;
00485E  80EB40     MOV 0x1D68, W0
004860  88EB70     MOV W0, 0x1D6E
284:               				offset_previous[2] = offset_right[2] ;
004862  80EB50     MOV 0x1D6A, W0
004864  88EB80     MOV W0, 0x1D70
285:               			}
286:               			
287:               			samples_32t = 0 ;
004866  B80060     MUL.UU W0, #0, W0
004868  887800     MOV W0, 0xF00
00486A  887811     MOV W1, 0xF02
288:               			xx_sum = 0 ;
00486C  20F0A4     MOV #0xF0A, W4
00486E  B80060     MUL.UU W0, #0, W0
004870  B81160     MUL.UU W2, #0, W2
004872  BE9A00     MOV.D W0, [W4++]
004874  BE9202     MOV.D W2, [W4--]
289:               			x_sum = 0 ;
004876  B80060     MUL.UU W0, #0, W0
004878  887950     MOV W0, 0xF2A
00487A  887961     MOV W1, 0xF2C
290:               			xy_sum[0] = 0 ;
00487C  20F124     MOV #0xF12, W4
00487E  B80060     MUL.UU W0, #0, W0
004880  B81160     MUL.UU W2, #0, W2
004882  BE9A00     MOV.D W0, [W4++]
004884  BE9202     MOV.D W2, [W4--]
291:               			xy_sum[1] = 0 ;
004886  20F1A4     MOV #0xF1A, W4
004888  B80060     MUL.UU W0, #0, W0
00488A  B81160     MUL.UU W2, #0, W2
00488C  BE9A00     MOV.D W0, [W4++]
00488E  BE9202     MOV.D W2, [W4--]
292:               			xy_sum[2] = 0 ;
004890  20F224     MOV #0xF22, W4
004892  B80060     MUL.UU W0, #0, W0
004894  B81160     MUL.UU W2, #0, W2
004896  BE9A00     MOV.D W0, [W4++]
004898  BE9202     MOV.D W2, [W4--]
293:               			y_sum[0] = 0 ;
00489A  B80060     MUL.UU W0, #0, W0
00489C  887970     MOV W0, 0xF2E
00489E  887981     MOV W1, 0xF30
294:               			y_sum[1] = 0 ;
0048A0  B80060     MUL.UU W0, #0, W0
0048A2  887990     MOV W0, 0xF32
0048A4  8879A1     MOV W1, 0xF34
295:               			y_sum[2] = 0 ;
0048A6  B80060     MUL.UU W0, #0, W0
0048A8  8879B0     MOV W0, 0xF36
0048AA  8879C1     MOV W1, 0xF38
296:               		}
297:               	}		
298:               }
0048AC  BE054F     MOV.D [--W15], W10
0048AE  BE044F     MOV.D [--W15], W8
0048B0  FA8000     ULNK
0048B2  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/fbcl.s  --------------------------------------------
                                                  1:     
                                                  2:     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                  3:     
                                                  4:     	.section .libdsp, code
                                                  5:     
                                                  6:     
                                                  7:     
                                                  8:     	.global	_FindFirstBitChangeFromLeft	; export
                                                  9:     _FindFirstBitChangeFromLeft:
                                                  10:    
0008E2  DF0000     FBCL W0, W0                    11:    	FBCL	W0 , W0
0008E4  060000     RETURN                         12:    	return
                                                  13:    
                                                  14:    	.global	_FindFirstBitFromLeft	; export
                                                  15:    _FindFirstBitFromLeft:
                                                  16:    
0008E6  CF8000     FF1L W0, W0                    17:    	FF1L	W0 , W0
0008E8  060000     RETURN                         18:    	return
                                                  19:    
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/events.c  ------------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                // Manages software triggered events to run registered callbacks
23:                
24:                #include "libUDB.h"
25:                #include "events.h"
26:                #include "interrupt.h"
27:                
28:                #define _EVENTL_TRIGGERIP _C2IP
29:                #define _EVENTL_TRIGGERIF _C2IF
30:                #define _EVENTL_TRIGGERIE _C2IE
31:                #define _EVENTL_INTERUPT  _C2Interrupt
32:                
33:                #define _EVENTM_TRIGGERIP _C1IP
34:                #define _EVENTM_TRIGGERIF _C1IF
35:                #define _EVENTM_TRIGGERIE _C1IE
36:                #define _EVENTM_INTERUPT  _C1Interrupt
37:                
38:                EVENT events[MAX_EVENTS];
39:                boolean event_init_done = false;
40:                
41:                uint16_t register_event(void(*event_callback)(void))
42:                {
00782E  FA0002     LNK #0x2
007830  780F00     MOV W0, [W14]
43:                	return register_event_p(event_callback, EVENT_PRIORITY_MEDIUM);
007832  200011     MOV #0x1, W1
007834  78001E     MOV [W14], W0
007836  070002     RCALL register_event_p
44:                }
007838  FA8000     ULNK
00783A  060000     RETURN
45:                
46:                uint16_t register_event_p(void(*event_callback)(void), eventPriority priority)
47:                {
00783C  FA0006     LNK #0x6
00783E  980710     MOV W0, [W14+2]
007840  980721     MOV W1, [W14+4]
48:                	int16_t eventIndex;
49:                
50:                	for (eventIndex = 0; eventIndex < MAX_EVENTS; eventIndex++)
007842  EB0000     CLR W0
007844  780F00     MOV W0, [W14]
007846  37001A     BRA .L3
00787A  E80F1E     INC [W14], [W14]
00787C  78001E     MOV [W14], W0
00787E  500FEF     SUB W0, #0xF, [W15]
007880  34FFE3     BRA LE, .L6, .LSM5
51:                	{
52:                		if (events[eventIndex].event_callback == NULL)
007848  78001E     MOV [W14], W0
00784A  B90066     MUL.SU W0, #6, W0
00784C  780000     MOV W0, W0
00784E  E88080     INC2 W0, W1
007850  21BE40     MOV #0x1BE4, W0
007852  408000     ADD W1, W0, W0
007854  780010     MOV [W0], W0
007856  500FE0     SUB W0, #0x0, [W15]
007858  3A0010     BRA NZ, .L4, .LSM9
53:                		{
54:                			events[eventIndex].event_callback = event_callback;
00785A  78001E     MOV [W14], W0
00785C  B90066     MUL.SU W0, #6, W0
00785E  780080     MOV W0, W1
007860  21BE60     MOV #0x1BE6, W0
007862  408000     ADD W1, W0, W0
007864  90009E     MOV [W14+2], W1
007866  780801     MOV W1, [W0]
55:                			events[eventIndex].priority = priority;
007868  90012E     MOV [W14+4], W2
00786A  78001E     MOV [W14], W0
00786C  B90066     MUL.SU W0, #6, W0
00786E  780080     MOV W0, W1
007870  21BE80     MOV #0x1BE8, W0
007872  408000     ADD W1, W0, W0
007874  780802     MOV W2, [W0]
56:                			return eventIndex;
007876  78001E     MOV [W14], W0
007878  370005     BRA .L5, .LSM11
57:                		}
58:                	}
59:                	return INVALID_HANDLE;
007882  EB8000     SETM W0
60:                }
007884  FA8000     ULNK
007886  060000     RETURN
61:                
62:                void trigger_event(uint16_t hEvent)
63:                {
007888  FA0002     LNK #0x2
00788A  780F00     MOV W0, [W14]
64:                	if (hEvent < MAX_EVENTS)
00788C  78001E     MOV [W14], W0
00788E  500FEF     SUB W0, #0xF, [W15]
007890  3E0020     BRA GTU, .L7, .LSM21
65:                	{
66:                		if (events[hEvent].event_callback != NULL)
007892  78001E     MOV [W14], W0
007894  B90066     MUL.SU W0, #6, W0
007896  780000     MOV W0, W0
007898  E88080     INC2 W0, W1
00789A  21BE40     MOV #0x1BE4, W0
00789C  408000     ADD W1, W0, W0
00789E  780010     MOV [W0], W0
0078A0  500FE0     SUB W0, #0x0, [W15]
0078A2  320017     BRA Z, .L7, .LSM21
67:                		{
68:                			events[hEvent].eventPending = true;
0078A4  78001E     MOV [W14], W0
0078A6  B90066     MUL.SU W0, #6, W0
0078A8  780080     MOV W0, W1
0078AA  21BE40     MOV #0x1BE4, W0
0078AC  408080     ADD W1, W0, W1
0078AE  B3C010     MOV.B #0x1, W0
0078B0  784880     MOV.B W0, [W1]
69:                			switch(events[hEvent].priority)
0078B2  78001E     MOV [W14], W0
0078B4  B90066     MUL.SU W0, #6, W0
0078B6  780000     MOV W0, W0
0078B8  4000E4     ADD W0, #0x4, W1
0078BA  21BE40     MOV #0x1BE4, W0
0078BC  408000     ADD W1, W0, W0
0078BE  780010     MOV [W0], W0
0078C0  500FE0     SUB W0, #0x0, [W15]
0078C2  320003     BRA Z, .L9, .LSM17
0078C4  500FE1     SUB W0, #0x1, [W15]
0078C6  320003     BRA Z, .L10, .LSM19
0078C8  370004     BRA .L7, .LSM21
70:                			{
71:                			case EVENT_PRIORITY_LOW:
72:                				_EVENTL_TRIGGERIF = 1;  // trigger the interrupt
0078CA  A8008B     BSET 0x8B, #0
73:                				break;
0078CC  370002     BRA .L7, .LSM21
74:                			case EVENT_PRIORITY_MEDIUM:
75:                				_EVENTM_TRIGGERIF = 1;  // trigger the interrupt
0078CE  A86088     BSET IFS2, #3
76:                				break;
0078D0  000000     NOP
77:                //			case EVENT_PRIORITY_HIGH:
78:                //				_EVENTH_TRIGGERIF = 1;  // trigger the interrupt
79:                //				break;
80:                			}
81:                		}
82:                	}
83:                }
0078D2  FA8000     ULNK
0078D4  060000     RETURN
84:                
85:                void init_events(void)  // initialize events handler
86:                {
0078D6  FA0002     LNK #0x2
87:                	// The TRIGGER interrupt is used a software interrupt event trigger
88:                	_EVENTL_TRIGGERIP = INT_PRI_EVENTL;
0078D8  800601     MOV IPC14, W1
0078DA  2FFF80     MOV #0xFFF8, W0
0078DC  608000     AND W1, W0, W0
0078DE  A00000     BSET W0, #0
0078E0  880600     MOV W0, IPC14
89:                	_EVENTL_TRIGGERIF = 0;      // clear the interrupt
0078E2  A9008B     BCLR 0x8B, #0
90:                	_EVENTL_TRIGGERIE = 1;      // enable the interrupt
0078E4  A8009B     BSET 0x9B, #0
91:                
92:                	_EVENTM_TRIGGERIP = INT_PRI_EVENTM;
0078E6  8005A1     MOV IPC8, W1
0078E8  28FFF0     MOV #0x8FFF, W0
0078EA  608080     AND W1, W0, W1
0078EC  220000     MOV #0x2000, W0
0078EE  708000     IOR W1, W0, W0
0078F0  8805A0     MOV W0, IPC8
93:                	_EVENTM_TRIGGERIF = 0;      // clear the interrupt
0078F2  A96088     BCLR IFS2, #3
94:                	_EVENTM_TRIGGERIE = 1;      // enable the interrupt
0078F4  A86098     BSET IEC2, #3
95:                
96:                	int16_t eventIndex;
97:                
98:                	for (eventIndex = 0; eventIndex < MAX_EVENTS; eventIndex++)
0078F6  EB0000     CLR W0
0078F8  780F00     MOV W0, [W14]
0078FA  370016     BRA .L12
007926  E80F1E     INC [W14], [W14]
007928  78001E     MOV [W14], W0
00792A  500FEF     SUB W0, #0xF, [W15]
00792C  34FFE7     BRA LE, .L13, .LSM30
99:                	{
100:               		events[eventIndex].event_callback = NULL;
0078FC  78001E     MOV [W14], W0
0078FE  B90066     MUL.SU W0, #6, W0
007900  780080     MOV W0, W1
007902  21BE60     MOV #0x1BE6, W0
007904  408000     ADD W1, W0, W0
007906  EB0080     CLR W1
007908  780801     MOV W1, [W0]
101:               		events[eventIndex].eventPending   = false;
00790A  78001E     MOV [W14], W0
00790C  B90066     MUL.SU W0, #6, W0
00790E  780080     MOV W0, W1
007910  21BE40     MOV #0x1BE4, W0
007912  408080     ADD W1, W0, W1
007914  EB4000     CLR.B W0
007916  784880     MOV.B W0, [W1]
102:               		events[eventIndex].priority       = EVENT_PRIORITY_LOW;
007918  78001E     MOV [W14], W0
00791A  B90066     MUL.SU W0, #6, W0
00791C  780080     MOV W0, W1
00791E  21BE80     MOV #0x1BE8, W0
007920  408000     ADD W1, W0, W0
007922  EB0080     CLR W1
007924  780801     MOV W1, [W0]
103:               	}
104:               	event_init_done = true;
00792E  21EA21     MOV #0x1EA2, W1
007930  B3C010     MOV.B #0x1, W0
007932  784880     MOV.B W0, [W1]
105:               }
007934  FA8000     ULNK
007936  060000     RETURN
106:               
107:               //  process EVENT TRIGGER interrupt = software interrupt
108:               void __attribute__((__interrupt__, __no_auto_psv__)) _EVENTL_INTERUPT(void) 
109:               {
007938  F80036     PUSH RCOUNT
00793A  BE9F80     MOV.D W0, [W15++]
00793C  BE9F82     MOV.D W2, [W15++]
00793E  BE9F84     MOV.D W4, [W15++]
007940  BE9F86     MOV.D W6, [W15++]
007942  FA0004     LNK #0x4
110:               	_EVENTL_TRIGGERIF = 0;      // clear the interrupt
007944  A9008B     BCLR 0x8B, #0
111:               	indicate_loading_inter;
112:               	set_ipl_on_output_pin;
113:               	interrupt_save_set_corcon;
007946  F80044     PUSH CORCON
007948  80F530     MOV 0x1EA6, W0
00794A  880220     MOV W0, CORCON
114:               
115:               	int16_t eventIndex;
116:               	EVENT* pEvent;
117:               
118:               	if (event_init_done)
00794C  21EA20     MOV #0x1EA2, W0
00794E  784010     MOV.B [W0], W0
007950  504FE0     SUB.B W0, #0x0, [W15]
007952  32001F     BRA Z, .L15, .LSM47
119:               	{
120:               		for (eventIndex = 0; eventIndex < MAX_EVENTS; eventIndex++)
007954  EB0000     CLR W0
007956  780F00     MOV W0, [W14]
007958  370019     BRA .L16
00798A  E80F1E     INC [W14], [W14]
00798C  78001E     MOV [W14], W0
00798E  500FEF     SUB W0, #0xF, [W15]
007990  34FFE4     BRA LE, .L18, .LSM41
121:               		{
122:               			pEvent = &events[eventIndex];
00795A  78001E     MOV [W14], W0
00795C  B90066     MUL.SU W0, #6, W0
00795E  780080     MOV W0, W1
007960  21BE40     MOV #0x1BE4, W0
007962  408000     ADD W1, W0, W0
007964  980710     MOV W0, [W14+2]
123:               			if ((pEvent->eventPending == true) && (pEvent->priority == EVENT_PRIORITY_LOW))
007966  90001E     MOV [W14+2], W0
007968  784010     MOV.B [W0], W0
00796A  504FE1     SUB.B W0, #0x1, [W15]
00796C  3A000E     BRA NZ, .L17, .LSM46
00796E  90001E     MOV [W14+2], W0
007970  900020     MOV [W0+4], W0
007972  500FE0     SUB W0, #0x0, [W15]
007974  3A000A     BRA NZ, .L17, .LSM46
124:               			{
125:               				pEvent->eventPending = false;
007976  90009E     MOV [W14+2], W1
007978  EB4000     CLR.B W0
00797A  784880     MOV.B W0, [W1]
126:               				if (pEvent->event_callback != NULL)
00797C  90001E     MOV [W14+2], W0
00797E  900010     MOV [W0+2], W0
007980  500FE0     SUB W0, #0x0, [W15]
007982  320003     BRA Z, .L17, .LSM46
127:               				{
128:               					pEvent->event_callback();
007984  90001E     MOV [W14+2], W0
007986  900010     MOV [W0+2], W0
007988  010000     CALL W0
129:               				}
130:               			}
131:               		}
132:               	}
133:               	interrupt_restore_corcon;
007992  F90044     POP CORCON
134:               	unset_ipl_on_output_pin;
135:               }
007994  FA8000     ULNK
007996  BE034F     MOV.D [--W15], W6
007998  BE024F     MOV.D [--W15], W4
00799A  BE014F     MOV.D [--W15], W2
00799C  BE004F     MOV.D [--W15], W0
00799E  F90036     POP RCOUNT
0079A0  064000     RETFIE
136:               
137:               void __attribute__((__interrupt__, __no_auto_psv__)) _EVENTM_INTERUPT(void)
138:               {
0079A2  F80036     PUSH RCOUNT
0079A4  BE9F80     MOV.D W0, [W15++]
0079A6  BE9F82     MOV.D W2, [W15++]
0079A8  BE9F84     MOV.D W4, [W15++]
0079AA  BE9F86     MOV.D W6, [W15++]
0079AC  FA0004     LNK #0x4
139:               	_EVENTM_TRIGGERIF = 0;      // clear the interrupt
0079AE  A96088     BCLR IFS2, #3
140:               	indicate_loading_inter;
141:               	set_ipl_on_output_pin;
142:               	interrupt_save_set_corcon;
0079B0  F80044     PUSH CORCON
0079B2  80F530     MOV 0x1EA6, W0
0079B4  880220     MOV W0, CORCON
143:               
144:               	int16_t eventIndex;
145:               	EVENT* pEvent;
146:               
147:               	if (event_init_done)
0079B6  21EA20     MOV #0x1EA2, W0
0079B8  784010     MOV.B [W0], W0
0079BA  504FE0     SUB.B W0, #0x0, [W15]
0079BC  32001F     BRA Z, .L20, .LSM60
148:               	{
149:               		for (eventIndex = 0; eventIndex < MAX_EVENTS; eventIndex++)
0079BE  EB0000     CLR W0
0079C0  780F00     MOV W0, [W14]
0079C2  370019     BRA .L21
0079F4  E80F1E     INC [W14], [W14]
0079F6  78001E     MOV [W14], W0
0079F8  500FEF     SUB W0, #0xF, [W15]
0079FA  34FFE4     BRA LE, .L23, .LSM54
150:               		{
151:               			pEvent = &events[eventIndex];
0079C4  78001E     MOV [W14], W0
0079C6  B90066     MUL.SU W0, #6, W0
0079C8  780080     MOV W0, W1
0079CA  21BE40     MOV #0x1BE4, W0
0079CC  408000     ADD W1, W0, W0
0079CE  980710     MOV W0, [W14+2]
152:               			if ((pEvent->eventPending == true) && (pEvent->priority == EVENT_PRIORITY_MEDIUM))
0079D0  90001E     MOV [W14+2], W0
0079D2  784010     MOV.B [W0], W0
0079D4  504FE1     SUB.B W0, #0x1, [W15]
0079D6  3A000E     BRA NZ, .L22, .LSM59
0079D8  90001E     MOV [W14+2], W0
0079DA  900020     MOV [W0+4], W0
0079DC  500FE1     SUB W0, #0x1, [W15]
0079DE  3A000A     BRA NZ, .L22, .LSM59
153:               			{
154:               				pEvent->eventPending = false;
0079E0  90009E     MOV [W14+2], W1
0079E2  EB4000     CLR.B W0
0079E4  784880     MOV.B W0, [W1]
155:               				if (pEvent->event_callback != NULL)
0079E6  90001E     MOV [W14+2], W0
0079E8  900010     MOV [W0+2], W0
0079EA  500FE0     SUB W0, #0x0, [W15]
0079EC  320003     BRA Z, .L22, .LSM59
156:               				{
157:               					pEvent->event_callback();
0079EE  90001E     MOV [W14+2], W0
0079F0  900010     MOV [W0+2], W0
0079F2  010000     CALL W0
158:               				}
159:               			}
160:               		}
161:               	}
162:               	interrupt_restore_corcon;
0079FC  F90044     POP CORCON
163:               	unset_ipl_on_output_pin;
164:               }
0079FE  FA8000     ULNK
007A00  BE034F     MOV.D [--W15], W6
007A02  BE024F     MOV.D [--W15], W4
007A04  BE014F     MOV.D [--W15], W2
007A06  BE004F     MOV.D [--W15], W0
007A08  F90036     POP RCOUNT
007A0A  064000     RETFIE
165:               
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/background.c  --------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "oscillator.h"
24:                #include "interrupt.h"
25:                #include "heartbeat.h"
26:                
27:                //#define CPU_LOAD_PERCENT  1678  // = ((65536 * 100) / ((32000000 / 2) / (16 * 256)))
28:                //#define CPU_LOAD_PERCENT  839   // = ((65536 * 100) / ((64000000 / 2) / (16 * 256)))
29:                //      65536 to move result into upper 16 bits of 32 bit word
30:                //      100 to make a percentage
31:                //      32000000 frequency of chrystal clock
32:                //      2 is number of chrystal cycles to each cpu cycle
33:                //      (16 * 256) Number of cycles for (see PR5 below) before timer interrupts
34:                #define CPU_LOAD_PERCENT (6553600/((FCY)/4096))
35:                static uint16_t cpu_timer = 0;
36:                static uint16_t _cpu_timer = 0;
37:                
38:                inline uint8_t udb_cpu_load(void)
39:                {
007BBC  FA0000     LNK #0x0
40:                	// scale cpu_timer to seconds*100 for percent loading
41:                	return (uint8_t)(__builtin_muluu(cpu_timer, CPU_LOAD_PERCENT) >> 16);
007BBE  80F330     MOV cpu_timer, W0
007BC0  203461     MOV #0x346, W1
007BC2  B80001     MUL.UU W0, W1, W0
007BC4  DE0840     LSR W1, #0, W0
007BC6  200001     MOV #0x0, W1
007BC8  784000     MOV.B W0, W0
42:                }
007BCA  FA8000     ULNK
007BCC  060000     RETURN
43:                
44:                static inline void init_heartbeat(void)
45:                {
007BCE  FA0000     LNK #0x0
46:                //#ifdef USE_MPU_HEARTBEAT
47:                //#if (HEARTBEAT_HZ != 200)
48:                //#error HEARTBEAT_HZ must be set to 200 when using the MPU6000 as a heartbeat
49:                //#endif
50:                //#endif
51:                
52:                #if (BOARD_TYPE != UDB4_BOARD && HEARTBEAT_HZ == 200)
53:                
54:                	// MPU6000 interrupt is used as the HEARTBEAT_HZ heartbeat of libUDB.
55:                	// Timer1 is not used for heartbeat, but its interrupt flag is set in the
56:                	// MPU6000 ISR.
57:                	T1CONbits.TON = 0;      // turn off timer 1
007BD0  A9E105     BCLR 0x105, #7
58:                	TMR1 = 0;
007BD2  EB0000     CLR W0
007BD4  880800     MOV W0, TMR1
59:                	_T1IP = INT_PRI_T1;     // set interrupt priority
007BD6  800521     MOV IPC0, W1
007BD8  28FFF0     MOV #0x8FFF, W0
007BDA  608080     AND W1, W0, W1
007BDC  260000     MOV #0x6000, W0
007BDE  708000     IOR W1, W0, W0
007BE0  880520     MOV W0, IPC0
60:                	_T1IF = 0;              // clear the interrupt
007BE2  A96084     BCLR IFS0, #3
61:                	_T1IE = 1;              // enable the interrupt
007BE4  A86094     BSET IEC0, #3
62:                
63:                	// TODO: can we use timer1 to determine the error between the mcu and the mpu 200Hz?
64:                
65:                #else // BOARD_TYPE && HEARTBEAT_HZ
66:                
67:                	// use Timer1 as the HEARTBEAT source
68:                
69:                #if (HEARTBEAT_HZ < 150)
70:                #define TMR1_PRESCALE 64
71:                #else
72:                #define TMR1_PRESCALE 8
73:                #endif
74:                
75:                	// Initialize timer1, used as the HEARTBEAT_HZ heartbeat of libUDB.
76:                	TMR1 = 0;
77:                #if (TMR1_PRESCALE == 8)
78:                	T1CONbits.TCKPS = 1;    // prescaler = 8
79:                #elif (TMR1_PRESCALE == 64)
80:                	T1CONbits.TCKPS = 2;    // prescaler = 64
81:                #else
82:                #error Invalid Timer1 configuration
83:                #endif
84:                //	PR1 = 50000;            // 25 millisecond period at 16 Mz clock, tmr prescale = 8
85:                	PR1 = (FREQOSC / (TMR1_PRESCALE * CLK_PHASES)) / HEARTBEAT_HZ; // period 1/HEARTBEAT_HZ
86:                	T1CONbits.TCS = 0;      // use the crystal to drive the clock
87:                	_T1IP = INT_PRI_T1;     // set interrupt priority
88:                	_T1IF = 0;              // clear the interrupt
89:                	_T1IE = 1;              // enable the interrupt
90:                	T1CONbits.TON = 1;      // turn on timer 1
91:                
92:                #endif // (BOARD_TYPE != UDB4_BOARD && HEARTBEAT_HZ == 200)
93:                }
007BE6  FA8000     ULNK
007BE8  060000     RETURN
94:                
95:                static inline void init_cpu_timer(void)
96:                {
007BEA  FA0000     LNK #0x0
97:                	// Timer 5 is used to measure CPU usage
98:                	// Two techniques are supported, depending on whether USE_MCU_IDLE is selected
99:                	//   Timer 5 free runs until stopped during CPU idle
100:               	// else
101:               	// Timer 5 will be turned on in interrupt routines and turned off in main()
102:               	TMR5 = 0;               // initialize timer
007BEC  EB0000     CLR W0
007BEE  8808C0     MOV W0, TMR5
103:               	PR5 = 16*256;           // measure instructions in groups of 16*256 
007BF0  210000     MOV #0x1000, W0
007BF2  8808E0     MOV W0, PR5
104:               	_cpu_timer = 0;         // initialize the load counter
007BF4  EB0000     CLR W0
007BF6  88F340     MOV W0, _cpu_timer
105:               	T5CONbits.TCKPS = 0;    // no prescaler
007BF8  800901     MOV T5CON, W1
007BFA  2FFCF0     MOV #0xFFCF, W0
007BFC  608000     AND W1, W0, W0
007BFE  880900     MOV W0, T5CON
106:               	T5CONbits.TCS = 0;      // use the crystal to drive the clock
007C00  A92120     BCLR T5CON, #1
107:               	_T5IP = INT_PRI_T5;     // set interrupt priority
007C02  800591     MOV IPC7, W1
007C04  2FFF80     MOV #0xFFF8, W0
007C06  608000     AND W1, W0, W0
007C08  B30060     IOR #0x6, W0
007C0A  880590     MOV W0, IPC7
108:               	_T5IF = 0;              // clear the interrupt
007C0C  A98087     BCLR 0x87, #4
109:               	_T5IE = 1;              // enable the interrupt
007C0E  A88097     BSET 0x97, #4
110:               #if (USE_MCU_IDLE == 1)
111:               	T5CONbits.TSIDL = 1;    // stop the timer during CPU IDLE
007C10  A8A121     BSET 0x121, #5
112:               	T5CONbits.TON = 1;      // turn the timer 5 on until we idle
007C12  A8E121     BSET 0x121, #7
113:               #else
114:               	T5CONbits.TON = 0;      // turn off timer 5 until we enter an interrupt
115:               #endif // USE_MCU_IDLE
116:               }
007C14  FA8000     ULNK
007C16  060000     RETURN
117:               
118:               inline void cpu_load_calc(void)
119:               {
007C18  FA0000     LNK #0x0
120:               	T5CONbits.TON = 0;      // turn off timer 5
007C1A  A9E121     BCLR 0x121, #7
121:               	cpu_timer = _cpu_timer; // snapshot the load counter
007C1C  80F340     MOV _cpu_timer, W0
007C1E  88F330     MOV W0, cpu_timer
122:               	_cpu_timer = 0;         // reset the load counter
007C20  EB0000     CLR W0
007C22  88F340     MOV W0, _cpu_timer
123:               	T5CONbits.TON = 1;      // turn on timer 5
007C24  A8E121     BSET 0x121, #7
124:               }
007C26  FA8000     ULNK
007C28  060000     RETURN
125:               
126:               static inline void init_callback_1(void)
127:               {
007C2A  FA0000     LNK #0x0
128:               	// The Timer7 interrupt is used to trigger background tasks such as
129:               	// navigation processing after binary data is received from the GPS.
130:               	_T7IP = INT_PRI_T7;     // set interrupt priority
007C2C  8005E1     MOV IPC12, W1
007C2E  2FFF80     MOV #0xFFF8, W0
007C30  608000     AND W1, W0, W0
007C32  A01000     BSET W0, #1
007C34  8805E0     MOV W0, IPC12
131:               	_T7IF = 0;              // clear the interrupt
007C36  A9008A     BCLR IFS3, #0
132:               	_T7IE = 1;              // enable the interrupt
007C38  A8009A     BSET IEC3, #0
133:               }
007C3A  FA8000     ULNK
007C3C  060000     RETURN
134:               
135:               static inline void init_callback_2(void)
136:               {
007C3E  FA0000     LNK #0x0
137:               	// Enable the interrupt, but not the timer. This is used as a trigger from
138:               	// the high priority heartbeat ISR to start all the HEARTBEAT_HZ processing
139:               	// at a lower priority.
140:               	_T6IP = INT_PRI_T6;     // set interrupt priority
007C40  8005D1     MOV IPC11, W1
007C42  28FFF0     MOV #0x8FFF, W0
007C44  608080     AND W1, W0, W1
007C46  230000     MOV #0x3000, W0
007C48  708000     IOR W1, W0, W0
007C4A  8805D0     MOV W0, IPC11
141:               	_T6IF = 0;              // clear the PWM interrupt
007C4C  A9E089     BCLR 0x89, #7
142:               	_T6IE = 1;              // enable the PWM interrupt
007C4E  A8E099     BSET 0x99, #7
143:               }
007C50  FA8000     ULNK
007C52  060000     RETURN
144:               
145:               void udb_init_clock(void)   // initialize timers
146:               {
007C54  FA0000     LNK #0x0
147:               	init_heartbeat();
007C56  07FFBB     RCALL _init_heartbeat, .LFE0, .LFB1, .LSM3
148:               	init_cpu_timer();
007C58  07FFC8     RCALL _init_cpu_timer, .LFE1, .LFB2, .LSM10
149:               	init_callback_1();
007C5A  07FFE7     RCALL _init_callback_1, .LFE3, .LFB4, .LSM28
150:               	init_callback_2();
007C5C  07FFF0     RCALL _init_callback_2, .LFE4, .LFB5, .LSM33
151:               }
007C5E  FA8000     ULNK
007C60  060000     RETURN
152:               
153:               void udb_init_irq(void)
154:               {
007C62  FA0000     LNK #0x0
155:               	SRbits.IPL = 0; // turn on all interrupt priorities
007C64  800211     MOV SR, W1
007C66  2FF1F0     MOV #0xFF1F, W0
007C68  608000     AND W1, W0, W0
007C6A  880210     MOV W0, SR
156:               }
007C6C  FA8000     ULNK
007C6E  060000     RETURN
157:               
158:               // This interrupt is the Heartbeat of libUDB.
159:               void __attribute__((__interrupt__,__no_auto_psv__)) _T1Interrupt(void)
160:               {
007C70  F80036     PUSH RCOUNT
007C72  BE9F80     MOV.D W0, [W15++]
007C74  BE9F82     MOV.D W2, [W15++]
007C76  BE9F84     MOV.D W4, [W15++]
007C78  BE9F86     MOV.D W6, [W15++]
007C7A  FA0000     LNK #0x0
161:               	indicate_loading_inter;
162:               	set_ipl_on_output_pin;
163:               	interrupt_save_set_corcon;
007C7C  F80044     PUSH CORCON
007C7E  80F530     MOV 0x1EA6, W0
007C80  880220     MOV W0, CORCON
164:               	_T1IF = 0;              // clear the interrupt
007C82  A96084     BCLR IFS0, #3
165:               	heartbeat();
007C84  027F60     CALL heartbeat
007C86  000000     NOP
166:               	interrupt_restore_corcon;
007C88  F90044     POP CORCON
167:               	unset_ipl_on_output_pin;
168:               }
007C8A  FA8000     ULNK
007C8C  BE034F     MOV.D [--W15], W6
007C8E  BE024F     MOV.D [--W15], W4
007C90  BE014F     MOV.D [--W15], W2
007C92  BE004F     MOV.D [--W15], W0
007C94  F90036     POP RCOUNT
007C96  064000     RETFIE
169:               
170:               void __attribute__((__interrupt__,__no_auto_psv__)) _T5Interrupt(void)
171:               {
007C98  781F80     MOV W0, [W15++]
007C9A  FA0000     LNK #0x0
172:               	interrupt_save_set_corcon;
007C9C  F80044     PUSH CORCON
007C9E  80F530     MOV 0x1EA6, W0
007CA0  880220     MOV W0, CORCON
173:               	set_ipl_on_output_pin;
174:               	TMR5 = 0;               // reset the timer
007CA2  EB0000     CLR W0
007CA4  8808C0     MOV W0, TMR5
175:               	_cpu_timer++;           // increment the load counter
007CA6  80F340     MOV _cpu_timer, W0
007CA8  E80000     INC W0, W0
007CAA  88F340     MOV W0, _cpu_timer
176:               	_T5IF = 0;              // clear the interrupt
007CAC  A98087     BCLR 0x87, #4
177:               	interrupt_restore_corcon;
007CAE  F90044     POP CORCON
178:               	unset_ipl_on_output_pin;
179:               }
007CB0  FA8000     ULNK
007CB2  78004F     MOV [--W15], W0
007CB4  064000     RETFIE
180:               
181:               static background_callback callback_fptr_1 = NULL;
182:               
183:               // Executes whatever lower priority calculation needs to be done every heartbeat (default: 25 milliseconds)
184:               // This is a good place to eventually compute pulse widths for servos.
185:               void __attribute__((__interrupt__,__no_auto_psv__)) _T6Interrupt(void)
186:               {
007CB6  F80036     PUSH RCOUNT
007CB8  BE9F80     MOV.D W0, [W15++]
007CBA  BE9F82     MOV.D W2, [W15++]
007CBC  BE9F84     MOV.D W4, [W15++]
007CBE  BE9F86     MOV.D W6, [W15++]
007CC0  FA0000     LNK #0x0
187:               	indicate_loading_inter;
188:               	set_ipl_on_output_pin;
189:               	interrupt_save_set_corcon;
007CC2  F80044     PUSH CORCON
007CC4  80F530     MOV 0x1EA6, W0
007CC6  880220     MOV W0, CORCON
190:               	_T6IF = 0;              // clear the interrupt
007CC8  A9E089     BCLR 0x89, #7
191:               	if (callback_fptr_1) callback_fptr_1(); // was called pulse() or heartbeat_pulse()
007CCA  80F350     MOV callback_fptr_1, W0
007CCC  500FE0     SUB W0, #0x0, [W15]
007CCE  320002     BRA Z, .L12, .LSM64
007CD0  80F350     MOV callback_fptr_1, W0
007CD2  010000     CALL W0
192:               	interrupt_restore_corcon;
007CD4  F90044     POP CORCON
193:               	unset_ipl_on_output_pin;
194:               }
007CD6  FA8000     ULNK
007CD8  BE034F     MOV.D [--W15], W6
007CDA  BE024F     MOV.D [--W15], W4
007CDC  BE014F     MOV.D [--W15], W2
007CDE  BE004F     MOV.D [--W15], W0
007CE0  F90036     POP RCOUNT
007CE2  064000     RETFIE
195:               
196:               // Trigger the low priority background processing interrupt.
197:               void udb_background_trigger_pulse(background_callback callback)
198:               {
007CE4  FA0002     LNK #0x2
007CE6  780F00     MOV W0, [W14]
199:               	// Trigger the HEARTBEAT_HZ calculations, but at a lower priority
200:               	callback_fptr_1 = callback;
007CE8  78001E     MOV [W14], W0
007CEA  88F350     MOV W0, callback_fptr_1
201:               	_T6IF = 1;
007CEC  A8E089     BSET 0x89, #7
202:               }
007CEE  FA8000     ULNK
007CF0  060000     RETURN
203:               
204:               static background_callback callback_fptr_2 = NULL;
205:               
206:               // Process the TRIGGER interrupt.
207:               // This is used by libDCM to kick off gps-based calculations at a lower
208:               // priority after receiving each new set of GPS data.
209:               void __attribute__((__interrupt__,__no_auto_psv__)) _T7Interrupt(void)
210:               {
007CF2  F80036     PUSH RCOUNT
007CF4  BE9F80     MOV.D W0, [W15++]
007CF6  BE9F82     MOV.D W2, [W15++]
007CF8  BE9F84     MOV.D W4, [W15++]
007CFA  BE9F86     MOV.D W6, [W15++]
007CFC  FA0000     LNK #0x0
211:               	indicate_loading_inter;
212:               	set_ipl_on_output_pin;
213:               	interrupt_save_set_corcon;
007CFE  F80044     PUSH CORCON
007D00  80F530     MOV 0x1EA6, W0
007D02  880220     MOV W0, CORCON
214:               	_T7IF = 0;              // clear the interrupt
007D04  A9008A     BCLR IFS3, #0
215:               	//udb_background_callback_triggered(); // replaced by function pointer callback below
216:               	if (callback_fptr_2) callback_fptr_2();
007D06  80F360     MOV callback_fptr_2, W0
007D08  500FE0     SUB W0, #0x0, [W15]
007D0A  320002     BRA Z, .L15, .LSM74
007D0C  80F360     MOV callback_fptr_2, W0
007D0E  010000     CALL W0
217:               	interrupt_restore_corcon;
007D10  F90044     POP CORCON
218:               	unset_ipl_on_output_pin;
219:               }
007D12  FA8000     ULNK
007D14  BE034F     MOV.D [--W15], W6
007D16  BE024F     MOV.D [--W15], W4
007D18  BE014F     MOV.D [--W15], W2
007D1A  BE004F     MOV.D [--W15], W0
007D1C  F90036     POP RCOUNT
007D1E  064000     RETFIE
220:               
221:               // Trigger the low priority background processing interrupt.
222:               void udb_background_trigger(background_callback callback)
223:               {
007D20  FA0002     LNK #0x2
007D22  780F00     MOV W0, [W14]
224:               	callback_fptr_2 = callback;
007D24  78001E     MOV [W14], W0
007D26  88F360     MOV W0, callback_fptr_2
225:               	_T7IF = 1;              // trigger the interrupt
007D28  A8008A     BSET IFS3, #0
226:               }
007D2A  FA8000     ULNK
007D2C  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/analogs.c  -----------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "ADchannel.h"
24:                #include "analogs.h"
25:                
26:                #if (ANALOG_CURRENT_INPUT_CHANNEL != CHANNEL_UNUSED || USE_CASTLE_LINK_THROTTLE == 1)
27:                union longww battery_current;
28:                union longww battery_mAh_used;
29:                #endif
30:                
31:                #if (ANALOG_VOLTAGE_INPUT_CHANNEL != CHANNEL_UNUSED || USE_CASTLE_LINK_THROTTLE == 1)
32:                union longww battery_voltage;	// battery_voltage._.W1 is in tenths of Volts
33:                #endif
34:                
35:                #if (ANALOG_VOLTAGE2_INPUT_CHANNEL != CHANNEL_UNUSED)
36:                union longww battery_voltage2;	// battery_voltage2._.W1 is in tenths of Volts
37:                #endif
38:                
39:                #if (ANALOG_RSSI_INPUT_CHANNEL != CHANNEL_UNUSED || RSSI_INPUT_CHANNEL != CHANNEL_UNUSED)
40:                uint8_t rc_signal_strength;
41:                #define MIN_RSSI   ((int32_t)((RSSI_MIN_SIGNAL_VOLTAGE)/3.3 * 65536))
42:                #define RSSI_RANGE ((int32_t)((RSSI_MAX_SIGNAL_VOLTAGE-RSSI_MIN_SIGNAL_VOLTAGE)/3.3 * 100))
43:                #endif
44:                
45:                
46:                void init_analogs(void)
47:                {
008088  FA0000     LNK #0x0
48:                #if (ANALOG_CURRENT_INPUT_CHANNEL != CHANNEL_UNUSED || USE_CASTLE_LINK_THROTTLE == 1)
49:                	battery_current.WW = 0;
50:                	battery_mAh_used.WW = 0;
51:                #endif
52:                #if (ANALOG_VOLTAGE_INPUT_CHANNEL != CHANNEL_UNUSED || USE_CASTLE_LINK_THROTTLE == 1)
53:                	battery_voltage.WW = 0;
54:                #endif
55:                #if (ANALOG_VOLTAGE2_INPUT_CHANNEL != CHANNEL_UNUSED)
56:                	battery_voltage2.WW = 0;
57:                #endif    
58:                #if (ANALOG_RSSI_INPUT_CHANNEL != CHANNEL_UNUSED || RSSI_INPUT_CHANNEL != CHANNEL_UNUSED)
59:                	rc_signal_strength = 0;
60:                #endif
61:                }
00808A  FA8000     ULNK
00808C  060000     RETURN
62:                
63:                void calculate_analog_sensor_values(void)
64:                {
00808E  FA0000     LNK #0x0
65:                #if (ANALOG_CURRENT_INPUT_CHANNEL != CHANNEL_UNUSED)
66:                	// Shift up from [-2^15 , 2^15-1] to [0 , 2^16-1]
67:                	// Convert to current in tenths of Amps
68:                	battery_current.WW = (udb_analogInputs[ANALOG_CURRENT_INPUT_CHANNEL-1].value + (int32_t)32768) * (MAX_CURRENT) + (((int32_t)(CURRENT_SENSOR_OFFSET)) << 16);
69:                #endif
70:                    
71:                #if (ANALOG_CURRENT_INPUT_CHANNEL != CHANNEL_UNUSED || USE_CASTLE_LINK_THROTTLE == 1)
72:                	// mAh = mA / 144000 (increment per 40Hz tick is /40*60*60)
73:                	// 90000/144000 == 900/1440
74:                	battery_mAh_used.WW += (battery_current.WW / 1440);
75:                #endif
76:                
77:                #if (ANALOG_VOLTAGE_INPUT_CHANNEL != CHANNEL_UNUSED)
78:                	// Shift up from [-2^15 , 2^15-1] to [0 , 2^16-1]
79:                	// Convert to voltage in tenths of Volts
80:                	battery_voltage.WW = (udb_analogInputs[ANALOG_VOLTAGE_INPUT_CHANNEL-1].value + (int32_t)32768) * (MAX_VOLTAGE) + (((int32_t)(VOLTAGE_SENSOR_OFFSET)) << 16);
81:                #endif
82:                
83:                #if (ANALOG_VOLTAGE2_INPUT_CHANNEL != CHANNEL_UNUSED)
84:                    // Shift up from [-2^15 , 2^15-1] to [0 , 2^16-1]
85:                    // Convert to voltage in tenths of Volts
86:                    battery_voltage2.WW = (udb_analogInputs[ANALOG_VOLTAGE2_INPUT_CHANNEL-1].value + (int32_t)32768) * (MAX_VOLTAGE2) + (((int32_t)(VOLTAGE2_SENSOR_OFFSET)) << 16);
87:                #endif
88:                        
89:                #if (ANALOG_RSSI_INPUT_CHANNEL != CHANNEL_UNUSED)
90:                	union longww rssi_accum;
91:                	rssi_accum.WW = (((udb_analogInputs[ANALOG_RSSI_INPUT_CHANNEL-1].value + 32768) - (MIN_RSSI)) * (10000 / (RSSI_RANGE)));
92:                	if (rssi_accum._.W1 < 0)
93:                		rc_signal_strength = 0;
94:                	else if (rssi_accum._.W1 > 100)
95:                		rc_signal_strength = 100;
96:                	else
97:                		rc_signal_strength = (uint8_t)rssi_accum._.W1;
98:                #endif
99:                	
100:               #if (RSSI_INPUT_CHANNEL != CHANNEL_UNUSED)
101:               	int16_t tempRSSI = (udb_pwIn[RSSI_INPUT_CHANNEL]-2000) / 20;
102:               	if (tempRSSI < 0) tempRSSI = 0;
103:               	if (tempRSSI > 100) tempRSSI = 100;
104:               	rc_signal_strength = tempRSSI;
105:               #endif
106:               }
008090  FA8000     ULNK
008092  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libUDB/analog2digital_udb5.c  -----------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libUDB.h"
23:                #include "oscillator.h"
24:                #include "interrupt.h"
25:                #include "heartbeat.h"
26:                #include "ADchannel.h"
27:                
28:                #if (BOARD_TYPE == UDB5_BOARD)
29:                
30:                #if (NUM_ANALOG_INPUTS >= 1)
31:                struct ADchannel udb_analogInputs[NUM_ANALOG_INPUTS]; // 0-indexed, unlike servo pwIn/Out/Trim arrays
32:                #endif
33:                struct ADchannel udb_vcc;
34:                struct ADchannel udb_5v;
35:                //struct ADchannel udb_vref;  // reference voltage (deprecated, here for MAVLink compatibility)
36:                
37:                // Number of locations for ADC buffer = 6 (AN0,15,16,17,18) x 1 = 6 words
38:                // Align the buffer. This is needed for peripheral indirect mode
39:                #define NUM_AD_CHAN 6
40:                int16_t BufferA[NUM_AD_CHAN] __attribute__((space(dma),aligned(32)));
41:                int16_t BufferB[NUM_AD_CHAN] __attribute__((space(dma),aligned(32)));
42:                int16_t sample_count;
43:                uint8_t DmaBuffer = 0;
44:                
45:                #if (RECORD_FREE_STACK_SPACE == 1)
46:                uint16_t maxstack = 0;
47:                #endif
48:                
49:                #if 0   // these are the original/legacy values, switch this off to test Mark's new timing constants
50:                // May-29-2017, WJP: Marks timing constants work well and they reduce CPU loading, so lets use them.
51:                #define ALMOST_ENOUGH_SAMPLES   216 // there are 222 or 223 samples in a sum
52:                #define ADCLK_DIV_N_MINUS_1     11  // ADC Conversion Clock Tad=Tcy*(ADCS+1)= (1/40M)*12 = 0.3us (3333.3Khz)
53:                                                    // ADC Conversion Time for 12-bit Tc=14*Tad = 4.2us
54:                #define ADSAMP_TIME_N           1   // No waiting between samples
55:                #else
56:                
57:                // dsPIC33FJXXXGPX06A/X08A/X10A
58:                // minimum allowed 12-bit ADC clock period is 118ns or 8.47MHz
59:                // minimum allowed 10-bit ADC clock period is 76ns, or 13.16MHz
60:                // 12 bit mode conversion time is 14 TAD cycles
61:                // total sample/conversion time is (14+SAMC) * TAD
62:                // for 400nsec TAD, total is 10usec for 100KHz conversion rate with SAMC = 11
63:                // *** observed 72usec interval between interrupts on scope => interrupt every sample
64:                
65:                // desired adc clock is 625KHz and conversion rate is 25KHz
66:                #if (MIPS == 16)
67:                // ADC_CLK 640KHz
68:                #define ADCLK_DIV_N_MINUS_1 24
69:                // ADC_RATE 25.6KHz
70:                #define ADSAMP_TIME_N 11
71:                
72:                #elif (MIPS == 32)
73:                // ADC_CLK 640KHz
74:                #define ADCLK_DIV_N_MINUS_1 49
75:                // ADC_RATE 25.6KHz
76:                #define ADSAMP_TIME_N 11
77:                
78:                #elif (MIPS == 40)
79:                // ADC_CLK 625KHz
80:                #define ADCLK_DIV_N_MINUS_1 63
81:                // ADC_RATE 25KHz
82:                #define ADSAMP_TIME_N 11
83:                
84:                #elif (MIPS == 64)
85:                // ADC_CLK 1MHz
86:                #define ADCLK_DIV_N_MINUS_1 63
87:                // ADC_RATE 25KHz
88:                #define ADSAMP_TIME_N 26
89:                
90:                #endif
91:                
92:                // TAD is 1/ADC_CLK
93:                #define ADC_CLK (FCY / (ADCLK_DIV_N_MINUS_1 + 1))
94:                
95:                // At FCY=40MHz, ADC_CLK=625KHz
96:                // At FCY=40MHz, ADC_RATE = 25 KHz
97:                // At 40MHz: 23.148KHz ADC rate and 8 channels seq. sampled, the per channel rate is
98:                // about 2.894 KHz and lp2 3dB point is at 75Hz.
99:                #define ADC_RATE (ADC_CLK / (ADSAMP_TIME_N + 14))
100:               
101:               #define ALMOST_ENOUGH_SAMPLES ((ADC_RATE / (NUM_AD_CHAN * HEARTBEAT_HZ)) - 2)
102:               
103:               #endif // 0/1
104:               
105:               void udb_init_ADC(void)
106:               {
0071D2  FA0000     LNK #0x0
107:               	sample_count = 0;
0071D4  EB0000     CLR W0
0071D6  88E870     MOV W0, sample_count
108:               
109:               	AD1CON1bits.FORM  = 3;      // Data Output Format: Signed Fraction (Q15 format)
0071D8  801901     MOV AD1CON1, W1
0071DA  203000     MOV #0x300, W0
0071DC  708000     IOR W1, W0, W0
0071DE  881900     MOV W0, AD1CON1
110:               	AD1CON1bits.SSRC  = 7;      // Sample Clock Source: Auto-conversion
0071E0  801901     MOV AD1CON1, W1
0071E2  200E00     MOV #0xE0, W0
0071E4  708000     IOR W1, W0, W0
0071E6  881900     MOV W0, AD1CON1
111:               	AD1CON1bits.ASAM  = 1;      // ADC Sample Control: Sampling begins immediately after conversion
0071E8  A84320     BSET AD1CON1, #2
112:               	AD1CON1bits.AD12B = 1;      // 12-bit ADC operation
0071EA  A84321     BSET 0x321, #2
113:               
114:               	AD1CON2bits.CSCNA = 1;      // Scan Input Selections for CH0+ during Sample A bit
0071EC  A84323     BSET 0x323, #2
115:               	AD1CON2bits.CHPS  = 0;      // Converts CH0
0071EE  801911     MOV AD1CON2, W1
0071F0  2FCFF0     MOV #0xFCFF, W0
0071F2  608000     AND W1, W0, W0
0071F4  881910     MOV W0, AD1CON2
116:               
117:               	AD1CON3bits.ADRC = 0;       // ADC Clock is derived from System Clock
0071F6  A9E325     BCLR 0x325, #7
118:               	AD1CON3bits.ADCS = ADCLK_DIV_N_MINUS_1;
0071F8  B3C310     MOV.B #0x31, W0
0071FA  B7E324     MOV.B WREG, AD1CON3
119:               	AD1CON3bits.SAMC = ADSAMP_TIME_N;
0071FC  801921     MOV AD1CON3, W1
0071FE  2E0FF0     MOV #0xE0FF, W0
007200  608080     AND W1, W0, W1
007202  20B000     MOV #0xB00, W0
007204  708000     IOR W1, W0, W0
007206  881920     MOV W0, AD1CON3
120:               
121:               	AD1CON2bits.VCFG = 0;       // use supply as reference voltage
007208  801911     MOV AD1CON2, W1
00720A  21FFF0     MOV #0x1FFF, W0
00720C  608000     AND W1, W0, W0
00720E  881910     MOV W0, AD1CON2
122:               
123:               	AD1CON1bits.ADDMABM = 1;    // DMA buffers are built in sequential mode
007210  A88321     BSET 0x321, #4
124:               	AD1CON2bits.SMPI    = (NUM_AD_CHAN-1);
007212  801911     MOV AD1CON2, W1
007214  2FFC30     MOV #0xFFC3, W0
007216  608000     AND W1, W0, W0
007218  B30140     IOR #0x14, W0
00721A  881910     MOV W0, AD1CON2
125:               	AD1CON4bits.DMABL   = 0;    // Each buffer contains 1 word
00721C  801991     MOV AD1CON4, W1
00721E  2FFF80     MOV #0xFFF8, W0
007220  608000     AND W1, W0, W0
007222  881990     MOV W0, AD1CON4
126:               
127:               	AD1CSSL = 0x0000;
007224  EB0000     CLR W0
007226  881980     MOV W0, AD1CSSL
128:               	AD1CSSH = 0x0000;
007228  EB0000     CLR W0
00722A  881970     MOV W0, AD1CSSH
129:               
130:               	// set all ADC 1 and 2 inputs to digital mode
131:               	AD1PCFGL= 0xFFFF;
00722C  EB8000     SETM W0
00722E  881960     MOV W0, AD1PCFGL
132:               	AD1PCFGH= 0xFFFF;
007230  EB8000     SETM W0
007232  881950     MOV W0, AD1PCFGH
133:               	AD2PCFGL= 0xFFFF;
007234  EB8000     SETM W0
007236  881B60     MOV W0, AD2PCFGL
134:               
135:               	// include voltage monitor inputs
136:               	_CSS0 = 1;                  // Enable AN0 for channel scan
007238  A80330     BSET AD1CSSL, #0
137:               	_CSS1 = 1;                  // Enable AN1 for channel scan
00723A  A82330     BSET AD1CSSL, #1
138:               	_PCFG0 = 0;                 // AN0 as Analog Input
00723C  A9032C     BCLR AD1PCFGL, #0
139:               	_PCFG1 = 0;                 // AN1 as Analog Input
00723E  A9232C     BCLR AD1PCFGL, #1
140:               
141:               	// include the extra analog input pins
142:               	_CSS15 = 1;                 // Enable AN15 for channel scan
007240  A8E331     BSET 0x331, #7
143:               	_CSS16 = 1;                 // Enable AN16 for channel scan
007242  A8032E     BSET AD1CSSH, #0
144:               	_CSS17 = 1;                 // Enable AN17 for channel scan
007244  A8232E     BSET AD1CSSH, #1
145:               	_CSS18 = 1;                 // Enable AN18 for channel scan
007246  A8432E     BSET AD1CSSH, #2
146:               
147:               	_PCFG15 = 0;                // AN15 as Analog Input
007248  A9E32D     BCLR 0x32D, #7
148:               	_PCFG16 = 0;                // AN16 as Analog Input
00724A  A9032A     BCLR AD1PCFGH, #0
149:               	_PCFG17 = 0;                // AN17 as Analog Input
00724C  A9232A     BCLR AD1PCFGH, #1
150:               	_PCFG18 = 0;                // AN18 as Analog Input
00724E  A9432A     BCLR AD1PCFGH, #2
151:               
152:               	_AD1IF = 0;                 // Clear the A/D interrupt flag bit
007250  A9A085     BCLR 0x85, #5
153:               	_AD1IP = INT_PRI_AD1;       // Set the interrupt priority
007252  800551     MOV IPC3, W1
007254  2FF8F0     MOV #0xFF8F, W0
007256  608080     AND W1, W0, W1
007258  200500     MOV #0x50, W0
00725A  708000     IOR W1, W0, W0
00725C  880550     MOV W0, IPC3
154:               	_AD1IE = 0;                 // Do Not Enable A/D interrupt
00725E  A9A095     BCLR 0x95, #5
155:               	AD1CON1bits.ADON = 1;       // Turn on the A/D converter
007260  A8E321     BSET 0x321, #7
156:               
157:               	// DMA Setup
158:               	DMA0CONbits.AMODE = 2;      // Configure DMA for Peripheral indirect mode
007262  801C01     MOV DMA0CON, W1
007264  2FFCF0     MOV #0xFFCF, W0
007266  608080     AND W1, W0, W1
007268  200200     MOV #0x20, W0
00726A  708000     IOR W1, W0, W0
00726C  881C00     MOV W0, DMA0CON
159:               	DMA0CONbits.MODE  = 2;      // Configure DMA for Continuous Ping-Pong mode
00726E  801C01     MOV DMA0CON, W1
007270  2FFFC0     MOV #0xFFFC, W0
007272  608000     AND W1, W0, W0
007274  A01000     BSET W0, #1
007276  881C00     MOV W0, DMA0CON
160:               	DMA0PAD = (int16_t)&ADC1BUF0;
007278  203000     MOV #0x300, W0
00727A  881C40     MOV W0, DMA0PAD
161:               	DMA0CNT = NUM_AD_CHAN-1;
00727C  200050     MOV #0x5, W0
00727E  881C50     MOV W0, DMA0CNT
162:               	DMA0REQ = 13;               // Select ADC1 as DMA Request source
007280  2000D0     MOV #0xD, W0
007282  881C10     MOV W0, DMA0REQ
163:               
164:               	DMA0STA = __builtin_dmaoffset(BufferA);
007284  207E00     MOV #0x7E0, W0
007286  881C20     MOV W0, DMA0STA
165:               	DMA0STB = __builtin_dmaoffset(BufferB);
007288  207C00     MOV #0x7C0, W0
00728A  881C30     MOV W0, DMA0STB
166:               
167:               	_DMA0IP = INT_PRI_DMA0;     // Set the DMA ISR priority
00728C  800531     MOV IPC1, W1
00728E  2FFF80     MOV #0xFFF8, W0
007290  608000     AND W1, W0, W0
007292  B30050     IOR #0x5, W0
007294  880530     MOV W0, IPC1
168:               	_DMA0IF = 0;                // Clear the DMA interrupt flag bit
007296  A98084     BCLR IFS0, #4
169:               	_DMA0IE = 1;                // Set the DMA interrupt enable bit
007298  A88094     BSET IEC0, #4
170:               
171:               	DMA0CONbits.CHEN = 1;       // Enable DMA
00729A  A8E381     BSET 0x381, #7
172:               }
00729C  FA8000     ULNK
00729E  060000     RETURN
173:               
174:               void __attribute__((__interrupt__,__no_auto_psv__)) _DMA0Interrupt(void)
175:               {
0072A0  F80036     PUSH RCOUNT
0072A2  BE9F80     MOV.D W0, [W15++]
0072A4  BE9F82     MOV.D W2, [W15++]
0072A6  FA0002     LNK #0x2
176:               	indicate_loading_inter;
177:               	set_ipl_on_output_pin;
178:               	interrupt_save_set_corcon;
0072A8  F80044     PUSH CORCON
0072AA  80F530     MOV 0x1EA6, W0
0072AC  880220     MOV W0, CORCON
179:               
180:               #if (RECORD_FREE_STACK_SPACE == 1)
181:               	uint16_t stack = SP_current();
182:               	if (stack > maxstack)
183:               	{
184:               		maxstack = stack;
185:               	}
186:               #endif
187:               
188:               #if (HILSIM != 1)
189:               	int16_t *CurBuffer = (DmaBuffer == 0) ? BufferA : BufferB;
0072AE  21EA00     MOV #0x1EA0, W0
0072B0  784010     MOV.B [W0], W0
0072B2  504FE0     SUB.B W0, #0x0, [W15]
0072B4  3A0002     BRA NZ, .L3
0072B6  27FE00     MOV #0x7FE0, W0
0072B8  370001     BRA .L4
0072BA  27FC00     MOV #0x7FC0, W0
0072BC  780F00     MOV W0, [W14]
190:               	udb_vcc.input = CurBuffer[A_VCC_BUFF-1];
0072BE  78001E     MOV [W14], W0
0072C0  780010     MOV [W0], W0
0072C2  88E7D0     MOV W0, udb_vcc
191:               	udb_5v.input  = CurBuffer[A_5V_BUFF-1];
0072C4  E8801E     INC2 [W14], W0
0072C6  780010     MOV [W0], W0
0072C8  88E820     MOV W0, udb_5v
192:               #if (NUM_ANALOG_INPUTS >= 1)
193:               	udb_analogInputs[0].input = CurBuffer[analogInput1BUFF-1];
0072CA  78009E     MOV [W14], W1
0072CC  408064     ADD W1, #0x4, W0
0072CE  780010     MOV [W0], W0
0072D0  88E690     MOV W0, udb_analogInputs
194:               #endif
195:               #if (NUM_ANALOG_INPUTS >= 2)
196:               	udb_analogInputs[1].input = CurBuffer[analogInput2BUFF-1];
0072D2  78009E     MOV [W14], W1
0072D4  408066     ADD W1, #0x6, W0
0072D6  780010     MOV [W0], W0
0072D8  88E6E0     MOV W0, 0x1CDC
197:               #endif
198:               #if (NUM_ANALOG_INPUTS >= 3)
199:               	udb_analogInputs[2].input = CurBuffer[analogInput3BUFF-1];
0072DA  78009E     MOV [W14], W1
0072DC  408068     ADD W1, #0x8, W0
0072DE  780010     MOV [W0], W0
0072E0  88E730     MOV W0, 0x1CE6
200:               #endif
201:               #if (NUM_ANALOG_INPUTS >= 4)
202:               	udb_analogInputs[3].input = CurBuffer[analogInput4BUFF-1];
0072E2  78009E     MOV [W14], W1
0072E4  40806A     ADD W1, #0xA, W0
0072E6  780010     MOV [W0], W0
0072E8  88E780     MOV W0, 0x1CF0
203:               #endif
204:               #endif // HILSIM
205:               
206:               	DmaBuffer ^= 1;                 // Switch buffers
0072EA  21EA00     MOV #0x1EA0, W0
0072EC  784010     MOV.B [W0], W0
0072EE  A20400     BTG.B W0, #0
0072F0  21EA01     MOV #0x1EA0, W1
0072F2  784880     MOV.B W0, [W1]
207:               	IFS0bits.DMA0IF = 0;            // Clear the DMA0 Interrupt Flag
0072F4  A98084     BCLR IFS0, #4
208:               
209:               	if (udb_flags._.a2d_read == 1)  // prepare for the next reading
0072F6  80F521     MOV udb_flags, W1
0072F8  210000     MOV #0x1000, W0
0072FA  608000     AND W1, W0, W0
0072FC  500FE0     SUB W0, #0x0, [W15]
0072FE  320018     BRA Z, .L5, .LSM68
210:               	{
211:               		udb_flags._.a2d_read = 0;
007300  80F521     MOV udb_flags, W1
007302  2EFFF0     MOV #0xEFFF, W0
007304  608000     AND W1, W0, W0
007306  88F520     MOV W0, udb_flags
212:               		// TODO: determine and make a note as to why we are not zeroing these accumulators
213:               //		udb_xrate.sum = udb_yrate.sum = udb_zrate.sum = 0;
214:               //		udb_xaccel.sum = udb_yaccel.sum = udb_zaccel.sum = 0;
215:               		udb_vcc.sum = 0;
007308  B80060     MUL.UU W0, #0, W0
00730A  88E800     MOV W0, 0x1D00
00730C  88E811     MOV W1, 0x1D02
216:               		udb_5v.sum = 0;
00730E  B80060     MUL.UU W0, #0, W0
007310  88E850     MOV W0, 0x1D0A
007312  88E861     MOV W1, 0x1D0C
217:               #if (NUM_ANALOG_INPUTS >= 1)
218:               		udb_analogInputs[0].sum = 0;
007314  B80060     MUL.UU W0, #0, W0
007316  88E6C0     MOV W0, 0x1CD8
007318  88E6D1     MOV W1, 0x1CDA
219:               #endif
220:               #if (NUM_ANALOG_INPUTS >= 2)
221:               		udb_analogInputs[1].sum = 0;
00731A  B80060     MUL.UU W0, #0, W0
00731C  88E710     MOV W0, 0x1CE2
00731E  88E721     MOV W1, 0x1CE4
222:               #endif
223:               #if (NUM_ANALOG_INPUTS >= 3)
224:               		udb_analogInputs[2].sum = 0;
007320  B80060     MUL.UU W0, #0, W0
007322  88E760     MOV W0, 0x1CEC
007324  88E771     MOV W1, 0x1CEE
225:               #endif
226:               #if (NUM_ANALOG_INPUTS >= 4)
227:               		udb_analogInputs[3].sum = 0;
007326  B80060     MUL.UU W0, #0, W0
007328  88E7B0     MOV W0, 0x1CF6
00732A  88E7C1     MOV W1, 0x1CF8
228:               #endif
229:               		sample_count = 0;
00732C  EB0000     CLR W0
00732E  88E870     MOV W0, sample_count
230:               	}
231:               
232:               	// perform the integration:
233:               	udb_vcc.sum += udb_vcc.input;
007330  80E802     MOV 0x1D00, W2
007332  80E813     MOV 0x1D02, W3
007334  80E7D0     MOV udb_vcc, W0
007336  DE80CF     ASR W0, #15, W1
007338  400002     ADD W0, W2, W0
00733A  488083     ADDC W1, W3, W1
00733C  88E800     MOV W0, 0x1D00
00733E  88E811     MOV W1, 0x1D02
234:               	udb_5v.sum  += udb_5v.input;
007340  80E852     MOV 0x1D0A, W2
007342  80E863     MOV 0x1D0C, W3
007344  80E820     MOV udb_5v, W0
007346  DE80CF     ASR W0, #15, W1
007348  400002     ADD W0, W2, W0
00734A  488083     ADDC W1, W3, W1
00734C  88E850     MOV W0, 0x1D0A
00734E  88E861     MOV W1, 0x1D0C
235:               #if (NUM_ANALOG_INPUTS >= 1)
236:               	udb_analogInputs[0].sum += udb_analogInputs[0].input;
007350  80E6C2     MOV 0x1CD8, W2
007352  80E6D3     MOV 0x1CDA, W3
007354  80E690     MOV udb_analogInputs, W0
007356  DE80CF     ASR W0, #15, W1
007358  400002     ADD W0, W2, W0
00735A  488083     ADDC W1, W3, W1
00735C  88E6C0     MOV W0, 0x1CD8
00735E  88E6D1     MOV W1, 0x1CDA
237:               #endif
238:               #if (NUM_ANALOG_INPUTS >= 2)
239:               	udb_analogInputs[1].sum += udb_analogInputs[1].input;
007360  80E712     MOV 0x1CE2, W2
007362  80E723     MOV 0x1CE4, W3
007364  80E6E0     MOV 0x1CDC, W0
007366  DE80CF     ASR W0, #15, W1
007368  400002     ADD W0, W2, W0
00736A  488083     ADDC W1, W3, W1
00736C  88E710     MOV W0, 0x1CE2
00736E  88E721     MOV W1, 0x1CE4
240:               #endif
241:               #if (NUM_ANALOG_INPUTS >= 3)
242:               	udb_analogInputs[2].sum += udb_analogInputs[2].input;
007370  80E762     MOV 0x1CEC, W2
007372  80E773     MOV 0x1CEE, W3
007374  80E730     MOV 0x1CE6, W0
007376  DE80CF     ASR W0, #15, W1
007378  400002     ADD W0, W2, W0
00737A  488083     ADDC W1, W3, W1
00737C  88E760     MOV W0, 0x1CEC
00737E  88E771     MOV W1, 0x1CEE
243:               #endif
244:               #if (NUM_ANALOG_INPUTS >= 4)
245:               	udb_analogInputs[3].sum += udb_analogInputs[3].input;
007380  80E7B2     MOV 0x1CF6, W2
007382  80E7C3     MOV 0x1CF8, W3
007384  80E780     MOV 0x1CF0, W0
007386  DE80CF     ASR W0, #15, W1
007388  400002     ADD W0, W2, W0
00738A  488083     ADDC W1, W3, W1
00738C  88E7B0     MOV W0, 0x1CF6
00738E  88E7C1     MOV W1, 0x1CF8
246:               #endif
247:               	sample_count++;
007390  80E870     MOV sample_count, W0
007392  E80000     INC W0, W0
007394  88E870     MOV W0, sample_count
248:               
249:               	// When there is a chance that data will be read soon,
250:               	// have the new average values ready.
251:               	if (sample_count > ALMOST_ENOUGH_SAMPLES)
007396  80E870     MOV sample_count, W0
007398  500FF3     SUB W0, #0x13, [W15]
00739A  340030     BRA LE, .L6, .LSM82
252:               	{
253:               		udb_vcc.value = __builtin_divsd(udb_vcc.sum, sample_count);
00739C  80E872     MOV sample_count, W2
00739E  80E800     MOV 0x1D00, W0
0073A0  80E811     MOV 0x1D02, W1
0073A2  781F81     MOV W1, [W15++]
0073A4  090011     REPEAT #0x11
0073A6  D80842     DIV.SD W0, W2
0073A8  7800CF     MOV [--W15], W1
0073AA  88E7E0     MOV W0, 0x1CFC
254:               		udb_5v.value  = __builtin_divsd(udb_5v.sum,  sample_count);
0073AC  80E872     MOV sample_count, W2
0073AE  80E850     MOV 0x1D0A, W0
0073B0  80E861     MOV 0x1D0C, W1
0073B2  781F81     MOV W1, [W15++]
0073B4  090011     REPEAT #0x11
0073B6  D80842     DIV.SD W0, W2
0073B8  7800CF     MOV [--W15], W1
0073BA  88E830     MOV W0, 0x1D06
255:               #if (NUM_ANALOG_INPUTS >= 1)
256:               		udb_analogInputs[0].value = __builtin_divsd(udb_analogInputs[0].sum, sample_count);
0073BC  80E872     MOV sample_count, W2
0073BE  80E6C0     MOV 0x1CD8, W0
0073C0  80E6D1     MOV 0x1CDA, W1
0073C2  781F81     MOV W1, [W15++]
0073C4  090011     REPEAT #0x11
0073C6  D80842     DIV.SD W0, W2
0073C8  7800CF     MOV [--W15], W1
0073CA  88E6A0     MOV W0, 0x1CD4
257:               #endif
258:               #if (NUM_ANALOG_INPUTS >= 2)
259:               		udb_analogInputs[1].value = __builtin_divsd(udb_analogInputs[1].sum, sample_count);
0073CC  80E872     MOV sample_count, W2
0073CE  80E710     MOV 0x1CE2, W0
0073D0  80E721     MOV 0x1CE4, W1
0073D2  781F81     MOV W1, [W15++]
0073D4  090011     REPEAT #0x11
0073D6  D80842     DIV.SD W0, W2
0073D8  7800CF     MOV [--W15], W1
0073DA  88E6F0     MOV W0, 0x1CDE
260:               #endif
261:               #if (NUM_ANALOG_INPUTS >= 3)
262:               		udb_analogInputs[2].value = __builtin_divsd(udb_analogInputs[2].sum, sample_count);
0073DC  80E872     MOV sample_count, W2
0073DE  80E760     MOV 0x1CEC, W0
0073E0  80E771     MOV 0x1CEE, W1
0073E2  781F81     MOV W1, [W15++]
0073E4  090011     REPEAT #0x11
0073E6  D80842     DIV.SD W0, W2
0073E8  7800CF     MOV [--W15], W1
0073EA  88E740     MOV W0, 0x1CE8
263:               #endif
264:               #if (NUM_ANALOG_INPUTS >= 4)
265:               		udb_analogInputs[3].value = __builtin_divsd(udb_analogInputs[3].sum, sample_count);
0073EC  80E872     MOV sample_count, W2
0073EE  80E7B0     MOV 0x1CF6, W0
0073F0  80E7C1     MOV 0x1CF8, W1
0073F2  781F81     MOV W1, [W15++]
0073F4  090011     REPEAT #0x11
0073F6  D80842     DIV.SD W0, W2
0073F8  7800CF     MOV [--W15], W1
0073FA  88E790     MOV W0, 0x1CF2
266:               #endif
267:               	}
268:               
269:               	interrupt_restore_corcon;
0073FC  F90044     POP CORCON
270:               	unset_ipl_on_output_pin;
271:               }
0073FE  FA8000     ULNK
007400  BE014F     MOV.D [--W15], W2
007402  BE004F     MOV.D [--W15], W0
007404  F90036     POP RCOUNT
007406  064000     RETFIE
272:               
273:               #endif // BOARD_TYPE
---  C:/Users/bill/Desktop/git_repos/git_luge/libDCM/rmat.c  --------------------------------------------
1:                 
2:                 #include "libDCM_internal.h"
3:                 #include "mathlibNAV.h"
4:                 #include "deadReckoning.h"
5:                 #include "gpsParseCommon.h"
6:                 #include "../libUDB/magnetometer.h"
7:                 #include "../libUDB/heartbeat.h"
8:                 #include "../libUDB/ADchannel.h"
9:                 #include <math.h>
10:                
11:                // These are the routines for maintaining a direction cosine matrix
12:                // that can be used to transform vectors between the earth and plane
13:                // coordinate systems. The 9 direction cosines in the matrix completely
14:                // define the orientation of the plane with respect to the earth.
15:                // The inverse of the matrix is equal to its transpose. This defines
16:                // the so-called orthogonality conditions, which impose 6 constraints on
17:                // the 9 elements of the matrix.
18:                
19:                // All numbers are stored in 2.14 format.
20:                // Vector and matrix libraries work in 1.15 format.
21:                // This combination allows values of matrix elements between -2 and +2.
22:                // Multiplication produces results scaled by 1/2.
23:                
24:                
25:                #define RMAX15 24576 //0b0110000000000000   // 1.5 in 2.14 format
26:                
27:                #define GGAINX CALIBRATIONX*SCALEGYRO*6*(RMAX*(1.0/HEARTBEAT_HZ)) // integration multiplier for gyros
28:                #define GGAINY CALIBRATIONY*SCALEGYRO*6*(RMAX*(1.0/HEARTBEAT_HZ)) // integration multiplier for gyros
29:                #define GGAINZ CALIBRATIONZ*SCALEGYRO*6*(RMAX*(1.0/HEARTBEAT_HZ)) // integration multiplier for gyros
30:                fractional ggain[] =  { 2*GGAINX, 2*GGAINY, 2*GGAINZ };
31:                
32:                #if (GYRO_RANGE != 1000)
33:                #error "only GYRO_RANGE 1000 is presently supported"
34:                #endif // GYRO_RANGE
35:                
36:                uint16_t spin_rate = 0;
37:                
38:                // the gains are constant because the gravity vector is normalized
39:                //#define KPROLLPITCH ( 2*2048 )
40:                //#define KIROLLPITCH ( (uint32_t) 4*2560 / (uint32_t) HEARTBEAT_HZ)
41:                
42:                #define KPROLLPITCH ( 8*2048 )
43:                //#define KPROLLPITCH ( 2048 )
44:                #define KIROLLPITCH ( (uint32_t) 64*2560 / (uint32_t) HEARTBEAT_HZ)
45:                
46:                //#define KPYAW ( 2*2048 )
47:                #define KPYAW ( 0 )
48:                #define KIYAW ((uint32_t) 4*2560/(uint32_t)HEARTBEAT_HZ)
49:                
50:                #define GYROSAT 15000
51:                // threshold at which gyros may be saturated
52:                
53:                // rmat is the matrix of direction cosines relating
54:                // the body and earth coordinate systems.
55:                // The columns of rmat are the axis vectors of the plane,
56:                // as measured in the earth reference frame.
57:                // The rows of rmat are the unit vectors defining the body frame in the earth frame.
58:                // rmat therefore describes the body frame B relative to the Earth frame E
59:                // and in Craig's notation is represented as (B->E)R: LateX format: presupsub{E}{B}R
60:                // To transform a point from body frame to Earth frame, multiply from the left
61:                // with rmat.
62:                
63:                // rmat is initialized to the identity matrix in 2.14 fractional format
64:                
65:                #ifdef INITIALIZE_VERTICAL  // for VTOL vertical initialization
66:                fractional rmat[] = { RMAX, 0, 0, 0, 0, RMAX, 0, -RMAX, 0 };
67:                static fractional rmatDelayCompensated[] =  { RMAX, 0, 0, 0, 0, RMAX, 0, -RMAX, 0 };
68:                
69:                #else // the usual case, horizontal initialization
70:                fractional rmat[] = { RMAX, 0, 0, 0, RMAX, 0, 0, 0, RMAX };
71:                #if (MAG_YAW_DRIFT == 1)
72:                static fractional rmatDelayCompensated[] = { RMAX, 0, 0, 0, RMAX, 0, 0, 0, RMAX };
73:                #endif
74:                #endif
75:                
76:                // rup is the rotational update matrix.
77:                // At each time step, the new rmat is equal to the old one, multiplied by rup.
78:                //fractional rup[] = { RMAX, 0, 0, 0, RMAX, 0, 0, 0, RMAX };
79:                
80:                // gyro rotation vector:
81:                fractional omegagyro[] = { 0, 0, 0 };
82:                fractional omega[] = { 0, 0, 0 };
83:                
84:                // gyro correction vectors:
85:                static fractional omegacorrP[] = { 0, 0, 0 };
86:                fractional omegacorrI[] = { 0, 0, 0 };
87:                
88:                // acceleration, as measured in GPS earth coordinate system
89:                fractional accelEarth[] = { 0, 0, 0 };
90:                
91:                //union longww accelEarthFiltered[] = { { 0 }, { 0 },  { 0 } };
92:                
93:                // correction vector integrators;
94:                union longww gyroCorrectionIntegral[] =  { { 0 }, { 0 },  { 0 } };
95:                union longww gyro_fraction[] =  { { 0 }, { 0 },  { 0 } };
96:                
97:                // accumulator for computing adjusted omega:
98:                fractional omegaAccum[] = { 0, 0, 0 };
99:                
100:               // gravity, as measured in plane coordinate system
101:               
102:               fractional gplane[] = { 0, 0, GRAVITY };
103:               int16_t aero_force[] = { 0 , 0 , -GRAVITY };
104:               union longww aero_force_filtered[3];
105:               
106:               // horizontal velocity over ground, as measured by GPS (Vz = 0)
107:               fractional dirOverGndHGPS[] = { 0, RMAX, 0 };
108:               
109:               // horizontal direction over ground, as indicated by Rmatrix
110:               fractional dirOverGndHrmat[] = { 0, RMAX, 0 };
111:               
112:               // rotation angle equal to omega times integration factor:
113:               //fractional theta[] = { 0, 0, 0 };
114:               
115:               // matrix buffer:
116:               //fractional rbuff[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
117:               
118:               // vector buffer
119:               fractional errorRP[] = { 0, 0, 0 };
120:               fractional errorYawground[] = { 0, 0, 0 };
121:               fractional errorYawplane[]  = { 0, 0, 0 };
122:               
123:               // measure of error in orthogonality, used for debugging purposes:
124:               static fractional error = 0;
125:               
126:               #if (MAG_YAW_DRIFT == 1)
127:               static fractional declinationVector[2];
128:               #endif
129:               
130:               #if (DECLINATIONANGLE_VARIABLE == 1)
131:               union intbb dcm_declination_angle;
132:               #endif
133:               
134:               void estimate_velocity(void);
135:               
136:               void lookup_gyro_offsets(void);
137:               
138:               void yaw_drift_reset(void)
139:               {
0034B6  FA0000     LNK #0x0
140:               	errorYawground[0] = errorYawground[1] = errorYawground[2] = 0; // turn off yaw drift
0034B8  EB0000     CLR W0
0034BA  88D570     MOV W0, 0x1AAE
0034BC  80D570     MOV 0x1AAE, W0
0034BE  88D560     MOV W0, .L9
0034C0  80D560     MOV .L9, W0
0034C2  88D550     MOV W0, 0x1AAA
141:               }
0034C4  FA8000     ULNK
0034C6  060000     RETURN
142:               
143:               void dcm_init_rmat(void)
144:               {
0034C8  FA0000     LNK #0x0
145:               #if (MAG_YAW_DRIFT == 1)
146:               #if (DECLINATIONANGLE_VARIABLE == 1)
147:               	dcm_declination_angle.BB = DECLINATIONANGLE;
148:               #endif
149:               	declinationVector[0] = cosine((int8_t) (DECLINATIONANGLE >> 8));
150:               	declinationVector[1] = sine((int8_t) (DECLINATIONANGLE >> 8));
151:               #endif
152:               }
0034CA  FA8000     ULNK
0034CC  060000     RETURN
153:               
154:               union longww omegagyro_filtered[] = { { 0 }, { 0 },  { 0 } };
155:               
156:               #define GYRO_FILTER_SHIFT 12
157:               
158:               extern int16_t accelOn ;
159:               extern int16_t gyro_offset[];
160:               union longww gyro_offset_32[] = { { 0 }, { 0 },  { 0 } };
161:               static inline void read_gyros(void)
162:               {
0034CE  FA0004     LNK #0x4
163:               	// fetch the gyro signals and subtract the baseline offset, 
164:               	// and adjust for variations in supply voltage
165:               	
166:               	lookup_gyro_offsets();
0034D0  023FEE     CALL lookup_gyro_offsets
0034D2  000000     NOP
167:               	gyro_offset_32[0].WW += ((int32_t)gyro_offset[0]) << 10 ;
0034D4  80D612     MOV 0x1AC2, W2
0034D6  80D623     MOV 0x1AC4, W3
0034D8  80EA20     MOV gyro_offset, W0
0034DA  B90261     MUL.SU W0, #1, W4
0034DC  DD284A     SL W5, #10, W0
0034DE  DE20C6     LSR W4, #6, W1
0034E0  700081     IOR W0, W1, W1
0034E2  DD204A     SL W4, #10, W0
0034E4  400002     ADD W0, W2, W0
0034E6  488083     ADDC W1, W3, W1
0034E8  88D610     MOV W0, 0x1AC2
0034EA  88D621     MOV W1, 0x1AC4
168:               	gyro_offset_32[1].WW += ((int32_t)gyro_offset[1]) << 10 ;
0034EC  80D632     MOV .L11, W2
0034EE  80D643     MOV .L2, W3
0034F0  80EA30     MOV .L29, W0
0034F2  B90261     MUL.SU W0, #1, W4
0034F4  DD284A     SL W5, #10, W0
0034F6  DE20C6     LSR W4, #6, W1
0034F8  700081     IOR W0, W1, W1
0034FA  DD204A     SL W4, #10, W0
0034FC  400002     ADD W0, W2, W0
0034FE  488083     ADDC W1, W3, W1
003500  88D630     MOV W0, .L11
003502  88D641     MOV W1, .L2
169:               	gyro_offset_32[2].WW += ((int32_t)gyro_offset[2]) << 10 ;
003504  80D652     MOV 0x1ACA, W2
003506  80D663     MOV 0x1ACC, W3
003508  80EA40     MOV 0x1D48, W0
00350A  B90261     MUL.SU W0, #1, W4
00350C  DD284A     SL W5, #10, W0
00350E  DE20C6     LSR W4, #6, W1
003510  700081     IOR W0, W1, W1
003512  DD204A     SL W4, #10, W0
003514  400002     ADD W0, W2, W0
003516  488083     ADDC W1, W3, W1
003518  88D650     MOV W0, 0x1ACA
00351A  88D661     MOV W1, 0x1ACC
170:               	udb_xrate.offset = (gyro_offset_32[0]._.W1) ;
00351C  80D620     MOV 0x1AC4, W0
00351E  88E570     MOV W0, 0x1CAE
171:               	udb_yrate.offset = (gyro_offset_32[1]._.W1) ;
003520  80D640     MOV .L2, W0
003522  88E5C0     MOV W0, 0x1CB8
172:               	udb_zrate.offset = (gyro_offset_32[2]._.W1) ;
003524  80D660     MOV 0x1ACC, W0
003526  88E610     MOV W0, 0x1CC2
173:               	gyro_offset_32[0]._.W1 = 0 ;
003528  EB0000     CLR W0
00352A  88D620     MOV W0, 0x1AC4
174:               	gyro_offset_32[1]._.W1 = 0 ;
00352C  EB0000     CLR W0
00352E  88D640     MOV W0, .L2
175:               	gyro_offset_32[2]._.W1 = 0 ;
003530  EB0000     CLR W0
003532  88D660     MOV W0, 0x1ACC
176:               
177:               	omegagyro[0] = XRATE_VALUE;
003534  80E560     MOV 0x1CAC, W0
003536  D18080     ASR W0, W1
003538  80E570     MOV 0x1CAE, W0
00353A  D18000     ASR W0, W0
00353C  508000     SUB W1, W0, W0
00353E  88D2B0     MOV W0, .L3
178:               	omegagyro[1] = YRATE_VALUE;
003540  80E5C0     MOV 0x1CB8, W0
003542  D18080     ASR W0, W1
003544  80E5B0     MOV 0x1CB6, W0
003546  D18000     ASR W0, W0
003548  508000     SUB W1, W0, W0
00354A  88D2C0     MOV W0, 0x1A58
179:               	omegagyro[2] = ZRATE_VALUE;
00354C  80E610     MOV 0x1CC2, W0
00354E  D18080     ASR W0, W1
003550  80E600     MOV 0x1CC0, W0
003552  D18000     ASR W0, W0
003554  508000     SUB W1, W0, W0
003556  88D2D0     MOV W0, 0x1A5A
180:               	union longww accum32 ;
181:               	
182:               	if (accelOn == 1)
003558  80CCE0     MOV accelOn, W0
00355A  500FE1     SUB W0, #0x1, [W15]
00355C  3A0042     BRA NZ, .L3, .LSM26
183:               	{
184:               	accum32._.W1 = -omegagyro[0] ;
00355E  80D2B0     MOV .L3, W0
003560  EA0000     NEG W0, W0
003562  980710     MOV W0, [W14+2]
185:               	omegagyro_filtered[0].WW += ((int32_t)(accum32.WW)>>GYRO_FILTER_SHIFT) -((int32_t)(omegagyro_filtered[0].WW )>>GYRO_FILTER_SHIFT) ;
003564  80D5B2     MOV .L10, W2
003566  80D5C3     MOV 0x1AB8, W3
003568  BE001E     MOV.D [W14], W0
00356A  DE8ACC     ASR W1, #12, W5
00356C  DD0B44     SL W1, #4, W6
00356E  DE024C     LSR W0, #12, W4
003570  730204     IOR W6, W4, W4
003572  80D5B0     MOV .L10, W0
003574  80D5C1     MOV 0x1AB8, W1
003576  DD0B44     SL W1, #4, W6
003578  DE004C     LSR W0, #12, W0
00357A  730000     IOR W6, W0, W0
00357C  DE88CC     ASR W1, #12, W1
00357E  520000     SUB W4, W0, W0
003580  5A8081     SUBB W5, W1, W1
003582  400002     ADD W0, W2, W0
003584  488083     ADDC W1, W3, W1
003586  88D5B0     MOV W0, .L10
003588  88D5C1     MOV W1, 0x1AB8
186:               	accum32._.W1 = -omegagyro[1] ;
00358A  80D2C0     MOV 0x1A58, W0
00358C  EA0000     NEG W0, W0
00358E  980710     MOV W0, [W14+2]
187:               	omegagyro_filtered[1].WW += ((int32_t)(accum32.WW)>>GYRO_FILTER_SHIFT) -((int32_t)(omegagyro_filtered[1].WW )>>GYRO_FILTER_SHIFT) ;
003590  80D5D2     MOV 0x1ABA, W2
003592  80D5E3     MOV 0x1ABC, W3
003594  BE001E     MOV.D [W14], W0
003596  DE8ACC     ASR W1, #12, W5
003598  DD0B44     SL W1, #4, W6
00359A  DE024C     LSR W0, #12, W4
00359C  730204     IOR W6, W4, W4
00359E  80D5D0     MOV 0x1ABA, W0
0035A0  80D5E1     MOV 0x1ABC, W1
0035A2  DD0B44     SL W1, #4, W6
0035A4  DE004C     LSR W0, #12, W0
0035A6  730000     IOR W6, W0, W0
0035A8  DE88CC     ASR W1, #12, W1
0035AA  520000     SUB W4, W0, W0
0035AC  5A8081     SUBB W5, W1, W1
0035AE  400002     ADD W0, W2, W0
0035B0  488083     ADDC W1, W3, W1
0035B2  88D5D0     MOV W0, 0x1ABA
0035B4  88D5E1     MOV W1, 0x1ABC
188:               	accum32._.W1 = -omegagyro[2] ;
0035B6  80D2D0     MOV 0x1A5A, W0
0035B8  EA0000     NEG W0, W0
0035BA  980710     MOV W0, [W14+2]
189:               	omegagyro_filtered[2].WW += ((int32_t)(accum32.WW)>>GYRO_FILTER_SHIFT) -((int32_t)(omegagyro_filtered[2].WW )>>GYRO_FILTER_SHIFT) ;
0035BC  80D5F2     MOV 0x1ABE, W2
0035BE  80D603     MOV 0x1AC0, W3
0035C0  BE001E     MOV.D [W14], W0
0035C2  DE8ACC     ASR W1, #12, W5
0035C4  DD0B44     SL W1, #4, W6
0035C6  DE024C     LSR W0, #12, W4
0035C8  730204     IOR W6, W4, W4
0035CA  80D5F0     MOV 0x1ABE, W0
0035CC  80D601     MOV 0x1AC0, W1
0035CE  DD0B44     SL W1, #4, W6
0035D0  DE004C     LSR W0, #12, W0
0035D2  730000     IOR W6, W0, W0
0035D4  DE88CC     ASR W1, #12, W1
0035D6  520000     SUB W4, W0, W0
0035D8  5A8081     SUBB W5, W1, W1
0035DA  400002     ADD W0, W2, W0
0035DC  488083     ADDC W1, W3, W1
0035DE  88D5F0     MOV W0, 0x1ABE
0035E0  88D601     MOV W1, 0x1AC0
190:               	}
191:               }
0035E2  FA8000     ULNK
0035E4  060000     RETURN
192:               boolean first_accel = 1 ;
193:               int16_t aero_force_new[] = { 0 , 0 , 0 } ;
194:               int16_t aero_force_previous[] = { 0 , 0 , 0 } ;
195:               
196:               inline void read_accel(void)
197:               {
0035E6  FA0000     LNK #0x0
198:               
199:               	gplane[0] = __builtin_divsd(__builtin_mulss(XACCEL_VALUE,CALIB_GRAVITY),CAL_GRAV_X);
0035E8  80E480     MOV 0x1C90, W0
0035EA  D18080     ASR W0, W1
0035EC  80E470     MOV 0x1C8E, W0
0035EE  D18000     ASR W0, W0
0035F0  508000     SUB W1, W0, W0
0035F2  210001     MOV #0x1000, W1
0035F4  B98001     MUL.SS W0, W1, W0
0035F6  210242     MOV #0x1024, W2
0035F8  781F81     MOV W1, [W15++]
0035FA  090011     REPEAT #0x11
0035FC  D80842     DIV.SD W0, W2
0035FE  7800CF     MOV [--W15], W1
003600  88D460     MOV W0, 0x1A8C
200:               	gplane[1] = __builtin_divsd(__builtin_mulss(YACCEL_VALUE,CALIB_GRAVITY),CAL_GRAV_Y);
003602  80E4C0     MOV 0x1C98, W0
003604  D18080     ASR W0, W1
003606  80E4D0     MOV 0x1C9A, W0
003608  D18000     ASR W0, W0
00360A  508000     SUB W1, W0, W0
00360C  210001     MOV #0x1000, W1
00360E  B98001     MUL.SS W0, W1, W0
003610  20FFE2     MOV #0xFFE, W2
003612  781F81     MOV W1, [W15++]
003614  090011     REPEAT #0x11
003616  D80842     DIV.SD W0, W2
003618  7800CF     MOV [--W15], W1
00361A  88D470     MOV W0, 0x1A8E
201:               	gplane[2] = __builtin_divsd(__builtin_mulss(ZACCEL_VALUE,CALIB_GRAVITY),CAL_GRAV_Z);
00361C  80E510     MOV 0x1CA2, W0
00361E  D18080     ASR W0, W1
003620  80E520     MOV 0x1CA4, W0
003622  D18000     ASR W0, W0
003624  508000     SUB W1, W0, W0
003626  210001     MOV #0x1000, W1
003628  B98001     MUL.SS W0, W1, W0
00362A  210492     MOV #0x1049, W2
00362C  781F81     MOV W1, [W15++]
00362E  090011     REPEAT #0x11
003630  D80842     DIV.SD W0, W2
003632  7800CF     MOV [--W15], W1
003634  88D480     MOV W0, 0x1A90
202:               	
203:               	aero_force_new[0] = - gplane[0] ;
003636  80D460     MOV 0x1A8C, W0
003638  EA0000     NEG W0, W0
00363A  88D680     MOV W0, 0x1AD0
204:               	aero_force_new[1] = - gplane[1] ;
00363C  80D470     MOV 0x1A8E, W0
00363E  EA0000     NEG W0, W0
003640  88D690     MOV W0, 0x1AD2
205:               	aero_force_new[2] = - gplane[2] ;
003642  80D480     MOV 0x1A90, W0
003644  EA0000     NEG W0, W0
003646  88D6A0     MOV W0, _memchr
206:               	
207:               	if (first_accel == 1 )
003648  21ACE0     MOV #0x1ACE, W0
00364A  784010     MOV.B [W0], W0
00364C  504FE1     SUB.B W0, #0x1, [W15]
00364E  3A000D     BRA NZ, .L6, .LSM41
208:               	{
209:               		aero_force[0] = aero_force_new[0] ;
003650  80D680     MOV 0x1AD0, W0
003652  88D490     MOV W0, 0x1A92
210:               		aero_force[1] = aero_force_new[1] ;
003654  80D690     MOV 0x1AD2, W0
003656  88D4A0     MOV W0, 0x1A94
211:               		aero_force[2] = aero_force_new[2] ;
003658  80D6A0     MOV _memchr, W0
00365A  88D4B0     MOV W0, 0x1A96
212:               	
213:               		aero_force_previous[0] = aero_force_new[0] ;
00365C  80D680     MOV 0x1AD0, W0
00365E  88D6B0     MOV W0, .L4
214:               		aero_force_previous[1] = aero_force_new[1] ;
003660  80D690     MOV 0x1AD2, W0
003662  88D6C0     MOV W0, 0x1AD8
215:               		aero_force_previous[2] = aero_force_new[2] ;
003664  80D6A0     MOV _memchr, W0
003666  88D6D0     MOV W0, 0x1ADA
003668  37001E     BRA .L7, .LSM47
216:               	}
217:               	else
218:               	{
219:               		aero_force[0] = (aero_force_new[0] + aero_force_previous[0])/2 ;
00366A  80D681     MOV 0x1AD0, W1
00366C  80D6B0     MOV .L4, W0
00366E  408080     ADD W1, W0, W1
003670  200020     MOV #0x2, W0
003672  780100     MOV W0, W2
003674  090011     REPEAT #0x11
003676  D80082     DIV.SW W1, W2
003678  88D490     MOV W0, 0x1A92
220:               		aero_force[1] = (aero_force_new[1] + aero_force_previous[1])/2 ;
00367A  80D691     MOV 0x1AD2, W1
00367C  80D6C0     MOV 0x1AD8, W0
00367E  408080     ADD W1, W0, W1
003680  200020     MOV #0x2, W0
003682  780300     MOV W0, W6
003684  090011     REPEAT #0x11
003686  D80086     DIV.SW W1, W6
003688  88D4A0     MOV W0, 0x1A94
221:               		aero_force[2] = (aero_force_new[2] + aero_force_previous[2])/2 ;
00368A  80D6A1     MOV _memchr, W1
00368C  80D6D0     MOV 0x1ADA, W0
00368E  408080     ADD W1, W0, W1
003690  200020     MOV #0x2, W0
003692  780100     MOV W0, W2
003694  090011     REPEAT #0x11
003696  D80082     DIV.SW W1, W2
003698  88D4B0     MOV W0, 0x1A96
222:               	
223:               		aero_force_previous[0] = aero_force_new[0] ;
00369A  80D680     MOV 0x1AD0, W0
00369C  88D6B0     MOV W0, .L4
224:               		aero_force_previous[1] = aero_force_new[1] ;
00369E  80D690     MOV 0x1AD2, W0
0036A0  88D6C0     MOV W0, 0x1AD8
225:               		aero_force_previous[2] = aero_force_new[2] ;
0036A2  80D6A0     MOV _memchr, W0
0036A4  88D6D0     MOV W0, 0x1ADA
226:               	}
227:               	
228:               	if (first_accel == 1 )
0036A6  21ACE0     MOV #0x1ACE, W0
0036A8  784010     MOV.B [W0], W0
0036AA  504FE1     SUB.B W0, #0x1, [W15]
0036AC  3A000A     BRA NZ, .L8, .LSM52
229:               	{
230:               		aero_force_filtered[0]._.W1 = aero_force[0] ;
0036AE  80D490     MOV 0x1A92, W0
0036B0  88CBC0     MOV W0, .L68
231:               		aero_force_filtered[1]._.W1 = aero_force[1] ;
0036B2  80D4A0     MOV 0x1A94, W0
0036B4  88CBE0     MOV W0, 0x197C
232:               		aero_force_filtered[2]._.W1 = aero_force[2] ;
0036B6  80D4B0     MOV 0x1A96, W0
0036B8  88CC00     MOV W0, 0x1980
233:               		first_accel = 0 ;
0036BA  21ACE1     MOV #0x1ACE, W1
0036BC  EB4000     CLR.B W0
0036BE  784880     MOV.B W0, [W1]
0036C0  37003C     BRA .L9, .LSM55
234:               	}
235:               	else
236:               	{
237:               		aero_force_filtered[0].WW += (((int32_t)aero_force[0])<<10)-((aero_force_filtered[0].WW)>>6);
0036C2  80CBB2     MOV aero_force_filtered, W2
0036C4  80CBC3     MOV .L68, W3
0036C6  80D490     MOV 0x1A92, W0
0036C8  DE80CF     ASR W0, #15, W1
0036CA  DD0A4A     SL W1, #10, W4
0036CC  DE02C6     LSR W0, #6, W5
0036CE  720285     IOR W4, W5, W5
0036D0  DD024A     SL W0, #10, W4
0036D2  80CBB0     MOV aero_force_filtered, W0
0036D4  80CBC1     MOV .L68, W1
0036D6  DD0B4A     SL W1, #10, W6
0036D8  DE0046     LSR W0, #6, W0
0036DA  730000     IOR W6, W0, W0
0036DC  DE88C6     ASR W1, #6, W1
0036DE  520000     SUB W4, W0, W0
0036E0  5A8081     SUBB W5, W1, W1
0036E2  400002     ADD W0, W2, W0
0036E4  488083     ADDC W1, W3, W1
0036E6  88CBB0     MOV W0, aero_force_filtered
0036E8  88CBC1     MOV W1, .L68
238:               		aero_force_filtered[1].WW += (((int32_t)aero_force[1])<<10)-((aero_force_filtered[1].WW)>>6);
0036EA  80CBD2     MOV 0x197A, W2
0036EC  80CBE3     MOV 0x197C, W3
0036EE  80D4A0     MOV 0x1A94, W0
0036F0  DE80CF     ASR W0, #15, W1
0036F2  DD0A4A     SL W1, #10, W4
0036F4  DE02C6     LSR W0, #6, W5
0036F6  720285     IOR W4, W5, W5
0036F8  DD024A     SL W0, #10, W4
0036FA  80CBD0     MOV 0x197A, W0
0036FC  80CBE1     MOV 0x197C, W1
0036FE  DD0B4A     SL W1, #10, W6
003700  DE0046     LSR W0, #6, W0
003702  730000     IOR W6, W0, W0
003704  DE88C6     ASR W1, #6, W1
003706  520000     SUB W4, W0, W0
003708  5A8081     SUBB W5, W1, W1
00370A  400002     ADD W0, W2, W0
00370C  488083     ADDC W1, W3, W1
00370E  88CBD0     MOV W0, 0x197A
003710  88CBE1     MOV W1, 0x197C
239:               		aero_force_filtered[2].WW += (((int32_t)aero_force[2])<<10)-((aero_force_filtered[2].WW)>>6);
003712  80CBF2     MOV 0x197E, W2
003714  80CC03     MOV 0x1980, W3
003716  80D4B0     MOV 0x1A96, W0
003718  DE80CF     ASR W0, #15, W1
00371A  DD0A4A     SL W1, #10, W4
00371C  DE02C6     LSR W0, #6, W5
00371E  720285     IOR W4, W5, W5
003720  DD024A     SL W0, #10, W4
003722  80CBF0     MOV 0x197E, W0
003724  80CC01     MOV 0x1980, W1
003726  DD0B4A     SL W1, #10, W6
003728  DE0046     LSR W0, #6, W0
00372A  730000     IOR W6, W0, W0
00372C  DE88C6     ASR W1, #6, W1
00372E  520000     SUB W4, W0, W0
003730  5A8081     SUBB W5, W1, W1
003732  400002     ADD W0, W2, W0
003734  488083     ADDC W1, W3, W1
003736  88CBF0     MOV W0, 0x197E
003738  88CC01     MOV W1, 0x1980
240:               	}
241:               
242:               
243:               
244:                       // gplane is a vector that represents the gravity vector minus the acceleration vector,
245:                       // as seen in the body frame. Taking the dot products of gplane with the rows of the
246:                       // rotation matrix is the same thing as multiplying the rotation matrix times gplane vector,
247:                       // which is the same thing as transforming gplane into the earth frame,
248:                       // which gives us gravity minus acceleration in the earth frame,
249:                       // regardless of the orientation of the aircraft.
250:                       //
251:                       // We want acceleration minus gravity in the earth frame, so sign flip all three components.
252:                       // Going from UDB coordinates to Earth coordinates (east, north, up) requires us to apply
253:                       // another sign flip to x and z. So, taking the dot products and
254:                       // flipping only the sign of y, gives us acceleration minus gravity in the earth frame.
255:                       //
256:                       // The final step is to add gravity, which is equal to -GRAVITY, since gravity (which is down)
257:                       // is in the opposite direction to the earth up direction. so, the final step is to add -GRAVITY.
258:                       //
259:                       // See the following URL for further details of the frame reference conventions for UDB / MatrixPilot
260:                       // https://code.google.com/p/gentlenav/wiki/UDBCoordinateSystems
261:               	accelEarth[0] = +(VectorDotProduct(3, &rmat[0], gplane) << 1);
00373A  21A8C2     MOV #0x1A8C, W2
00373C  21A441     MOV #0x1A44, W1
00373E  200030     MOV #0x3, W0
003740  020BEC     CALL _VectorDotProduct
003742  000000     NOP
003744  400000     ADD W0, W0, W0
003746  88D340     MOV W0, 0x1A68
262:               	accelEarth[1] = -(VectorDotProduct(3, &rmat[3], gplane) << 1);
003748  21A8C2     MOV #0x1A8C, W2
00374A  21A4A1     MOV #0x1A4A, W1
00374C  200030     MOV #0x3, W0
00374E  020BEC     CALL _VectorDotProduct
003750  000000     NOP
003752  400000     ADD W0, W0, W0
003754  EA0000     NEG W0, W0
003756  88D350     MOV W0, 0x1A6A
263:               	accelEarth[2] = +(-((int16_t)GRAVITY) + (VectorDotProduct(3, &rmat[6], gplane) << 1));
003758  21A8C2     MOV #0x1A8C, W2
00375A  21A501     MOV #0x1A50, W1
00375C  200030     MOV #0x3, W0
00375E  020BEC     CALL _VectorDotProduct
003760  000000     NOP
003762  400000     ADD W0, W0, W0
003764  780080     MOV W0, W1
003766  2EFC30     MOV #0xEFC3, W0
003768  408000     ADD W1, W0, W0
00376A  88D360     MOV W0, 0x1A6C
264:               
265:               //	accelEarthFiltered[0].WW += ((((int32_t)accelEarth[0])<<16) - accelEarthFiltered[0].WW)>>5;
266:               //	accelEarthFiltered[1].WW += ((((int32_t)accelEarth[1])<<16) - accelEarthFiltered[1].WW)>>5;
267:               //	accelEarthFiltered[2].WW += ((((int32_t)accelEarth[2])<<16) - accelEarthFiltered[2].WW)>>5;
268:               }
00376C  FA8000     ULNK
00376E  060000     RETURN
269:               
270:               void udb_callback_read_sensors(void)
271:               {
003770  FA0000     LNK #0x0
272:               	read_gyros(); // record the average values for both DCM and for offset measurements
003772  07FEAD     RCALL _read_gyros, .LFE1, .LFB2, .LSM5
273:               	read_accel();
003774  07FF38     RCALL read_accel
274:               }
003776  FA8000     ULNK
003778  060000     RETURN
275:               
276:               fractional theta[3];
277:               extern int16_t theta_16[];
278:               fractional rup_copy[9];
279:               // The update algorithm!!
280:               static void rupdate(void)
281:               {
00377A  FA005C     LNK #0x5C
282:               	// This is the key routine. It performs a small rotation
283:               	// on the direction cosine matrix, based on the gyro vector and correction.
284:               	// It uses vector and matrix routines furnished by Microchip.
285:               	fractional delta_angle[9];
286:               	fractional delta_angle_square_over_2[9];
287:               	fractional delta_angle_cube_over_6[9];
288:               	fractional rup[9];
289:               
290:               	fractional rbuff[9];
291:               		
292:               //	VectorAdd(3, omegaAccum, omegagyro, omegacorrI);
293:               	
294:               	gyro_fraction[0]._.W1 = omegagyro[0] ;
00377C  80D2B0     MOV .L3, W0
00377E  88D3E0     MOV W0, 0x1A7C
295:               	gyro_fraction[1]._.W1 = omegagyro[1] ;
003780  80D2C0     MOV 0x1A58, W0
003782  88D400     MOV W0, .L6
296:               	gyro_fraction[2]._.W1 = omegagyro[2] ;
003784  80D2D0     MOV 0x1A5A, W0
003786  88D420     MOV W0, 0x1A84
297:               	
298:               	if (accelOn == 1 )
003788  80CCE0     MOV accelOn, W0
00378A  500FE1     SUB W0, #0x1, [W15]
00378C  3A0019     BRA NZ, .L12, .LSM71
299:               	{
300:               		gyro_fraction[0].WW = gyro_fraction[0].WW + gyroCorrectionIntegral[0].WW ;
00378E  80D3D2     MOV 0x1A7A, W2
003790  80D3E3     MOV 0x1A7C, W3
003792  80D370     MOV 0x1A6E, W0
003794  80D381     MOV .L13, W1
003796  400002     ADD W0, W2, W0
003798  488083     ADDC W1, W3, W1
00379A  88D3D0     MOV W0, 0x1A7A
00379C  88D3E1     MOV W1, 0x1A7C
301:               		gyro_fraction[1].WW = gyro_fraction[1].WW + gyroCorrectionIntegral[1].WW ;
00379E  80D3F2     MOV 0x1A7E, W2
0037A0  80D403     MOV .L6, W3
0037A2  80D390     MOV .L5, W0
0037A4  80D3A1     MOV 0x1A74, W1
0037A6  400002     ADD W0, W2, W0
0037A8  488083     ADDC W1, W3, W1
0037AA  88D3F0     MOV W0, 0x1A7E
0037AC  88D401     MOV W1, .L6
302:               		gyro_fraction[2].WW = gyro_fraction[2].WW + gyroCorrectionIntegral[2].WW ;
0037AE  80D412     MOV 0x1A82, W2
0037B0  80D423     MOV 0x1A84, W3
0037B2  80D3B0     MOV 0x1A76, W0
0037B4  80D3C1     MOV 0x1A78, W1
0037B6  400002     ADD W0, W2, W0
0037B8  488083     ADDC W1, W3, W1
0037BA  88D410     MOV W0, 0x1A82
0037BC  88D421     MOV W1, 0x1A84
0037BE  370018     BRA .L13, .LSM74
303:               	}
304:               	else
305:               	{
306:               		gyro_fraction[0].WW = gyro_fraction[0].WW + omegagyro_filtered[0].WW ;	
0037C0  80D3D2     MOV 0x1A7A, W2
0037C2  80D3E3     MOV 0x1A7C, W3
0037C4  80D5B0     MOV .L10, W0
0037C6  80D5C1     MOV 0x1AB8, W1
0037C8  400002     ADD W0, W2, W0
0037CA  488083     ADDC W1, W3, W1
0037CC  88D3D0     MOV W0, 0x1A7A
0037CE  88D3E1     MOV W1, 0x1A7C
307:               		gyro_fraction[1].WW = gyro_fraction[1].WW + omegagyro_filtered[1].WW ;
0037D0  80D3F2     MOV 0x1A7E, W2
0037D2  80D403     MOV .L6, W3
0037D4  80D5D0     MOV 0x1ABA, W0
0037D6  80D5E1     MOV 0x1ABC, W1
0037D8  400002     ADD W0, W2, W0
0037DA  488083     ADDC W1, W3, W1
0037DC  88D3F0     MOV W0, 0x1A7E
0037DE  88D401     MOV W1, .L6
308:               		gyro_fraction[2].WW = gyro_fraction[2].WW + omegagyro_filtered[2].WW ;
0037E0  80D412     MOV 0x1A82, W2
0037E2  80D423     MOV 0x1A84, W3
0037E4  80D5F0     MOV 0x1ABE, W0
0037E6  80D601     MOV 0x1AC0, W1
0037E8  400002     ADD W0, W2, W0
0037EA  488083     ADDC W1, W3, W1
0037EC  88D410     MOV W0, 0x1A82
0037EE  88D421     MOV W1, 0x1A84
309:               	}
310:               	
311:               	omegaAccum[0] = gyro_fraction[0]._.W1 ;
0037F0  80D3E0     MOV 0x1A7C, W0
0037F2  88D430     MOV W0, 0x1A86
312:               	omegaAccum[1] = gyro_fraction[1]._.W1 ;
0037F4  80D400     MOV .L6, W0
0037F6  88D440     MOV W0, 0x1A88
313:               	omegaAccum[2] = gyro_fraction[2]._.W1 ;
0037F8  80D420     MOV 0x1A84, W0
0037FA  88D450     MOV W0, 0x1A8A
314:               	
315:               	gyro_fraction[0]._.W1 = 0 ;
0037FC  EB0000     CLR W0
0037FE  88D3E0     MOV W0, 0x1A7C
316:               	gyro_fraction[1]._.W1 = 0 ;
003800  EB0000     CLR W0
003802  88D400     MOV W0, .L6
317:               	gyro_fraction[2]._.W1 = 0 ;
003804  EB0000     CLR W0
003806  88D420     MOV W0, 0x1A84
318:               	
319:               	VectorAdd(3, omega, omegaAccum, omegacorrP);
003808  219703     MOV #0x1970, W3
00380A  21A862     MOV #0x1A86, W2
00380C  21A5C1     MOV #0x1A5C, W1
00380E  200030     MOV #0x3, W0
003810  020A76     CALL _VectorAdd
003812  000000     NOP
320:               	//	scale by the integration factors:
321:               	VectorMultiply(3, theta, omega, ggain); // Scalegain of 2
003814  21A3C3     MOV #0x1A3C, W3
003816  21A5C2     MOV #0x1A5C, W2
003818  219841     MOV #0x1984, W1
00381A  200030     MOV #0x3, W0
00381C  020C5A     CALL _VectorMultiply
00381E  000000     NOP
322:               	// diagonal elements of the update matrix:
323:               	rup[0] = RMAX;
003820  200380     MOV #0x38, W0
003822  40000E     ADD W0, W14, W0
003824  240001     MOV #0x4000, W1
003826  780801     MOV W1, [W0]
324:               	rup[4] = RMAX;
003828  200380     MOV #0x38, W0
00382A  40000E     ADD W0, W14, W0
00382C  240001     MOV #0x4000, W1
00382E  980041     MOV W1, [W0+8]
325:               	rup[8] = RMAX;
003830  200380     MOV #0x38, W0
003832  40000E     ADD W0, W14, W0
003834  240001     MOV #0x4000, W1
003836  980801     MOV W1, [W0+16]
326:               	rup[1] = 0 ;
003838  200380     MOV #0x38, W0
00383A  40000E     ADD W0, W14, W0
00383C  EB0080     CLR W1
00383E  980011     MOV W1, [W0+2]
327:               	rup[2] = 0 ;
003840  200380     MOV #0x38, W0
003842  40000E     ADD W0, W14, W0
003844  EB0080     CLR W1
003846  980021     MOV W1, [W0+4]
328:               	rup[3] = 0 ;
003848  200380     MOV #0x38, W0
00384A  40000E     ADD W0, W14, W0
00384C  EB0080     CLR W1
00384E  980031     MOV W1, [W0+6]
329:               	rup[5] = 0 ;
003850  200380     MOV #0x38, W0
003852  40000E     ADD W0, W14, W0
003854  EB0080     CLR W1
003856  980051     MOV W1, [W0+10]
330:               	rup[6] = 0 ;
003858  200380     MOV #0x38, W0
00385A  40000E     ADD W0, W14, W0
00385C  EB0080     CLR W1
00385E  980061     MOV W1, [W0+12]
331:               	rup[7] = 0 ;
003860  200380     MOV #0x38, W0
003862  40000E     ADD W0, W14, W0
003864  EB0080     CLR W1
003866  980071     MOV W1, [W0+14]
332:               
333:               #ifdef CONING_CORRECTION
334:               	if (accelOn == 1 )
003868  80CCE0     MOV accelOn, W0
00386A  500FE1     SUB W0, #0x1, [W15]
00386C  3A001F     BRA NZ, .L14, .LSM101
335:               	{
336:               		// construct the delta angle matrix without coning correction
337:               		// because it includes residual offset compensation
338:               		// and coning correction is not needed during standby mode
339:               		delta_angle[0] = 0 ;
00386E  E8800E     INC2 W14, W0
003870  EB0080     CLR W1
003872  780801     MOV W1, [W0]
340:               		delta_angle[1] = -theta[2];
003874  80CC40     MOV 0x1988, W0
003876  EA0080     NEG W0, W1
003878  E8800E     INC2 W14, W0
00387A  980011     MOV W1, [W0+2]
341:               		delta_angle[2] =  theta[1];
00387C  80CC31     MOV 0x1986, W1
00387E  E8800E     INC2 W14, W0
003880  980021     MOV W1, [W0+4]
342:               		delta_angle[3] =  theta[2];
003882  80CC41     MOV 0x1988, W1
003884  E8800E     INC2 W14, W0
003886  980031     MOV W1, [W0+6]
343:               		delta_angle[4] = 0 ;
003888  E8800E     INC2 W14, W0
00388A  EB0080     CLR W1
00388C  980041     MOV W1, [W0+8]
344:               		delta_angle[5] = -theta[0];
00388E  80CC20     MOV theta, W0
003890  EA0080     NEG W0, W1
003892  E8800E     INC2 W14, W0
003894  980051     MOV W1, [W0+10]
345:               		delta_angle[6] = -theta[1];
003896  80CC30     MOV 0x1986, W0
003898  EA0080     NEG W0, W1
00389A  E8800E     INC2 W14, W0
00389C  980061     MOV W1, [W0+12]
346:               		delta_angle[7] =  theta[0];
00389E  80CC21     MOV theta, W1
0038A0  E8800E     INC2 W14, W0
0038A2  980071     MOV W1, [W0+14]
347:               		delta_angle[8] = 0 ;
0038A4  E8800E     INC2 W14, W0
0038A6  EB0080     CLR W1
0038A8  980801     MOV W1, [W0+16]
0038AA  37001E     BRA .L15, .LSM110
348:               	}
349:               	else
350:               	{
351:               		// construct the delta angle matrix with coning correction:
352:               		delta_angle[0] = 0 ;
0038AC  E8800E     INC2 W14, W0
0038AE  EB0080     CLR W1
0038B0  780801     MOV W1, [W0]
353:               		delta_angle[1] = -theta_16[2];
0038B2  80DCB0     MOV 0x1B96, W0
0038B4  EA0080     NEG W0, W1
0038B6  E8800E     INC2 W14, W0
0038B8  980011     MOV W1, [W0+2]
354:               		delta_angle[2] =  theta_16[1];
0038BA  80DCA1     MOV 0x1B94, W1
0038BC  E8800E     INC2 W14, W0
0038BE  980021     MOV W1, [W0+4]
355:               		delta_angle[3] =  theta_16[2];
0038C0  80DCB1     MOV 0x1B96, W1
0038C2  E8800E     INC2 W14, W0
0038C4  980031     MOV W1, [W0+6]
356:               		delta_angle[4] = 0 ;
0038C6  E8800E     INC2 W14, W0
0038C8  EB0080     CLR W1
0038CA  980041     MOV W1, [W0+8]
357:               		delta_angle[5] = -theta_16[0];
0038CC  80DC90     MOV theta_16, W0
0038CE  EA0080     NEG W0, W1
0038D0  E8800E     INC2 W14, W0
0038D2  980051     MOV W1, [W0+10]
358:               		delta_angle[6] = -theta_16[1];
0038D4  80DCA0     MOV 0x1B94, W0
0038D6  EA0080     NEG W0, W1
0038D8  E8800E     INC2 W14, W0
0038DA  980061     MOV W1, [W0+12]
359:               		delta_angle[7] =  theta_16[0];
0038DC  80DC91     MOV theta_16, W1
0038DE  E8800E     INC2 W14, W0
0038E0  980071     MOV W1, [W0+14]
360:               		delta_angle[8] = 0 ;
0038E2  E8800E     INC2 W14, W0
0038E4  EB0080     CLR W1
0038E6  980801     MOV W1, [W0+16]
361:               	}
362:               #else
363:               	
364:               	// construct the delta angle matrix:
365:               	delta_angle[0] = 0 ;
366:               	delta_angle[1] = -theta[2];
367:               	delta_angle[2] =  theta[1];
368:               	delta_angle[3] =  theta[2];
369:               	delta_angle[4] = 0 ;
370:               	delta_angle[5] = -theta[0];
371:               	delta_angle[6] = -theta[1];
372:               	delta_angle[7] =  theta[0];
373:               	delta_angle[8] = 0 ;
374:               #endif // CONING_CORRECTION
375:               	
376:               	// compute 1/2 of square of the delta angle matrix
377:               	// since a matrix multiply divides by 2, we get it for free	
378:               	MatrixMultiply( 3, 3, 3, delta_angle_square_over_2 , delta_angle , delta_angle );
0038E8  E8810E     INC2 W14, W2
0038EA  E8808E     INC2 W14, W1
0038EC  470074     ADD W14, #0x14, W0
0038EE  780282     MOV W2, W5
0038F0  780201     MOV W1, W4
0038F2  780180     MOV W0, W3
0038F4  200032     MOV #0x3, W2
0038F6  200031     MOV #0x3, W1
0038F8  200030     MOV #0x3, W0
0038FA  02092A     CALL _MatrixMultiply
0038FC  000000     NOP
379:               	
380:               	// first step in computing delta angle cube over 6, compute it over 4 ;
381:               	MatrixMultiply( 3, 3, 3, delta_angle_cube_over_6 , delta_angle_square_over_2 , delta_angle );
0038FE  E8810E     INC2 W14, W2
003900  4700F4     ADD W14, #0x14, W1
003902  200260     MOV #0x26, W0
003904  40000E     ADD W0, W14, W0
003906  780282     MOV W2, W5
003908  780201     MOV W1, W4
00390A  780180     MOV W0, W3
00390C  200032     MOV #0x3, W2
00390E  200031     MOV #0x3, W1
003910  200030     MOV #0x3, W0
003912  02092A     CALL _MatrixMultiply
003914  000000     NOP
382:               	
383:               	// multiply by 2/3
384:               	int16_t loop_index ;
385:               	for ( loop_index = 0 ; loop_index <= 8 ; ++ loop_index ) 
003916  EB0000     CLR W0
003918  780F00     MOV W0, [W14]
00391A  370014     BRA .L16
003942  E80F1E     INC [W14], [W14]
003944  78001E     MOV [W14], W0
003946  500FE8     SUB W0, #0x8, [W15]
003948  34FFE9     BRA LE, .L17, .LSM113
386:               	{
387:               		delta_angle_cube_over_6[loop_index] = __builtin_divsd(__builtin_mulsu(delta_angle_cube_over_6[loop_index],2 ),3);
00391C  200261     MOV #0x26, W1
00391E  40808E     ADD W1, W14, W1
003920  78001E     MOV [W14], W0
003922  400000     ADD W0, W0, W0
003924  780061     MOV [W1+W0], W0
003926  200021     MOV #0x2, W1
003928  B90001     MUL.SU W0, W1, W0
00392A  200032     MOV #0x3, W2
00392C  781F80     MOV W0, [W15++]
00392E  090011     REPEAT #0x11
003930  D80842     DIV.SD W0, W2
003932  780080     MOV W0, W1
003934  78004F     MOV [--W15], W0
003936  200262     MOV #0x26, W2
003938  41010E     ADD W2, W14, W2
00393A  78001E     MOV [W14], W0
00393C  400000     ADD W0, W0, W0
00393E  410000     ADD W2, W0, W0
003940  780801     MOV W1, [W0]
388:               	}
389:               	
390:               	// form the update matrix
391:               	MatrixAdd(3, 3, rup, rup, delta_angle );
00394A  E8810E     INC2 W14, W2
00394C  200381     MOV #0x38, W1
00394E  40808E     ADD W1, W14, W1
003950  200380     MOV #0x38, W0
003952  40000E     ADD W0, W14, W0
003954  780202     MOV W2, W4
003956  780181     MOV W1, W3
003958  780100     MOV W0, W2
00395A  200031     MOV #0x3, W1
00395C  200030     MOV #0x3, W0
00395E  0208EA     CALL _MatrixAdd
003960  000000     NOP
392:               	MatrixAdd(3, 3, rup, rup, delta_angle_square_over_2 );
003962  470174     ADD W14, #0x14, W2
003964  200381     MOV #0x38, W1
003966  40808E     ADD W1, W14, W1
003968  200380     MOV #0x38, W0
00396A  40000E     ADD W0, W14, W0
00396C  780202     MOV W2, W4
00396E  780181     MOV W1, W3
003970  780100     MOV W0, W2
003972  200031     MOV #0x3, W1
003974  200030     MOV #0x3, W0
003976  0208EA     CALL _MatrixAdd
003978  000000     NOP
393:               	MatrixAdd(3, 3, rup, rup, delta_angle_cube_over_6 );
00397A  200262     MOV #0x26, W2
00397C  41010E     ADD W2, W14, W2
00397E  200381     MOV #0x38, W1
003980  40808E     ADD W1, W14, W1
003982  200380     MOV #0x38, W0
003984  40000E     ADD W0, W14, W0
003986  780202     MOV W2, W4
003988  780181     MOV W1, W3
00398A  780100     MOV W0, W2
00398C  200031     MOV #0x3, W1
00398E  200030     MOV #0x3, W0
003990  0208EA     CALL _MatrixAdd
003992  000000     NOP
394:               
395:               	// for debugging
396:               	VectorCopy(9,rup_copy,rup);
003994  200380     MOV #0x38, W0
003996  40000E     ADD W0, W14, W0
003998  780100     MOV W0, W2
00399A  2198A1     MOV #0x198A, W1
00399C  200090     MOV #0x9, W0
00399E  020BAC     CALL _VectorCopy
0039A0  000000     NOP
397:               	// matrix multiply the rmatrix by the update matrix
398:               	MatrixMultiply(3, 3, 3, rbuff, rmat, rup);
0039A2  200381     MOV #0x38, W1
0039A4  40808E     ADD W1, W14, W1
0039A6  2004A0     MOV #0x4A, W0
0039A8  40000E     ADD W0, W14, W0
0039AA  780281     MOV W1, W5
0039AC  21A444     MOV #0x1A44, W4
0039AE  780180     MOV W0, W3
0039B0  200032     MOV #0x3, W2
0039B2  200031     MOV #0x3, W1
0039B4  200030     MOV #0x3, W0
0039B6  02092A     CALL _MatrixMultiply
0039B8  000000     NOP
399:               	// multiply by 2 and copy back from rbuff to rmat:
400:               	MatrixAdd(3, 3, rmat, rbuff, rbuff);
0039BA  2004A1     MOV #0x4A, W1
0039BC  40808E     ADD W1, W14, W1
0039BE  2004A0     MOV #0x4A, W0
0039C0  40000E     ADD W0, W14, W0
0039C2  780201     MOV W1, W4
0039C4  780180     MOV W0, W3
0039C6  21A442     MOV #0x1A44, W2
0039C8  200031     MOV #0x3, W1
0039CA  200030     MOV #0x3, W0
0039CC  0208EA     CALL _MatrixAdd
0039CE  000000     NOP
401:               }
0039D0  FA8000     ULNK
0039D2  060000     RETURN
402:               
403:               // The normalization algorithm
404:               static void normalize(void)
405:               {
0039D4  FA0016     LNK #0x16
406:               	//  This is the routine that maintains the orthogonality of the
407:               	//  direction cosine matrix, which is expressed by the identity
408:               	//  relationship that the cosine matrix multiplied by its
409:               	//  transpose should equal the identity matrix.
410:               	//  Small adjustments are made at each time step to assure orthogonality.
411:               
412:               	fractional norm;    // actual magnitude
413:               	fractional renorm;  // renormalization factor
414:               	fractional rbuff[9];
415:               
416:               	// take the tilt row without any adjustments
417:               	VectorCopy( 3 , &rbuff[6] , &rmat[6] ) ;
0039D6  470064     ADD W14, #0x4, W0
0039D8  40006C     ADD W0, #0xC, W0
0039DA  21A502     MOV #0x1A50, W2
0039DC  780080     MOV W0, W1
0039DE  200030     MOV #0x3, W0
0039E0  020BAC     CALL _VectorCopy
0039E2  000000     NOP
418:               	// compute the negative of the dot product between rows 2 and 3
419:               	error =  - 2*VectorDotProduct(3, &rmat[3], &rmat[6]);
0039E4  21A502     MOV #0x1A50, W2
0039E6  21A4A1     MOV #0x1A4A, W1
0039E8  200030     MOV #0x3, W0
0039EA  020BEC     CALL _VectorDotProduct
0039EC  000000     NOP
0039EE  2FFFE1     MOV #0xFFFE, W1
0039F0  B98001     MUL.SS W0, W1, W0
0039F2  780000     MOV W0, W0
0039F4  88CC10     MOV W0, error
420:               	// compute adjustment to row 2 that will make it more perpendicular to row 3
421:               	VectorScale( 3 , &rbuff[3] , &rbuff[6] , error ) ;
0039F6  80CC12     MOV error, W2
0039F8  470064     ADD W14, #0x4, W0
0039FA  4000EC     ADD W0, #0xC, W1
0039FC  470064     ADD W14, #0x4, W0
0039FE  400066     ADD W0, #0x6, W0
003A00  780182     MOV W2, W3
003A02  780101     MOV W1, W2
003A04  780080     MOV W0, W1
003A06  200030     MOV #0x3, W0
003A08  020D0E     CALL _VectorScale
003A0A  000000     NOP
422:               	VectorAdd( 3, &rbuff[3] , &rbuff[3] , &rmat[3] ) ;
003A0C  470064     ADD W14, #0x4, W0
003A0E  4000E6     ADD W0, #0x6, W1
003A10  470064     ADD W14, #0x4, W0
003A12  400066     ADD W0, #0x6, W0
003A14  21A4A3     MOV #0x1A4A, W3
003A16  780101     MOV W1, W2
003A18  780080     MOV W0, W1
003A1A  200030     MOV #0x3, W0
003A1C  020A76     CALL _VectorAdd
003A1E  000000     NOP
423:               	// use the cross product of row 2 and 3 to get the first row
424:               	VectorCross(&rbuff[0] , &rbuff[3] , &rbuff[6] ) ;
003A20  470064     ADD W14, #0x4, W0
003A22  40016C     ADD W0, #0xC, W2
003A24  470064     ADD W14, #0x4, W0
003A26  4000E6     ADD W0, #0x6, W1
003A28  470064     ADD W14, #0x4, W0
003A2A  02504E     CALL VectorCross
003A2C  000000     NOP
425:               
426:               	// Use a Taylor's expansion for 1/sqrt(X*X) to avoid division in the renormalization
427:               
428:               	// rescale row1
429:               	norm = VectorPower(3, &rbuff[0]); // Scalegain of 0.5
003A2E  470064     ADD W14, #0x4, W0
003A30  780080     MOV W0, W1
003A32  200030     MOV #0x3, W0
003A34  020CD6     CALL _VectorPower
003A36  000000     NOP
003A38  780F00     MOV W0, [W14]
430:               	renorm = RMAX15 - norm;
003A3A  260000     MOV #0x6000, W0
003A3C  50001E     SUB W0, [W14], W0
003A3E  980710     MOV W0, [W14+2]
431:               	VectorScale(3, &rbuff[0], &rbuff[0], renorm);
003A40  4700E4     ADD W14, #0x4, W1
003A42  470064     ADD W14, #0x4, W0
003A44  90019E     MOV [W14+2], W3
003A46  780101     MOV W1, W2
003A48  780080     MOV W0, W1
003A4A  200030     MOV #0x3, W0
003A4C  020D0E     CALL _VectorScale
003A4E  000000     NOP
432:               	VectorAdd(3, &rmat[0], &rbuff[0], &rbuff[0]);
003A50  4700E4     ADD W14, #0x4, W1
003A52  470064     ADD W14, #0x4, W0
003A54  780181     MOV W1, W3
003A56  780100     MOV W0, W2
003A58  21A441     MOV #0x1A44, W1
003A5A  200030     MOV #0x3, W0
003A5C  020A76     CALL _VectorAdd
003A5E  000000     NOP
433:               	// rescale row2
434:               	norm = VectorPower(3, &rbuff[3]);
003A60  470064     ADD W14, #0x4, W0
003A62  400066     ADD W0, #0x6, W0
003A64  780080     MOV W0, W1
003A66  200030     MOV #0x3, W0
003A68  020CD6     CALL _VectorPower
003A6A  000000     NOP
003A6C  780F00     MOV W0, [W14]
435:               	renorm = RMAX15 - norm;
003A6E  260000     MOV #0x6000, W0
003A70  50001E     SUB W0, [W14], W0
003A72  980710     MOV W0, [W14+2]
436:               	VectorScale(3, &rbuff[3], &rbuff[3], renorm);
003A74  470064     ADD W14, #0x4, W0
003A76  4000E6     ADD W0, #0x6, W1
003A78  470064     ADD W14, #0x4, W0
003A7A  400066     ADD W0, #0x6, W0
003A7C  90019E     MOV [W14+2], W3
003A7E  780101     MOV W1, W2
003A80  780080     MOV W0, W1
003A82  200030     MOV #0x3, W0
003A84  020D0E     CALL _VectorScale
003A86  000000     NOP
437:               	VectorAdd(3, &rmat[3], &rbuff[3], &rbuff[3]);
003A88  470064     ADD W14, #0x4, W0
003A8A  4000E6     ADD W0, #0x6, W1
003A8C  470064     ADD W14, #0x4, W0
003A8E  400066     ADD W0, #0x6, W0
003A90  780181     MOV W1, W3
003A92  780100     MOV W0, W2
003A94  21A4A1     MOV #0x1A4A, W1
003A96  200030     MOV #0x3, W0
003A98  020A76     CALL _VectorAdd
003A9A  000000     NOP
438:               	// rescale row3
439:               	norm = VectorPower(3, &rbuff[6]);
003A9C  470064     ADD W14, #0x4, W0
003A9E  40006C     ADD W0, #0xC, W0
003AA0  780080     MOV W0, W1
003AA2  200030     MOV #0x3, W0
003AA4  020CD6     CALL _VectorPower
003AA6  000000     NOP
003AA8  780F00     MOV W0, [W14]
440:               	renorm = RMAX15 - norm;
003AAA  260000     MOV #0x6000, W0
003AAC  50001E     SUB W0, [W14], W0
003AAE  980710     MOV W0, [W14+2]
441:               	VectorScale(3, &rbuff[6], &rbuff[6], renorm);
003AB0  470064     ADD W14, #0x4, W0
003AB2  4000EC     ADD W0, #0xC, W1
003AB4  470064     ADD W14, #0x4, W0
003AB6  40006C     ADD W0, #0xC, W0
003AB8  90019E     MOV [W14+2], W3
003ABA  780101     MOV W1, W2
003ABC  780080     MOV W0, W1
003ABE  200030     MOV #0x3, W0
003AC0  020D0E     CALL _VectorScale
003AC2  000000     NOP
442:               	VectorAdd(3, &rmat[6], &rbuff[6], &rbuff[6]);
003AC4  470064     ADD W14, #0x4, W0
003AC6  4000EC     ADD W0, #0xC, W1
003AC8  470064     ADD W14, #0x4, W0
003ACA  40006C     ADD W0, #0xC, W0
003ACC  780181     MOV W1, W3
003ACE  780100     MOV W0, W2
003AD0  21A501     MOV #0x1A50, W1
003AD2  200030     MOV #0x3, W0
003AD4  020A76     CALL _VectorAdd
003AD6  000000     NOP
443:               }
003AD8  FA8000     ULNK
003ADA  060000     RETURN
444:               
445:               int16_t accelOn ;
446:               int16_t launched ;
447:               extern int16_t accelEarthVertical ;
448:               extern int32_t velocityEarthVertical ;
449:               int16_t launch_count ;
450:               
451:               int16_t omega_dot_rmat6 ;
452:               int16_t omega_scaled[3] ;
453:               int16_t omega_yaw_drift[3] ;
454:               uint16_t omega_magnitude ;
455:               extern boolean logging_on ;
456:               
457:               extern boolean gyro_locking_on ;
458:               int16_t motion_reset_counter = 500 ;
459:               int16_t motion_detect = 1 ;
460:               uint16_t accel_magnitude ;
461:               static void roll_pitch_drift(void)
462:               {	
003ADC  FA0006     LNK #0x6
463:               	accel_magnitude = vector3_mag(gplane[0],gplane[1],gplane[2]);
003ADE  80D482     MOV 0x1A90, W2
003AE0  80D471     MOV 0x1A8E, W1
003AE2  80D460     MOV 0x1A8C, W0
003AE4  024DDA     CALL vector3_mag
003AE6  000000     NOP
003AE8  88CD90     MOV W0, accel_magnitude
464:               	omega_magnitude = vector3_mag(omegagyro[0],omegagyro[1],0); // z has large drift, x and y are more stable
003AEA  80D2C1     MOV 0x1A58, W1
003AEC  80D2B0     MOV .L3, W0
003AEE  EB0100     CLR W2
003AF0  024DDA     CALL vector3_mag
003AF2  000000     NOP
003AF4  88CD80     MOV W0, omega_magnitude
465:               	if((omega_magnitude<GYRO_OFFSET_MARGIN )	&& (abs(accel_magnitude-CALIB_GRAVITY/2)<CALIB_GRAVITY/8))
003AF6  80CD81     MOV omega_magnitude, W1
003AF8  200630     MOV #0x63, W0
003AFA  508F80     SUB W1, W0, [W15]
003AFC  3E0018     BRA GTU, .L20, .LSM150
003AFE  80CD91     MOV accel_magnitude, W1
003B00  2F8000     MOV #0xF800, W0
003B02  408000     ADD W1, W0, W0
003B04  780080     MOV W0, W1
003B06  2FE010     MOV #0xFE01, W0
003B08  508F80     SUB W1, W0, [W15]
003B0A  350011     BRA LT, .L20, .LSM150
003B0C  80CD91     MOV accel_magnitude, W1
003B0E  2F8000     MOV #0xF800, W0
003B10  408000     ADD W1, W0, W0
003B12  780080     MOV W0, W1
003B14  201FF0     MOV #0x1FF, W0
003B16  508F80     SUB W1, W0, [W15]
003B18  3C000A     BRA GT, .L20, .LSM150
466:               	{
467:               		if (motion_reset_counter == 0 )
003B1A  80D6E0     MOV 0x1ADC, W0
003B1C  500FE0     SUB W0, #0x0, [W15]
003B1E  3A0003     BRA NZ, .L21, .LSM148
003B24  370008     BRA .L23, .LSM152
003B2C  370004     BRA .L23, .LSM152
468:               		{
469:               			motion_detect = 0 ;
003B20  EB0000     CLR W0
003B22  88D6F0     MOV W0, .L2
470:               		}
471:               		else
472:               		{
473:               			motion_reset_counter = motion_reset_counter - 1;
003B26  80D6E0     MOV 0x1ADC, W0
003B28  E90000     DEC W0, W0
003B2A  88D6E0     MOV W0, 0x1ADC
474:               		}
475:               	}
476:               	else
477:               	{
478:               		motion_reset_counter = 500 ;
003B2E  201F40     MOV #0x1F4, W0
003B30  88D6E0     MOV W0, 0x1ADC
479:               		motion_detect = 1 ;
003B32  200010     MOV #0x1, W0
003B34  88D6F0     MOV W0, .L2
480:               	}
481:               	if((gyro_locking_on == 1)&&(motion_detect == 0))
003B36  21E3D0     MOV #0x1E3D, W0
003B38  784010     MOV.B [W0], W0
003B3A  504FE1     SUB.B W0, #0x1, [W15]
003B3C  3A0015     BRA NZ, .L24, .LSM160
003B3E  80D6F0     MOV .L2, W0
003B40  500FE0     SUB W0, #0x0, [W15]
003B42  3A0012     BRA NZ, .L24, .LSM160
482:               	{
003B66  37000E     BRA .L19, .LSM167
483:               		accelOn = 1 ;
003B44  200010     MOV #0x1, W0
003B46  88CCE0     MOV W0, accelOn
484:               		int16_t gplane_nomalized[3] ;
485:               		vector3_normalize( gplane_nomalized , gplane ) ;
003B48  21A8C1     MOV #0x1A8C, W1
003B4A  78000E     MOV W14, W0
003B4C  024E82     CALL vector3_normalize
003B4E  000000     NOP
486:               		VectorCross(errorRP, gplane_nomalized, &rmat[6]);
003B50  21A502     MOV #0x1A50, W2
003B52  78008E     MOV W14, W1
003B54  21AA40     MOV #0x1AA4, W0
003B56  02504E     CALL VectorCross
003B58  000000     NOP
487:               		
488:               		errorYawplane[0] = 0 ;
003B5A  EB0000     CLR W0
003B5C  88D580     MOV W0, 0x1AB0
489:               		errorYawplane[1] = 0 ;
003B5E  EB0000     CLR W0
003B60  88D590     MOV W0, 0x1AB2
490:               		errorYawplane[2] = 0 ;
003B62  EB0000     CLR W0
003B64  88D5A0     MOV W0, 0x1AB4
491:               	}
492:               	else
493:               	{
494:               		accelOn = 0 ;
003B68  EB0000     CLR W0
003B6A  88CCE0     MOV W0, accelOn
495:               		errorRP[0] = 0 ;
003B6C  EB0000     CLR W0
003B6E  88D520     MOV W0, 0x1AA4
496:               		errorRP[1] = 0 ;
003B70  EB0000     CLR W0
003B72  88D530     MOV W0, 0x1AA6
497:               		errorRP[2] = 0 ;
003B74  EB0000     CLR W0
003B76  88D540     MOV W0, 0x1AA8
498:               		errorYawplane[0] = 0 ;
003B78  EB0000     CLR W0
003B7A  88D580     MOV W0, 0x1AB0
499:               		errorYawplane[1] = 0 ;
003B7C  EB0000     CLR W0
003B7E  88D590     MOV W0, 0x1AB2
500:               		errorYawplane[2] = 0 ;
003B80  EB0000     CLR W0
003B82  88D5A0     MOV W0, 0x1AB4
501:               	}
502:               
503:               }
003B84  FA8000     ULNK
003B86  060000     RETURN
504:               
505:               #define MAXIMUM_SPIN_DCM_INTEGRAL 20.0 // degrees per second
506:               
507:               static void PI_feedback(void)
508:               {
003B88  FA000A     LNK #0xA
509:               	fractional errorRPScaled[3];
510:               	int16_t kpyaw;
511:               	int16_t kprollpitch;
512:               
513:               	{
514:               		kpyaw = KPYAW;
003B8A  EB0000     CLR W0
003B8C  780F00     MOV W0, [W14]
515:               		kprollpitch = KPROLLPITCH;
003B8E  240000     MOV #0x4000, W0
003B90  980710     MOV W0, [W14+2]
516:               	}
517:               	
518:               	VectorScale(3, omegacorrP, errorYawplane, kpyaw);   // Scale gain = 2
003B92  78019E     MOV [W14], W3
003B94  21AB02     MOV #0x1AB0, W2
003B96  219701     MOV #0x1970, W1
003B98  200030     MOV #0x3, W0
003B9A  020D0E     CALL _VectorScale
003B9C  000000     NOP
519:               	VectorScale(3, errorRPScaled, errorRP, kprollpitch);// Scale gain = 2
003B9E  470064     ADD W14, #0x4, W0
003BA0  90019E     MOV [W14+2], W3
003BA2  21AA42     MOV #0x1AA4, W2
003BA4  780080     MOV W0, W1
003BA6  200030     MOV #0x3, W0
003BA8  020D0E     CALL _VectorScale
003BAA  000000     NOP
520:               	VectorAdd(3, omegacorrP, omegacorrP, errorRPScaled);
003BAC  470064     ADD W14, #0x4, W0
003BAE  780180     MOV W0, W3
003BB0  219702     MOV #0x1970, W2
003BB2  219701     MOV #0x1970, W1
003BB4  200030     MOV #0x3, W0
003BB6  020A76     CALL _VectorAdd
003BB8  000000     NOP
521:               
522:               	{	
523:               		gyroCorrectionIntegral[0].WW += (__builtin_mulsu(errorRP[0], KIROLLPITCH)>>6);
003BBA  80D372     MOV 0x1A6E, W2
003BBC  80D383     MOV .L13, W3
003BBE  80D520     MOV 0x1AA4, W0
003BC0  203331     MOV #0x333, W1
003BC2  B90001     MUL.SU W0, W1, W0
003BC4  DD0A4A     SL W1, #10, W4
003BC6  DE0046     LSR W0, #6, W0
003BC8  720000     IOR W4, W0, W0
003BCA  DE88C6     ASR W1, #6, W1
003BCC  400002     ADD W0, W2, W0
003BCE  488083     ADDC W1, W3, W1
003BD0  88D370     MOV W0, 0x1A6E
003BD2  88D381     MOV W1, .L13
524:               		gyroCorrectionIntegral[1].WW += (__builtin_mulsu(errorRP[1], KIROLLPITCH)>>6);
003BD4  80D392     MOV .L5, W2
003BD6  80D3A3     MOV 0x1A74, W3
003BD8  80D530     MOV 0x1AA6, W0
003BDA  203331     MOV #0x333, W1
003BDC  B90001     MUL.SU W0, W1, W0
003BDE  DD0A4A     SL W1, #10, W4
003BE0  DE0046     LSR W0, #6, W0
003BE2  720000     IOR W4, W0, W0
003BE4  DE88C6     ASR W1, #6, W1
003BE6  400002     ADD W0, W2, W0
003BE8  488083     ADDC W1, W3, W1
003BEA  88D390     MOV W0, .L5
003BEC  88D3A1     MOV W1, 0x1A74
525:               		gyroCorrectionIntegral[2].WW += (__builtin_mulsu(errorRP[2], KIROLLPITCH)>>6);
003BEE  80D3B2     MOV 0x1A76, W2
003BF0  80D3C3     MOV 0x1A78, W3
003BF2  80D540     MOV 0x1AA8, W0
003BF4  203331     MOV #0x333, W1
003BF6  B90001     MUL.SU W0, W1, W0
003BF8  DD0A4A     SL W1, #10, W4
003BFA  DE0046     LSR W0, #6, W0
003BFC  720000     IOR W4, W0, W0
003BFE  DE88C6     ASR W1, #6, W1
003C00  400002     ADD W0, W2, W0
003C02  488083     ADDC W1, W3, W1
003C04  88D3B0     MOV W0, 0x1A76
003C06  88D3C1     MOV W1, 0x1A78
526:               
527:               		gyroCorrectionIntegral[0].WW += (__builtin_mulsu(errorYawplane[0], KIYAW)>>6);
003C08  80D372     MOV 0x1A6E, W2
003C0A  80D383     MOV .L13, W3
003C0C  80D580     MOV 0x1AB0, W0
003C0E  200331     MOV #0x33, W1
003C10  B90001     MUL.SU W0, W1, W0
003C12  DD0A4A     SL W1, #10, W4
003C14  DE0046     LSR W0, #6, W0
003C16  720000     IOR W4, W0, W0
003C18  DE88C6     ASR W1, #6, W1
003C1A  400002     ADD W0, W2, W0
003C1C  488083     ADDC W1, W3, W1
003C1E  88D370     MOV W0, 0x1A6E
003C20  88D381     MOV W1, .L13
528:               		gyroCorrectionIntegral[1].WW += (__builtin_mulsu(errorYawplane[1], KIYAW)>>6);
003C22  80D392     MOV .L5, W2
003C24  80D3A3     MOV 0x1A74, W3
003C26  80D590     MOV 0x1AB2, W0
003C28  200331     MOV #0x33, W1
003C2A  B90001     MUL.SU W0, W1, W0
003C2C  DD0A4A     SL W1, #10, W4
003C2E  DE0046     LSR W0, #6, W0
003C30  720000     IOR W4, W0, W0
003C32  DE88C6     ASR W1, #6, W1
003C34  400002     ADD W0, W2, W0
003C36  488083     ADDC W1, W3, W1
003C38  88D390     MOV W0, .L5
003C3A  88D3A1     MOV W1, 0x1A74
529:               		gyroCorrectionIntegral[2].WW += (__builtin_mulsu(errorYawplane[2], KIYAW)>>6);
003C3C  80D3B2     MOV 0x1A76, W2
003C3E  80D3C3     MOV 0x1A78, W3
003C40  80D5A0     MOV 0x1AB4, W0
003C42  200331     MOV #0x33, W1
003C44  B90001     MUL.SU W0, W1, W0
003C46  DD0A4A     SL W1, #10, W4
003C48  DE0046     LSR W0, #6, W0
003C4A  720000     IOR W4, W0, W0
003C4C  DE88C6     ASR W1, #6, W1
003C4E  400002     ADD W0, W2, W0
003C50  488083     ADDC W1, W3, W1
003C52  88D3B0     MOV W0, 0x1A76
003C54  88D3C1     MOV W1, 0x1A78
530:               	}
531:               
532:               	omegacorrI[0] = gyroCorrectionIntegral[0]._.W1;
003C56  80D380     MOV .L13, W0
003C58  88D310     MOV W0, 0x1A62
533:               	omegacorrI[1] = gyroCorrectionIntegral[1]._.W1;
003C5A  80D3A0     MOV 0x1A74, W0
003C5C  88D320     MOV W0, 0x1A64
534:               	omegacorrI[2] = gyroCorrectionIntegral[2]._.W1;
003C5E  80D3C0     MOV 0x1A78, W0
003C60  88D330     MOV W0, 0x1A66
535:               }
003C62  FA8000     ULNK
003C64  060000     RETURN
536:               
537:               void dcm_run_imu_step(void)
538:               {
003C66  FA0000     LNK #0x0
539:               	rupdate();                  // local
003C68  07FD88     RCALL _rupdate, .LFE4, .LFB5, .LSM63
540:               	normalize();                // local
003C6A  07FEB4     RCALL _normalize, .LFE5, .LFB6, .LSM122
541:               	roll_pitch_drift();         // local
003C6C  07FF37     RCALL _roll_pitch_drift, .LFE6, .LFB7, .LSM141
542:               	PI_feedback();              // local
003C6E  07FF8C     RCALL _PI_feedback, .LFE7, .LFB8, .LSM168
543:               #ifdef LOG_VELOCITY
544:               	estimate_velocity();
545:               #endif // LOG_VELOCITY
546:               }
003C70  FA8000     ULNK
003C72  060000     RETURN
547:               float roll_angle , pitch_angle , yaw_angle ;
548:               float bill_angle_x , bill_angle_y , bill_angle_z ;
549:               float rmat_f[9];
550:               #define DEG_PER_RAD 57.296
551:               void compute_euler(void)
552:               {
003C74  FA0000     LNK #0x0
003C76  BE9F88     MOV.D W8, [W15++]
553:               	rmat_f[0]=(float)rmat[0] ;
003C78  80D220     MOV 0x1A44, W0
003C7A  DE80CF     ASR W0, #15, W1
003C7C  021092     CALL ___floatsisf
003C7E  000000     NOP
003C80  88CE60     MOV W0, rmat_f
003C82  88CE71     MOV W1, 0x19CE
554:               	rmat_f[1]=(float)rmat[1] ;
003C84  80D230     MOV .L8, W0
003C86  DE80CF     ASR W0, #15, W1
003C88  021092     CALL ___floatsisf
003C8A  000000     NOP
003C8C  88CE80     MOV W0, .L5
003C8E  88CE91     MOV W1, 0x19D2
555:               	rmat_f[2]=(float)rmat[2] ;
003C90  80D240     MOV 0x1A48, W0
003C92  DE80CF     ASR W0, #15, W1
003C94  021092     CALL ___floatsisf
003C96  000000     NOP
003C98  88CEA0     MOV W0, 0x19D4
003C9A  88CEB1     MOV W1, 0x19D6
556:               	rmat_f[3]=(float)rmat[3] ;
003C9C  80D250     MOV 0x1A4A, W0
003C9E  DE80CF     ASR W0, #15, W1
003CA0  021092     CALL ___floatsisf
003CA2  000000     NOP
003CA4  88CEC0     MOV W0, 0x19D8
003CA6  88CED1     MOV W1, 0x19DA
557:               	rmat_f[4]=(float)rmat[4] ;
003CA8  80D260     MOV 0x1A4C, W0
003CAA  DE80CF     ASR W0, #15, W1
003CAC  021092     CALL ___floatsisf
003CAE  000000     NOP
003CB0  88CEE0     MOV W0, 0x19DC
003CB2  88CEF1     MOV W1, 0x19DE
558:               	rmat_f[5]=(float)rmat[5] ;
003CB4  80D270     MOV 0x1A4E, W0
003CB6  DE80CF     ASR W0, #15, W1
003CB8  021092     CALL ___floatsisf
003CBA  000000     NOP
003CBC  88CF00     MOV W0, 0x19E0
003CBE  88CF11     MOV W1, 0x19E2
559:               	rmat_f[6]=(float)rmat[6] ;
003CC0  80D280     MOV 0x1A50, W0
003CC2  DE80CF     ASR W0, #15, W1
003CC4  021092     CALL ___floatsisf
003CC6  000000     NOP
003CC8  88CF20     MOV W0, 0x19E4
003CCA  88CF31     MOV W1, .L51
560:               	rmat_f[7]=(float)rmat[7] ;
003CCC  80D290     MOV 0x1A52, W0
003CCE  DE80CF     ASR W0, #15, W1
003CD0  021092     CALL ___floatsisf
003CD2  000000     NOP
003CD4  88CF40     MOV W0, 0x19E8
003CD6  88CF51     MOV W1, 0x19EA
561:               	rmat_f[8]=(float)rmat[8] ;
003CD8  80D2A0     MOV 0x1A54, W0
003CDA  DE80CF     ASR W0, #15, W1
003CDC  021092     CALL ___floatsisf
003CDE  000000     NOP
003CE0  88CF60     MOV W0, 0x19EC
003CE2  88CF71     MOV W1, 0x19EE
562:               
563:               	pitch_angle = DEG_PER_RAD*atan2f(-rmat_f[6],sqrtf(rmat_f[7]*rmat_f[7]+rmat_f[8]*rmat_f[8]));
003CE4  80CF44     MOV 0x19E8, W4
003CE6  80CF55     MOV 0x19EA, W5
003CE8  80CF40     MOV 0x19E8, W0
003CEA  80CF51     MOV 0x19EA, W1
003CEC  BE0100     MOV.D W0, W2
003CEE  BE0004     MOV.D W4, W0
003CF0  0211B2     CALL ___mulsf3
003CF2  000000     NOP
003CF4  BE0400     MOV.D W0, W8
003CF6  80CF64     MOV 0x19EC, W4
003CF8  80CF75     MOV 0x19EE, W5
003CFA  80CF60     MOV 0x19EC, W0
003CFC  80CF71     MOV 0x19EE, W1
003CFE  BE0100     MOV.D W0, W2
003D00  BE0004     MOV.D W4, W0
003D02  0211B2     CALL ___mulsf3
003D04  000000     NOP
003D06  BE0100     MOV.D W0, W2
003D08  BE0008     MOV.D W8, W0
003D0A  020DE8     CALL ___addsf3
003D0C  000000     NOP
003D0E  02121A     CALL _sqrtf
003D10  000000     NOP
003D12  80CF22     MOV 0x19E4, W2
003D14  80CF33     MOV .L51, W3
003D16  BE0202     MOV.D W2, W4
003D18  A2F005     BTG W5, #15
003D1A  BE0100     MOV.D W0, W2
003D1C  BE0004     MOV.D W4, W0
003D1E  020EA2     CALL _atan2f
003D20  000000     NOP
003D22  22F1B2     MOV #0x2F1B, W2
003D24  242653     MOV #0x4265, W3
003D26  0211B2     CALL ___mulsf3
003D28  000000     NOP
003D2A  88CDC0     MOV W0, pitch_angle
003D2C  88CDD1     MOV W1, 0x19BA
564:               	roll_angle = DEG_PER_RAD*atan2f(rmat_f[7],rmat_f[8]);
003D2E  80CF60     MOV 0x19EC, W0
003D30  80CF71     MOV 0x19EE, W1
003D32  80CF44     MOV 0x19E8, W4
003D34  80CF55     MOV 0x19EA, W5
003D36  BE0100     MOV.D W0, W2
003D38  BE0004     MOV.D W4, W0
003D3A  020EA2     CALL _atan2f
003D3C  000000     NOP
003D3E  22F1B2     MOV #0x2F1B, W2
003D40  242653     MOV #0x4265, W3
003D42  0211B2     CALL ___mulsf3
003D44  000000     NOP
003D46  88CDA0     MOV W0, roll_angle
003D48  88CDB1     MOV W1, 0x19B6
565:               	yaw_angle = DEG_PER_RAD*atan2f(rmat_f[3],rmat_f[0]);
003D4A  80CE60     MOV rmat_f, W0
003D4C  80CE71     MOV 0x19CE, W1
003D4E  80CEC4     MOV 0x19D8, W4
003D50  80CED5     MOV 0x19DA, W5
003D52  BE0100     MOV.D W0, W2
003D54  BE0004     MOV.D W4, W0
003D56  020EA2     CALL _atan2f
003D58  000000     NOP
003D5A  22F1B2     MOV #0x2F1B, W2
003D5C  242653     MOV #0x4265, W3
003D5E  0211B2     CALL ___mulsf3
003D60  000000     NOP
003D62  88CDE0     MOV W0, yaw_angle
003D64  88CDF1     MOV W1, 0x19BE
566:               }
003D66  BE044F     MOV.D [--W15], W8
003D68  FA8000     ULNK
003D6A  060000     RETURN
567:               
568:               void compute_bill_angles(void)
569:               {
003D6C  FA0000     LNK #0x0
570:               	rmat_f[0]=(float)rmat[0] ;
003D6E  80D220     MOV 0x1A44, W0
003D70  DE80CF     ASR W0, #15, W1
003D72  021092     CALL ___floatsisf
003D74  000000     NOP
003D76  88CE60     MOV W0, rmat_f
003D78  88CE71     MOV W1, 0x19CE
571:               	rmat_f[1]=(float)rmat[1] ;
003D7A  80D230     MOV .L8, W0
003D7C  DE80CF     ASR W0, #15, W1
003D7E  021092     CALL ___floatsisf
003D80  000000     NOP
003D82  88CE80     MOV W0, .L5
003D84  88CE91     MOV W1, 0x19D2
572:               	rmat_f[2]=(float)rmat[2] ;
003D86  80D240     MOV 0x1A48, W0
003D88  DE80CF     ASR W0, #15, W1
003D8A  021092     CALL ___floatsisf
003D8C  000000     NOP
003D8E  88CEA0     MOV W0, 0x19D4
003D90  88CEB1     MOV W1, 0x19D6
573:               	rmat_f[3]=(float)rmat[3] ;
003D92  80D250     MOV 0x1A4A, W0
003D94  DE80CF     ASR W0, #15, W1
003D96  021092     CALL ___floatsisf
003D98  000000     NOP
003D9A  88CEC0     MOV W0, 0x19D8
003D9C  88CED1     MOV W1, 0x19DA
574:               	rmat_f[4]=(float)rmat[4] ;
003D9E  80D260     MOV 0x1A4C, W0
003DA0  DE80CF     ASR W0, #15, W1
003DA2  021092     CALL ___floatsisf
003DA4  000000     NOP
003DA6  88CEE0     MOV W0, 0x19DC
003DA8  88CEF1     MOV W1, 0x19DE
575:               	rmat_f[5]=(float)rmat[5] ;
003DAA  80D270     MOV 0x1A4E, W0
003DAC  DE80CF     ASR W0, #15, W1
003DAE  021092     CALL ___floatsisf
003DB0  000000     NOP
003DB2  88CF00     MOV W0, 0x19E0
003DB4  88CF11     MOV W1, 0x19E2
576:               	rmat_f[6]=(float)rmat[6] ;
003DB6  80D280     MOV 0x1A50, W0
003DB8  DE80CF     ASR W0, #15, W1
003DBA  021092     CALL ___floatsisf
003DBC  000000     NOP
003DBE  88CF20     MOV W0, 0x19E4
003DC0  88CF31     MOV W1, .L51
577:               	rmat_f[7]=(float)rmat[7] ;
003DC2  80D290     MOV 0x1A52, W0
003DC4  DE80CF     ASR W0, #15, W1
003DC6  021092     CALL ___floatsisf
003DC8  000000     NOP
003DCA  88CF40     MOV W0, 0x19E8
003DCC  88CF51     MOV W1, 0x19EA
578:               	rmat_f[8]=(float)rmat[8] ;
003DCE  80D2A0     MOV 0x1A54, W0
003DD0  DE80CF     ASR W0, #15, W1
003DD2  021092     CALL ___floatsisf
003DD4  000000     NOP
003DD6  88CF60     MOV W0, 0x19EC
003DD8  88CF71     MOV W1, 0x19EE
579:               
580:               	bill_angle_x = DEG_PER_RAD*atan2f(rmat_f[2],rmat_f[1]);
003DDA  80CE80     MOV .L5, W0
003DDC  80CE91     MOV 0x19D2, W1
003DDE  80CEA4     MOV 0x19D4, W4
003DE0  80CEB5     MOV 0x19D6, W5
003DE2  BE0100     MOV.D W0, W2
003DE4  BE0004     MOV.D W4, W0
003DE6  020EA2     CALL _atan2f
003DE8  000000     NOP
003DEA  22F1B2     MOV #0x2F1B, W2
003DEC  242653     MOV #0x4265, W3
003DEE  0211B2     CALL ___mulsf3
003DF0  000000     NOP
003DF2  88CE00     MOV W0, bill_angle_x
003DF4  88CE11     MOV W1, 0x19C2
581:               	bill_angle_y = DEG_PER_RAD*atan2f(rmat_f[0],rmat_f[2]);
003DF6  80CEA0     MOV 0x19D4, W0
003DF8  80CEB1     MOV 0x19D6, W1
003DFA  80CE64     MOV rmat_f, W4
003DFC  80CE75     MOV 0x19CE, W5
003DFE  BE0100     MOV.D W0, W2
003E00  BE0004     MOV.D W4, W0
003E02  020EA2     CALL _atan2f
003E04  000000     NOP
003E06  22F1B2     MOV #0x2F1B, W2
003E08  242653     MOV #0x4265, W3
003E0A  0211B2     CALL ___mulsf3
003E0C  000000     NOP
003E0E  88CE20     MOV W0, bill_angle_y
003E10  88CE31     MOV W1, 0x19C6
582:               	bill_angle_z = DEG_PER_RAD*atan2f(rmat_f[1],rmat_f[0]);
003E12  80CE60     MOV rmat_f, W0
003E14  80CE71     MOV 0x19CE, W1
003E16  80CE84     MOV .L5, W4
003E18  80CE95     MOV 0x19D2, W5
003E1A  BE0100     MOV.D W0, W2
003E1C  BE0004     MOV.D W4, W0
003E1E  020EA2     CALL _atan2f
003E20  000000     NOP
003E22  22F1B2     MOV #0x2F1B, W2
003E24  242653     MOV #0x4265, W3
003E26  0211B2     CALL ___mulsf3
003E28  000000     NOP
003E2A  88CE40     MOV W0, bill_angle_z
003E2C  88CE51     MOV W1, .L65
583:               }
003E2E  FA8000     ULNK
003E30  060000     RETURN
584:               
585:               int16_t gravity_estimate[3];
586:               union longww gravity_long[3];
587:               int16_t acceleration[3];
588:               float gravity_float[3] ;
589:               float aero_force_float[3] ;
590:               float acceleration_float[3];
591:               float omegaAccum_float[3] ;
592:               float velocity ;
593:               
594:               #define MINIMUM_OMEGA_SQUARE 0.0625 // 14 degrees/second
595:               
596:               void estimate_velocity(void)
597:               {
003E32  FA0004     LNK #0x4
003E34  BE9F88     MOV.D W8, [W15++]
598:               	float omega_square ;
599:               	
600:               	omegaAccum_float[0] = (((float)omegaAccum[0])*((float)GYRO_RANGE))/(57.296*((float)16384)) ;
003E36  80D430     MOV 0x1A86, W0
003E38  DE80CF     ASR W0, #15, W1
003E3A  021092     CALL ___floatsisf
003E3C  000000     NOP
003E3E  200002     MOV #0x0, W2
003E40  2447A3     MOV #0x447A, W3
003E42  0211B2     CALL ___mulsf3
003E44  000000     NOP
003E46  22F1B2     MOV #0x2F1B, W2
003E48  249653     MOV #0x4965, W3
003E4A  020FA6     CALL ___divsf3
003E4C  000000     NOP
003E4E  88D160     MOV W0, omegaAccum_float
003E50  88D171     MOV W1, 0x1A2E
601:               	omegaAccum_float[1] = (((float)omegaAccum[1])*((float)GYRO_RANGE))/(57.296*((float)16384)) ;
003E52  80D440     MOV 0x1A88, W0
003E54  DE80CF     ASR W0, #15, W1
003E56  021092     CALL ___floatsisf
003E58  000000     NOP
003E5A  200002     MOV #0x0, W2
003E5C  2447A3     MOV #0x447A, W3
003E5E  0211B2     CALL ___mulsf3
003E60  000000     NOP
003E62  22F1B2     MOV #0x2F1B, W2
003E64  249653     MOV #0x4965, W3
003E66  020FA6     CALL ___divsf3
003E68  000000     NOP
003E6A  88D180     MOV W0, 0x1A30
003E6C  88D191     MOV W1, 0x1A32
602:               	omegaAccum_float[2] = (((float)omegaAccum[2])*((float)GYRO_RANGE))/(57.296*((float)16384)) ;
003E6E  80D450     MOV 0x1A8A, W0
003E70  DE80CF     ASR W0, #15, W1
003E72  021092     CALL ___floatsisf
003E74  000000     NOP
003E76  200002     MOV #0x0, W2
003E78  2447A3     MOV #0x447A, W3
003E7A  0211B2     CALL ___mulsf3
003E7C  000000     NOP
003E7E  22F1B2     MOV #0x2F1B, W2
003E80  249653     MOV #0x4965, W3
003E82  020FA6     CALL ___divsf3
003E84  000000     NOP
003E86  88D1A0     MOV W0, 0x1A34
003E88  88D1B1     MOV W1, 0x1A36
603:               			
604:               	gravity_long[0].WW= __builtin_mulss(rmat[6],2*CALIB_GRAVITY);
003E8A  80D280     MOV 0x1A50, W0
003E8C  220001     MOV #0x2000, W1
003E8E  B98001     MUL.SS W0, W1, W0
003E90  88CFB0     MOV W0, gravity_long
003E92  88CFC1     MOV W1, .L3
605:               	gravity_long[1].WW= __builtin_mulss(rmat[7],2*CALIB_GRAVITY);
003E94  80D290     MOV 0x1A52, W0
003E96  220001     MOV #0x2000, W1
003E98  B98001     MUL.SS W0, W1, W0
003E9A  88CFD0     MOV W0, 0x19FA
003E9C  88CFE1     MOV W1, 0x19FC
606:               	gravity_long[2].WW= __builtin_mulss(rmat[8],2*CALIB_GRAVITY);
003E9E  80D2A0     MOV 0x1A54, W0
003EA0  220001     MOV #0x2000, W1
003EA2  B98001     MUL.SS W0, W1, W0
003EA4  88CFF0     MOV W0, .L2
003EA6  88D001     MOV W1, 0x1A00
607:               	
608:               	gravity_estimate[0] = gravity_long[0]._.W1 ;
003EA8  80CFC0     MOV .L3, W0
003EAA  88CF80     MOV W0, gravity_estimate
609:               	gravity_estimate[1] = gravity_long[1]._.W1 ;
003EAC  80CFE0     MOV 0x19FC, W0
003EAE  88CF90     MOV W0, 0x19F2
610:               	gravity_estimate[2] = gravity_long[2]._.W1 ;
003EB0  80D000     MOV 0x1A00, W0
003EB2  88CFA0     MOV W0, .L52
611:               	
612:               	//note: CALIB_GRAVITY has a factor of 2 built
613:               	
614:               	gravity_float[0] = ((float)gravity_estimate[0])*(((float)19.6)/((float)CALIB_GRAVITY));
003EB4  80CF80     MOV gravity_estimate, W0
003EB6  DE80CF     ASR W0, #15, W1
003EB8  021092     CALL ___floatsisf
003EBA  000000     NOP
003EBC  2CCCD2     MOV #0xCCCD, W2
003EBE  23B9C3     MOV #0x3B9C, W3
003EC0  0211B2     CALL ___mulsf3
003EC2  000000     NOP
003EC4  88D040     MOV W0, gravity_float
003EC6  88D051     MOV W1, .L63
615:               	gravity_float[1] = ((float)gravity_estimate[1])*(((float)19.6)/((float)CALIB_GRAVITY));
003EC8  80CF90     MOV 0x19F2, W0
003ECA  DE80CF     ASR W0, #15, W1
003ECC  021092     CALL ___floatsisf
003ECE  000000     NOP
003ED0  2CCCD2     MOV #0xCCCD, W2
003ED2  23B9C3     MOV #0x3B9C, W3
003ED4  0211B2     CALL ___mulsf3
003ED6  000000     NOP
003ED8  88D060     MOV W0, 0x1A0C
003EDA  88D071     MOV W1, .L15
616:               	gravity_float[2] = ((float)gravity_estimate[2])*(((float)19.6)/((float)CALIB_GRAVITY));
003EDC  80CFA0     MOV .L52, W0
003EDE  DE80CF     ASR W0, #15, W1
003EE0  021092     CALL ___floatsisf
003EE2  000000     NOP
003EE4  2CCCD2     MOV #0xCCCD, W2
003EE6  23B9C3     MOV #0x3B9C, W3
003EE8  0211B2     CALL ___mulsf3
003EEA  000000     NOP
003EEC  88D080     MOV W0, 0x1A10
003EEE  88D091     MOV W1, 0x1A12
617:               	
618:               	aero_force_float[0] = ((float)aero_force[0])*(((float)19.6)/((float)CALIB_GRAVITY));
003EF0  80D490     MOV 0x1A92, W0
003EF2  DE80CF     ASR W0, #15, W1
003EF4  021092     CALL ___floatsisf
003EF6  000000     NOP
003EF8  2CCCD2     MOV #0xCCCD, W2
003EFA  23B9C3     MOV #0x3B9C, W3
003EFC  0211B2     CALL ___mulsf3
003EFE  000000     NOP
003F00  88D0A0     MOV W0, aero_force_float
003F02  88D0B1     MOV W1, _strchr
619:               	aero_force_float[1] = ((float)aero_force[1])*(((float)19.6)/((float)CALIB_GRAVITY));
003F04  80D4A0     MOV 0x1A94, W0
003F06  DE80CF     ASR W0, #15, W1
003F08  021092     CALL ___floatsisf
003F0A  000000     NOP
003F0C  2CCCD2     MOV #0xCCCD, W2
003F0E  23B9C3     MOV #0x3B9C, W3
003F10  0211B2     CALL ___mulsf3
003F12  000000     NOP
003F14  88D0C0     MOV W0, .L4
003F16  88D0D1     MOV W1, 0x1A1A
620:               	aero_force_float[2] = ((float)aero_force[2])*(((float)19.6)/((float)CALIB_GRAVITY));
003F18  80D4B0     MOV 0x1A96, W0
003F1A  DE80CF     ASR W0, #15, W1
003F1C  021092     CALL ___floatsisf
003F1E  000000     NOP
003F20  2CCCD2     MOV #0xCCCD, W2
003F22  23B9C3     MOV #0x3B9C, W3
003F24  0211B2     CALL ___mulsf3
003F26  000000     NOP
003F28  88D0E0     MOV W0, 0x1A1C
003F2A  88D0F1     MOV W1, .L2
621:               	
622:               	acceleration_float[0] = gravity_float[0] + aero_force_float[0] ;
003F2C  80D044     MOV gravity_float, W4
003F2E  80D055     MOV .L63, W5
003F30  80D0A0     MOV aero_force_float, W0
003F32  80D0B1     MOV _strchr, W1
003F34  BE0100     MOV.D W0, W2
003F36  BE0004     MOV.D W4, W0
003F38  020DE8     CALL ___addsf3
003F3A  000000     NOP
003F3C  88D100     MOV W0, acceleration_float
003F3E  88D111     MOV W1, 0x1A22
623:               	acceleration_float[1] = gravity_float[1] + aero_force_float[1] ;
003F40  80D064     MOV 0x1A0C, W4
003F42  80D075     MOV .L15, W5
003F44  80D0C0     MOV .L4, W0
003F46  80D0D1     MOV 0x1A1A, W1
003F48  BE0100     MOV.D W0, W2
003F4A  BE0004     MOV.D W4, W0
003F4C  020DE8     CALL ___addsf3
003F4E  000000     NOP
003F50  88D120     MOV W0, 0x1A24
003F52  88D131     MOV W1, .L5
624:               	acceleration_float[2] = gravity_float[2] + aero_force_float[2] ;
003F54  80D084     MOV 0x1A10, W4
003F56  80D095     MOV 0x1A12, W5
003F58  80D0E0     MOV 0x1A1C, W0
003F5A  80D0F1     MOV .L2, W1
003F5C  BE0100     MOV.D W0, W2
003F5E  BE0004     MOV.D W4, W0
003F60  020DE8     CALL ___addsf3
003F62  000000     NOP
003F64  88D140     MOV W0, __Vacopy
003F66  88D151     MOV W1, 0x1A2A
625:               	
626:               	omega_square = omegaAccum_float[1]*omegaAccum_float[1] + omegaAccum_float[2]*omegaAccum_float[2] ;
003F68  80D184     MOV 0x1A30, W4
003F6A  80D195     MOV 0x1A32, W5
003F6C  80D180     MOV 0x1A30, W0
003F6E  80D191     MOV 0x1A32, W1
003F70  BE0100     MOV.D W0, W2
003F72  BE0004     MOV.D W4, W0
003F74  0211B2     CALL ___mulsf3
003F76  000000     NOP
003F78  BE0400     MOV.D W0, W8
003F7A  80D1A4     MOV 0x1A34, W4
003F7C  80D1B5     MOV 0x1A36, W5
003F7E  80D1A0     MOV 0x1A34, W0
003F80  80D1B1     MOV 0x1A36, W1
003F82  BE0100     MOV.D W0, W2
003F84  BE0004     MOV.D W4, W0
003F86  0211B2     CALL ___mulsf3
003F88  000000     NOP
003F8A  BE0100     MOV.D W0, W2
003F8C  BE0008     MOV.D W8, W0
003F8E  020DE8     CALL ___addsf3
003F90  000000     NOP
003F92  BE8F00     MOV.D W0, [W14]
627:               	if (omega_square>MINIMUM_OMEGA_SQUARE )
003F94  B3C018     MOV.B #0x1, W8
003F96  200002     MOV #0x0, W2
003F98  23D803     MOV #0x3D80, W3
003F9A  BE001E     MOV.D [W14], W0
003F9C  02104C     CALL ___gesf2, ___gtsf2
003F9E  000000     NOP
003FA0  500FE0     SUB W0, #0x0, [W15]
003FA2  3C0001     BRA GT, .L31
003FA4  EB4400     CLR.B W8
003FA6  544FE0     SUB.B W8, #0x0, [W15]
003FA8  32001C     BRA Z, .L32, .LSM240
628:               	{
629:               		velocity = fabsf((omegaAccum_float[2]*acceleration_float[1]-omegaAccum_float[1]*acceleration_float[2])/omega_square);
003FAA  80D1A4     MOV 0x1A34, W4
003FAC  80D1B5     MOV 0x1A36, W5
003FAE  80D120     MOV 0x1A24, W0
003FB0  80D131     MOV .L5, W1
003FB2  BE0100     MOV.D W0, W2
003FB4  BE0004     MOV.D W4, W0
003FB6  0211B2     CALL ___mulsf3
003FB8  000000     NOP
003FBA  BE0400     MOV.D W0, W8
003FBC  80D184     MOV 0x1A30, W4
003FBE  80D195     MOV 0x1A32, W5
003FC0  80D140     MOV __Vacopy, W0
003FC2  80D151     MOV 0x1A2A, W1
003FC4  BE0100     MOV.D W0, W2
003FC6  BE0004     MOV.D W4, W0
003FC8  0211B2     CALL ___mulsf3
003FCA  000000     NOP
003FCC  BE0100     MOV.D W0, W2
003FCE  BE0008     MOV.D W8, W0
003FD0  020DE6     CALL ___subsf3
003FD2  000000     NOP
003FD4  BE011E     MOV.D [W14], W2
003FD6  020FA6     CALL ___divsf3
003FD8  000000     NOP
003FDA  A1F001     BCLR W1, #15
003FDC  88D1C0     MOV W0, velocity
003FDE  88D1D1     MOV W1, 0x1A3A
003FE0  370003     BRA .L30, .LSM241
630:               	}
631:               	else
632:               	{
633:               		velocity = 0 ;
003FE2  B80060     MUL.UU W0, #0, W0
003FE4  88D1C0     MOV W0, velocity
003FE6  88D1D1     MOV W1, 0x1A3A
634:               	}
635:               	
636:               }
003FE8  BE044F     MOV.D [--W15], W8
003FEA  FA8000     ULNK
003FEC  060000     RETURN
637:               
---  C:/Users/bill/Desktop/git_repos/git_luge/libDCM/matrix_vector_32_bit.c  ----------------------------
1:                 
2:                 
3:                 //#include "libUDB.h"
4:                 //#include "oscillator.h"
5:                 //#include "interrupt.h"
6:                 //#include "heartbeat.h"
7:                 #include "../libUDB/udbTypes.h"
8:                 #include "../libDCM/matrix_vector_32_bit.h"
9:                 
10:                
11:                int32_t fract_32_mpy( int32_t x , int32_t y )
12:                {
006F84  FA0016     LNK #0x16
006F86  980770     MOV W0, [W14+14]
006F88  980F01     MOV W1, [W14+16]
006F8A  980F12     MOV W2, [W14+18]
006F8C  980F23     MOV W3, [W14+20]
13:                	union longww result ;
14:                	union longww arg1 , arg2 ;
15:                	arg1.WW = x ;
006F8E  90007E     MOV [W14+14], W0
006F90  90088E     MOV [W14+16], W1
006F92  980730     MOV W0, [W14+6]
006F94  980741     MOV W1, [W14+8]
16:                	arg2.WW = y ;
006F96  90081E     MOV [W14+18], W0
006F98  9008AE     MOV [W14+20], W1
006F9A  980750     MOV W0, [W14+10]
006F9C  980761     MOV W1, [W14+12]
17:                	int16_t sign = 1 ;
006F9E  200010     MOV #0x1, W0
006FA0  780F00     MOV W0, [W14]
18:                	if ( arg1.WW < 0 )
006FA2  90003E     MOV [W14+6], W0
006FA4  9000CE     MOV [W14+8], W1
006FA6  500FE0     SUB W0, #0x0, [W15]
006FA8  588FE0     SUBB W1, #0x0, [W15]
006FAA  3D0007     BRA GE, .L2, .LSM7
19:                	{
20:                		sign = - sign ;
006FAC  EA0F1E     NEG [W14], [W14]
21:                		arg1.WW = - (arg1.WW ) ;
006FAE  90003E     MOV [W14+6], W0
006FB0  9000CE     MOV [W14+8], W1
006FB2  100060     SUBR W0, #0x0, W0
006FB4  1880E0     SUBBR W1, #0x0, W1
006FB6  980730     MOV W0, [W14+6]
006FB8  980741     MOV W1, [W14+8]
22:                	}
23:                	if ( arg2.WW < 0)
006FBA  90005E     MOV [W14+10], W0
006FBC  9000EE     MOV [W14+12], W1
006FBE  500FE0     SUB W0, #0x0, [W15]
006FC0  588FE0     SUBB W1, #0x0, [W15]
006FC2  3D0007     BRA GE, .L3, .LSM10
24:                	{
25:                		sign = - sign ;
006FC4  EA0F1E     NEG [W14], [W14]
26:                		arg2.WW = - (arg2.WW ) ;
006FC6  90005E     MOV [W14+10], W0
006FC8  9000EE     MOV [W14+12], W1
006FCA  100060     SUBR W0, #0x0, W0
006FCC  1880E0     SUBBR W1, #0x0, W1
006FCE  980750     MOV W0, [W14+10]
006FD0  980761     MOV W1, [W14+12]
27:                	}
28:                	
29:                	result.WW = __builtin_muluu( arg1._.W1 , arg2._.W1 )
006FD2  90006E     MOV [W14+12], W0
006FD4  780080     MOV W0, W1
006FD6  90004E     MOV [W14+8], W0
006FD8  B80101     MUL.UU W0, W1, W2
006FFA  980710     MOV W0, [W14+2]
006FFC  980721     MOV W1, [W14+4]
30:                			+  (__builtin_muluu( arg1._.W1 , arg2._.W0 )>>16 )
006FDA  90005E     MOV [W14+10], W0
006FDC  780080     MOV W0, W1
006FDE  90004E     MOV [W14+8], W0
006FE0  B80001     MUL.UU W0, W1, W0
006FE2  DE0840     LSR W1, #0, W0
006FE4  200001     MOV #0x0, W1
006FE6  400102     ADD W0, W2, W2
006FE8  488183     ADDC W1, W3, W3
31:                			+  (__builtin_muluu( arg1._.W0 , arg2._.W1 )>>16 ) ;
006FEA  90006E     MOV [W14+12], W0
006FEC  780080     MOV W0, W1
006FEE  90003E     MOV [W14+6], W0
006FF0  B80001     MUL.UU W0, W1, W0
006FF2  DE0840     LSR W1, #0, W0
006FF4  200001     MOV #0x0, W1
006FF6  400002     ADD W0, W2, W0
006FF8  488083     ADDC W1, W3, W1
32:                	
33:                	if ( sign < 0)
006FFE  78001E     MOV [W14], W0
007000  500FE0     SUB W0, #0x0, [W15]
007002  3D0006     BRA GE, .L4, .LSM16
34:                	{
35:                		result.WW = - ( result.WW ) ;
007004  90001E     MOV [W14+2], W0
007006  9000AE     MOV [W14+4], W1
007008  100060     SUBR W0, #0x0, W0
00700A  1880E0     SUBBR W1, #0x0, W1
00700C  980710     MOV W0, [W14+2]
00700E  980721     MOV W1, [W14+4]
36:                	}
37:                	return result.WW ;
007010  90001E     MOV [W14+2], W0
007012  9000AE     MOV [W14+4], W1
38:                }
007014  FA8000     ULNK
007016  060000     RETURN
39:                
40:                void cross_product_32(union longww result[], union longww vectorx[] ,union longww vectory[] )
41:                {
007018  FA0006     LNK #0x6
00701A  BE9F88     MOV.D W8, [W15++]
00701C  781F8A     MOV W10, [W15++]
00701E  780F00     MOV W0, [W14]
007020  980711     MOV W1, [W14+2]
007022  980722     MOV W2, [W14+4]
42:                	result[0].WW = ( fract_32_mpy(vectorx[1].WW,vectory[2].WW)
007024  90002E     MOV [W14+4], W0
007026  400068     ADD W0, #0x8, W0
007028  BE0010     MOV.D [W0], W0
00702A  90011E     MOV [W14+2], W2
00702C  410164     ADD W2, #0x4, W2
00702E  BE0212     MOV.D [W2], W4
007030  BE0100     MOV.D W0, W2
007032  BE0004     MOV.D W4, W0
007034  07FFA7     RCALL fract_32_mpy
007036  BE0400     MOV.D W0, W8
00704E  78011E     MOV [W14], W2
007050  BE8900     MOV.D W0, [W2]
43:                			- fract_32_mpy(vectorx[2].WW,vectory[1].WW));
007038  90002E     MOV [W14+4], W0
00703A  400064     ADD W0, #0x4, W0
00703C  BE0010     MOV.D [W0], W0
00703E  90011E     MOV [W14+2], W2
007040  410168     ADD W2, #0x8, W2
007042  BE0212     MOV.D [W2], W4
007044  BE0100     MOV.D W0, W2
007046  BE0004     MOV.D W4, W0
007048  07FF9D     RCALL fract_32_mpy
00704A  540000     SUB W8, W0, W0
00704C  5C8081     SUBB W9, W1, W1
44:                
45:                	result[1].WW = ( fract_32_mpy(vectorx[2].WW,vectory[0].WW)
007052  78001E     MOV [W14], W0
007054  400564     ADD W0, #0x4, W10
007056  90002E     MOV [W14+4], W0
007058  BE0010     MOV.D [W0], W0
00705A  90011E     MOV [W14+2], W2
00705C  410168     ADD W2, #0x8, W2
00705E  BE0212     MOV.D [W2], W4
007060  BE0100     MOV.D W0, W2
007062  BE0004     MOV.D W4, W0
007064  07FF8F     RCALL fract_32_mpy
007066  BE0400     MOV.D W0, W8
00707C  BE8D00     MOV.D W0, [W10]
46:                			- fract_32_mpy(vectorx[0].WW,vectory[2].WW));
007068  90002E     MOV [W14+4], W0
00706A  400068     ADD W0, #0x8, W0
00706C  BE0010     MOV.D [W0], W0
00706E  90011E     MOV [W14+2], W2
007070  BE0212     MOV.D [W2], W4
007072  BE0100     MOV.D W0, W2
007074  BE0004     MOV.D W4, W0
007076  07FF86     RCALL fract_32_mpy
007078  540000     SUB W8, W0, W0
00707A  5C8081     SUBB W9, W1, W1
47:                
48:                	result[2].WW = ( fract_32_mpy(vectorx[0].WW,vectory[1].WW)
00707E  78001E     MOV [W14], W0
007080  400568     ADD W0, #0x8, W10
007082  90002E     MOV [W14+4], W0
007084  400064     ADD W0, #0x4, W0
007086  BE0010     MOV.D [W0], W0
007088  90011E     MOV [W14+2], W2
00708A  BE0212     MOV.D [W2], W4
00708C  BE0100     MOV.D W0, W2
00708E  BE0004     MOV.D W4, W0
007090  07FF79     RCALL fract_32_mpy
007092  BE0400     MOV.D W0, W8
0070A8  BE8D00     MOV.D W0, [W10]
49:                			- fract_32_mpy(vectorx[1].WW,vectory[0].WW));
007094  90002E     MOV [W14+4], W0
007096  BE0010     MOV.D [W0], W0
007098  90011E     MOV [W14+2], W2
00709A  410164     ADD W2, #0x4, W2
00709C  BE0212     MOV.D [W2], W4
00709E  BE0100     MOV.D W0, W2
0070A0  BE0004     MOV.D W4, W0
0070A2  07FF70     RCALL fract_32_mpy
0070A4  540000     SUB W8, W0, W0
0070A6  5C8081     SUBB W9, W1, W1
50:                }
0070AA  78054F     MOV [--W15], W10
0070AC  BE044F     MOV.D [--W15], W8
0070AE  FA8000     ULNK
0070B0  060000     RETURN
51:                
52:                int32_t VectorDotProduct_32( int32_t vector1 , int32_t vector2 )
53:                {
0070B2  FA0008     LNK #0x8
0070B4  BE8F00     MOV.D W0, [W14]
0070B6  980722     MOV W2, [W14+4]
0070B8  980733     MOV W3, [W14+6]
54:                	return 0 ;
0070BA  B80060     MUL.UU W0, #0, W0
55:                }
0070BC  FA8000     ULNK
0070BE  060000     RETURN
56:                
57:                int32_t row_col_dot_fract_32( int32_t row[], int32_t col[], int16_t row_index , int16_t col_index )
58:                {
0070C0  FA000C     LNK #0xC
0070C2  BE9F88     MOV.D W8, [W15++]
0070C4  980720     MOV W0, [W14+4]
0070C6  980731     MOV W1, [W14+6]
0070C8  980742     MOV W2, [W14+8]
0070CA  980753     MOV W3, [W14+10]
59:                	int32_t result ;
60:                	result = fract_32_mpy(row[row_index],col[col_index])
0070CC  90005E     MOV [W14+10], W0
0070CE  DD0042     SL W0, #2, W0
0070D0  9000BE     MOV [W14+6], W1
0070D2  408000     ADD W1, W0, W0
0070D4  BE0010     MOV.D [W0], W0
0070D6  90014E     MOV [W14+8], W2
0070D8  DD1142     SL W2, #2, W2
0070DA  9001AE     MOV [W14+4], W3
0070DC  418102     ADD W3, W2, W2
0070DE  BE0212     MOV.D [W2], W4
0070E0  BE0100     MOV.D W0, W2
0070E2  BE0004     MOV.D W4, W0
0070E4  07FF4F     RCALL fract_32_mpy
0070E6  BE0400     MOV.D W0, W8
007128  441F00     ADD W8, W0, [W14++]
00712A  4C9701     ADDC W9, W1, [W14--]
61:                			+fract_32_mpy(row[row_index+1],col[col_index+3])
0070E8  90005E     MOV [W14+10], W0
0070EA  400063     ADD W0, #0x3, W0
0070EC  DD0042     SL W0, #2, W0
0070EE  9000BE     MOV [W14+6], W1
0070F0  408000     ADD W1, W0, W0
0070F2  BE0010     MOV.D [W0], W0
0070F4  90014E     MOV [W14+8], W2
0070F6  E80102     INC W2, W2
0070F8  DD1142     SL W2, #2, W2
0070FA  9001AE     MOV [W14+4], W3
0070FC  418102     ADD W3, W2, W2
0070FE  BE0212     MOV.D [W2], W4
007100  BE0100     MOV.D W0, W2
007102  BE0004     MOV.D W4, W0
007104  07FF3F     RCALL fract_32_mpy
007106  400408     ADD W0, W8, W8
007108  488489     ADDC W1, W9, W9
62:                			+fract_32_mpy(row[row_index+2],col[col_index+6]) ;
00710A  90005E     MOV [W14+10], W0
00710C  400066     ADD W0, #0x6, W0
00710E  DD0042     SL W0, #2, W0
007110  9000BE     MOV [W14+6], W1
007112  408000     ADD W1, W0, W0
007114  BE0010     MOV.D [W0], W0
007116  90014E     MOV [W14+8], W2
007118  E88102     INC2 W2, W2
00711A  DD1142     SL W2, #2, W2
00711C  9001AE     MOV [W14+4], W3
00711E  418102     ADD W3, W2, W2
007120  BE0212     MOV.D [W2], W4
007122  BE0100     MOV.D W0, W2
007124  BE0004     MOV.D W4, W0
007126  07FF2E     RCALL fract_32_mpy
63:                	return result ;
00712C  BE001E     MOV.D [W14], W0
64:                }
00712E  BE044F     MOV.D [--W15], W8
007130  FA8000     ULNK
007132  060000     RETURN
65:                
66:                
67:                
68:                void matrix_mpy_fract_32( int32_t dest[] , int32_t arg1[] , int32_t arg2[] )
69:                {
007134  FA0006     LNK #0x6
007136  781F88     MOV W8, [W15++]
007138  780F00     MOV W0, [W14]
00713A  980711     MOV W1, [W14+2]
00713C  980722     MOV W2, [W14+4]
70:                	dest[0] = row_col_dot_fract_32(arg1,arg2,0,0);
00713E  EB0180     CLR W3
007140  EB0100     CLR W2
007142  9000AE     MOV [W14+4], W1
007144  90001E     MOV [W14+2], W0
007146  07FFBC     RCALL row_col_dot_fract_32
007148  78011E     MOV [W14], W2
00714A  BE8900     MOV.D W0, [W2]
71:                	dest[1] = row_col_dot_fract_32(arg1,arg2,0,1);
00714C  78001E     MOV [W14], W0
00714E  400464     ADD W0, #0x4, W8
007150  200013     MOV #0x1, W3
007152  EB0100     CLR W2
007154  9000AE     MOV [W14+4], W1
007156  90001E     MOV [W14+2], W0
007158  07FFB3     RCALL row_col_dot_fract_32
00715A  BE8C00     MOV.D W0, [W8]
72:                	dest[2] = row_col_dot_fract_32(arg1,arg2,0,2);
00715C  78001E     MOV [W14], W0
00715E  400468     ADD W0, #0x8, W8
007160  200023     MOV #0x2, W3
007162  EB0100     CLR W2
007164  9000AE     MOV [W14+4], W1
007166  90001E     MOV [W14+2], W0
007168  07FFAB     RCALL row_col_dot_fract_32
00716A  BE8C00     MOV.D W0, [W8]
73:                	dest[3] = row_col_dot_fract_32(arg1,arg2,3,0);
00716C  78001E     MOV [W14], W0
00716E  40046C     ADD W0, #0xC, W8
007170  EB0180     CLR W3
007172  200032     MOV #0x3, W2
007174  9000AE     MOV [W14+4], W1
007176  90001E     MOV [W14+2], W0
007178  07FFA3     RCALL row_col_dot_fract_32
00717A  BE8C00     MOV.D W0, [W8]
74:                	dest[4] = row_col_dot_fract_32(arg1,arg2,3,1);
00717C  78001E     MOV [W14], W0
00717E  400470     ADD W0, #0x10, W8
007180  200013     MOV #0x1, W3
007182  200032     MOV #0x3, W2
007184  9000AE     MOV [W14+4], W1
007186  90001E     MOV [W14+2], W0
007188  07FF9B     RCALL row_col_dot_fract_32
00718A  BE8C00     MOV.D W0, [W8]
75:                	dest[5] = row_col_dot_fract_32(arg1,arg2,3,2);
00718C  78001E     MOV [W14], W0
00718E  400474     ADD W0, #0x14, W8
007190  200023     MOV #0x2, W3
007192  200032     MOV #0x3, W2
007194  9000AE     MOV [W14+4], W1
007196  90001E     MOV [W14+2], W0
007198  07FF93     RCALL row_col_dot_fract_32
00719A  BE8C00     MOV.D W0, [W8]
76:                	dest[6] = row_col_dot_fract_32(arg1,arg2,6,0);
00719C  78001E     MOV [W14], W0
00719E  400478     ADD W0, #0x18, W8
0071A0  EB0180     CLR W3
0071A2  200062     MOV #0x6, W2
0071A4  9000AE     MOV [W14+4], W1
0071A6  90001E     MOV [W14+2], W0
0071A8  07FF8B     RCALL row_col_dot_fract_32
0071AA  BE8C00     MOV.D W0, [W8]
77:                	dest[7] = row_col_dot_fract_32(arg1,arg2,6,1);
0071AC  78001E     MOV [W14], W0
0071AE  40047C     ADD W0, #0x1C, W8
0071B0  200013     MOV #0x1, W3
0071B2  200062     MOV #0x6, W2
0071B4  9000AE     MOV [W14+4], W1
0071B6  90001E     MOV [W14+2], W0
0071B8  07FF83     RCALL row_col_dot_fract_32
0071BA  BE8C00     MOV.D W0, [W8]
78:                	dest[8] = row_col_dot_fract_32(arg1,arg2,6,2);
0071BC  200200     MOV #0x20, W0
0071BE  40041E     ADD W0, [W14], W8
0071C0  200023     MOV #0x2, W3
0071C2  200062     MOV #0x6, W2
0071C4  9000AE     MOV [W14+4], W1
0071C6  90001E     MOV [W14+2], W0
0071C8  07FF7B     RCALL row_col_dot_fract_32
0071CA  BE8C00     MOV.D W0, [W8]
79:                }
0071CC  78044F     MOV [--W15], W8
0071CE  FA8000     ULNK
0071D0  060000     RETURN
80:                
---  C:/Users/bill/Desktop/git_repos/git_luge/libDCM/mathlibNAV.c  --------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "dcmTypes.h"
23:                #include "mathlibNAV.h"
24:                #if (WIN == 1 || NIX == 1)
25:                #include "../Tools/MatrixPilot-SIL/SIL-udb.h"
26:                #endif // (WIN == 1 || NIX == 1)
27:                
28:                //  math libraray
29:                
30:                #define RADIANTOCIRCULAR 10430
31:                
32:                //  sine table for angles from zero to pi/2 with an increment of pi/128 radian.
33:                //  sine values are multiplied by 2**14
34:                const int16_t sintab[] = { 0,
35:                	402,   804,   1205,  1606,  2006,  2404,  2801,   3196,  3590,  3981,
36:                	4370,  4756,  5139,  5520,  5897,  6270,  6639,   7005,  7366,  7723,
37:                	8076,  8423,  8765,  9102,  9434,  9760,  10080, 10394, 10702, 11003,
38:                	11297, 11585, 11866, 12140, 12406, 12665, 12916, 13160, 13395, 13623,
39:                	13842, 14053, 14256, 14449, 14635, 14811, 14978, 15137, 15286, 15426,
40:                	15557, 15679, 15791, 15893, 15986, 16069, 16143, 16207, 16261, 16305,
41:                	16340, 16364, 16379, 16384
42:                };
43:                
44:                
45:                int16_t sine(int8_t angle)
46:                {
0048B4  FA0004     LNK #0x4
0048B6  984720     MOV.B W0, [W14+2]
47:                	// returns(2**14)*sine(angle), angle measured in units of pi/128 radians
48:                	int16_t angle_int;
49:                	angle_int = angle;
0048B8  90402E     MOV.B [W14+2], W0
0048BA  FB0000     SE W0, W0
0048BC  780F00     MOV W0, [W14]
50:                
51:                	if (angle_int >= 0)
0048BE  78001E     MOV [W14], W0
0048C0  500FE0     SUB W0, #0x0, [W15]
0048C2  350011     BRA LT, .L2, .LSM6
52:                	{
53:                		if (angle_int > 64)
0048C4  200400     MOV #0x40, W0
0048C6  78009E     MOV [W14], W1
0048C8  508F80     SUB W1, W0, [W15]
0048CA  340007     BRA LE, .L3, .LSM5
54:                		{
55:                			return (sintab[128-angle_int]);
0048CC  200800     MOV #0x80, W0
0048CE  50001E     SUB W0, [W14], W0
0048D0  400080     ADD W0, W0, W1
0048D2  2B3AC0     MOV #0xB3AC, W0
0048D4  408000     ADD W1, W0, W0
0048D6  780010     MOV [W0], W0
0048D8  370019     BRA .L4, .LSM10
56:                		}
57:                		else
58:                		{
59:                			return (sintab[angle_int]);
0048DA  78001E     MOV [W14], W0
0048DC  400080     ADD W0, W0, W1
0048DE  2B3AC0     MOV #0xB3AC, W0
0048E0  408000     ADD W1, W0, W0
0048E2  780010     MOV [W0], W0
0048E4  370013     BRA .L4, .LSM10
60:                		}
61:                	}
62:                	else
63:                	{
64:                		angle_int = -angle_int;
0048E6  EA0F1E     NEG [W14], [W14]
65:                		if (angle_int > 64)
0048E8  200400     MOV #0x40, W0
0048EA  78009E     MOV [W14], W1
0048EC  508F80     SUB W1, W0, [W15]
0048EE  340008     BRA LE, .L5, .LSM9
66:                		{
67:                			return (-sintab[128 - angle_int]);
0048F0  200800     MOV #0x80, W0
0048F2  50001E     SUB W0, [W14], W0
0048F4  400080     ADD W0, W0, W1
0048F6  2B3AC0     MOV #0xB3AC, W0
0048F8  408000     ADD W1, W0, W0
0048FA  780010     MOV [W0], W0
0048FC  EA0000     NEG W0, W0
0048FE  370006     BRA .L4, .LSM10
68:                		}
69:                		else
70:                		{
71:                			return (-sintab[angle_int]);
004900  78001E     MOV [W14], W0
004902  400080     ADD W0, W0, W1
004904  2B3AC0     MOV #0xB3AC, W0
004906  408000     ADD W1, W0, W0
004908  780010     MOV [W0], W0
00490A  EA0000     NEG W0, W0
72:                		}
73:                	}
74:                }
00490C  FA8000     ULNK
00490E  060000     RETURN
75:                
76:                int8_t arcsine(int16_t y)  // arcsine takes the y coordinate of an x,y point and returns an angle
77:                {
004910  FA0006     LNK #0x6
004912  781F88     MOV W8, [W15++]
004914  980720     MOV W0, [W14+4]
78:                	// returns the inverse sine of y
79:                	// y is in Q2.14 format, 16384 is maximum value
80:                	// returned angle is a byte circular
81:                	int8_t angle = 32;
004916  B3C200     MOV.B #0x20, W0
004918  984730     MOV.B W0, [W14+3]
82:                	int8_t doubleangle = 64;
00491A  B3C400     MOV.B #0x40, W0
00491C  784F00     MOV.B W0, [W14]
83:                	int8_t step = 32;
00491E  B3C200     MOV.B #0x20, W0
004920  984710     MOV.B W0, [W14+1]
84:                	int8_t sign;
85:                
86:                	if (y > 0)
004922  90002E     MOV [W14+4], W0
004924  500FE0     SUB W0, #0x0, [W15]
004926  340003     BRA LE, .L7, .LSM17
87:                	{
88:                		sign = 1;
004928  B3C010     MOV.B #0x1, W0
00492A  984720     MOV.B W0, [W14+2]
00492C  370005     BRA .L8, .LSM19
89:                	}
90:                	else
91:                	{
92:                		sign = - 1;
00492E  EBC000     SETM.B W0
004930  984720     MOV.B W0, [W14+2]
93:                		y = - y;
004932  90002E     MOV [W14+4], W0
004934  EA0000     NEG W0, W0
004936  980720     MOV W0, [W14+4]
94:                	}
95:                	if (y == 16384)
004938  9000AE     MOV [W14+4], W1
00493A  240000     MOV #0x4000, W0
00493C  508F80     SUB W1, W0, [W15]
00493E  3A002A     BRA NZ, .L11, .LSM28
96:                	{
97:                		return sign * 64;
004940  90402E     MOV.B [W14+2], W0
004942  200061     MOV #0x6, W1
004944  DD0001     SL W0, W1, W0
004946  370031     BRA .L10, .LSM30
98:                	}
99:                	while (step > 0)
004994  90401E     MOV.B [W14+1], W0
004996  504FE0     SUB.B W0, #0x0, [W15]
004998  3CFFD7     BRA GT, .L15, .LSM21
100:               	{
101:               		angle = doubleangle >> 1;
004948  FB001E     SE [W14], W0
00494A  D18000     ASR W0, W0
00494C  984730     MOV.B W0, [W14+3]
102:               		if (y == sine(angle))
00494E  90403E     MOV.B [W14+3], W0
004950  07FFB1     RCALL sine
004952  9000AE     MOV [W14+4], W1
004954  500F81     SUB W0, W1, [W15]
004956  3A0006     BRA NZ, .L12, .LSM24
103:               		{
104:               			return sign * angle;
004958  9040AE     MOV.B [W14+2], W1
00495A  90403E     MOV.B [W14+3], W0
00495C  B98800     MUL.SS W1, W0, W0
00495E  780000     MOV W0, W0
004960  784000     MOV.B W0, W0
004962  370023     BRA .L10, .LSM30
105:               		}
106:               		else if (y > ((sine(angle) + sine(angle - 1)) >> 1))
004964  90403E     MOV.B [W14+3], W0
004966  07FFA6     RCALL sine
004968  780400     MOV W0, W8
00496A  90403E     MOV.B [W14+3], W0
00496C  E94000     DEC.B W0, W0
00496E  07FFA2     RCALL sine
004970  440000     ADD W8, W0, W0
004972  D18080     ASR W0, W1
004974  90002E     MOV [W14+4], W0
004976  508F80     SUB W1, W0, [W15]
004978  3D0005     BRA GE, .L13, .LSM26
107:               		{
108:               			doubleangle += step;
00497A  78409E     MOV.B [W14], W1
00497C  90401E     MOV.B [W14+1], W0
00497E  40C000     ADD.B W1, W0, W0
004980  784F00     MOV.B W0, [W14]
004982  370004     BRA .L14, .LSM27
109:               		}
110:               		else
111:               		{
112:               			doubleangle -= step;
004984  78409E     MOV.B [W14], W1
004986  90401E     MOV.B [W14+1], W0
004988  50C000     SUB.B W1, W0, W0
00498A  784F00     MOV.B W0, [W14]
113:               		}
114:               		step = step >> 1;
00498C  90401E     MOV.B [W14+1], W0
00498E  FB0000     SE W0, W0
004990  D18000     ASR W0, W0
004992  984710     MOV.B W0, [W14+1]
115:               	}
116:               	return sign * (doubleangle >> 1);
00499A  FB001E     SE [W14], W0
00499C  D18000     ASR W0, W0
00499E  784000     MOV.B W0, W0
0049A0  784080     MOV.B W0, W1
0049A2  90402E     MOV.B [W14+2], W0
0049A4  B98800     MUL.SS W1, W0, W0
0049A6  780000     MOV W0, W0
0049A8  784000     MOV.B W0, W0
117:               }
0049AA  78044F     MOV [--W15], W8
0049AC  FA8000     ULNK
0049AE  060000     RETURN
118:               
119:               int16_t cosine(int8_t angle)
120:               {
0049B0  FA0002     LNK #0x2
0049B2  784F00     MOV.B W0, [W14]
121:               	return (sine(angle+64));
0049B4  78401E     MOV.B [W14], W0
0049B6  B04400     ADD.B #0x40, W0
0049B8  07FF7D     RCALL sine
122:               }
0049BA  FA8000     ULNK
0049BC  060000     RETURN
123:               
124:               void rotate_2D_vector_by_vector(int16_t vector[2], int16_t rotate[2])
125:               {
0049BE  FA000C     LNK #0xC
0049C0  980740     MOV W0, [W14+8]
0049C2  980751     MOV W1, [W14+10]
126:               	// rotate the vector by the implicit angle of rotate
127:               	// vector[0] is x, vector[1] is y
128:               	// rotate is RMAX*[ cosine(theta), sine(theta) ], theta is the desired rotation angle
129:               	// upon exit, the vector [ x, y ] will be rotated by the angle theta.
130:               	// theta is positive in the counter clockwise direction.
131:               	// This routine can also be used to do a complex multiply, with 1/RMAX scaling,
132:               	// and where vector and rotate are viewed as complex numbers
133:               	int16_t newx, newy;
134:               	union longww accum;
135:               
136:               	accum.WW = ((__builtin_mulss(rotate[0], vector[0]) - __builtin_mulss(rotate[1], vector[1])) << 2);
0049C4  90004E     MOV [W14+8], W0
0049C6  780090     MOV [W0], W1
0049C8  90005E     MOV [W14+10], W0
0049CA  780010     MOV [W0], W0
0049CC  B98101     MUL.SS W0, W1, W2
0049CE  90004E     MOV [W14+8], W0
0049D0  E88000     INC2 W0, W0
0049D2  780090     MOV [W0], W1
0049D4  90005E     MOV [W14+10], W0
0049D6  E88000     INC2 W0, W0
0049D8  780010     MOV [W0], W0
0049DA  B98001     MUL.SS W0, W1, W0
0049DC  510100     SUB W2, W0, W2
0049DE  598181     SUBB W3, W1, W3
0049E0  DD1842     SL W3, #2, W0
0049E2  DE10CE     LSR W2, #14, W1
0049E4  700081     IOR W0, W1, W1
0049E6  DD1042     SL W2, #2, W0
0049E8  980720     MOV W0, [W14+4]
0049EA  980731     MOV W1, [W14+6]
137:               	newx = accum._.W1;
0049EC  90003E     MOV [W14+6], W0
0049EE  780F00     MOV W0, [W14]
138:               	accum.WW = ((__builtin_mulss(rotate[1], vector[0]) + __builtin_mulss(rotate[0], vector[1])) <<2 );
0049F0  90004E     MOV [W14+8], W0
0049F2  780090     MOV [W0], W1
0049F4  90005E     MOV [W14+10], W0
0049F6  E88000     INC2 W0, W0
0049F8  780010     MOV [W0], W0
0049FA  B98101     MUL.SS W0, W1, W2
0049FC  90004E     MOV [W14+8], W0
0049FE  E88000     INC2 W0, W0
004A00  780090     MOV [W0], W1
004A02  90005E     MOV [W14+10], W0
004A04  780010     MOV [W0], W0
004A06  B98001     MUL.SS W0, W1, W0
004A08  400102     ADD W0, W2, W2
004A0A  488183     ADDC W1, W3, W3
004A0C  DD1842     SL W3, #2, W0
004A0E  DE10CE     LSR W2, #14, W1
004A10  700081     IOR W0, W1, W1
004A12  DD1042     SL W2, #2, W0
004A14  980720     MOV W0, [W14+4]
004A16  980731     MOV W1, [W14+6]
139:               	newy = accum._.W1;
004A18  9000BE     MOV [W14+6], W1
004A1A  980711     MOV W1, [W14+2]
140:               	vector[0] = newx;
004A1C  90004E     MOV [W14+8], W0
004A1E  78081E     MOV [W14], [W0]
141:               	vector[1] = newy;
004A20  90004E     MOV [W14+8], W0
004A22  E88000     INC2 W0, W0
004A24  90009E     MOV [W14+2], W1
004A26  780801     MOV W1, [W0]
142:               }
004A28  FA8000     ULNK
004A2A  060000     RETURN
143:               
144:               void rotate_2D_long_vector_by_vector(int32_t vector[2], int16_t rotate[2])
145:               {
004A2C  FA000C     LNK #0xC
004A2E  BE9F88     MOV.D W8, [W15++]
004A30  980740     MOV W0, [W14+8]
004A32  980751     MOV W1, [W14+10]
146:               	// same as rotate_2D_vector_by_vector, except the first vector is 32 bits
147:               	int32_t newx, newy;
148:               
149:               	newx = long_scale(vector[0], rotate[0]) - long_scale(vector[1], rotate[1]);
004A34  90005E     MOV [W14+10], W0
004A36  780110     MOV [W0], W2
004A38  90004E     MOV [W14+8], W0
004A3A  BE0010     MOV.D [W0], W0
004A3C  070279     RCALL long_scale
004A3E  BE0400     MOV.D W0, W8
004A40  90005E     MOV [W14+10], W0
004A42  E88000     INC2 W0, W0
004A44  780110     MOV [W0], W2
004A46  90004E     MOV [W14+8], W0
004A48  400064     ADD W0, #0x4, W0
004A4A  BE0010     MOV.D [W0], W0
004A4C  070271     RCALL long_scale
004A4E  541F00     SUB W8, W0, [W14++]
004A50  5C9701     SUBB W9, W1, [W14--]
150:               	newy = long_scale(vector[0], rotate[1]) + long_scale(vector[1], rotate[0]);
004A52  90005E     MOV [W14+10], W0
004A54  E88000     INC2 W0, W0
004A56  780110     MOV [W0], W2
004A58  90004E     MOV [W14+8], W0
004A5A  BE0010     MOV.D [W0], W0
004A5C  070269     RCALL long_scale
004A5E  BE0400     MOV.D W0, W8
004A60  90005E     MOV [W14+10], W0
004A62  780110     MOV [W0], W2
004A64  90004E     MOV [W14+8], W0
004A66  400064     ADD W0, #0x4, W0
004A68  BE0010     MOV.D [W0], W0
004A6A  070262     RCALL long_scale
004A6C  400008     ADD W0, W8, W0
004A6E  488089     ADDC W1, W9, W1
004A70  980720     MOV W0, [W14+4]
004A72  980731     MOV W1, [W14+6]
151:               	vector[0] = newx;
004A74  90004E     MOV [W14+8], W0
004A76  BE011E     MOV.D [W14], W2
004A78  BE8802     MOV.D W2, [W0]
152:               	vector[1] = newy;
004A7A  90004E     MOV [W14+8], W0
004A7C  400064     ADD W0, #0x4, W0
004A7E  90012E     MOV [W14+4], W2
004A80  9001BE     MOV [W14+6], W3
004A82  BE8802     MOV.D W2, [W0]
153:               }
004A84  BE044F     MOV.D [--W15], W8
004A86  FA8000     ULNK
004A88  060000     RETURN
154:               
155:               void rotate_2D_vector_by_angle(int16_t vector[2], int8_t angle)
156:               {
004A8A  FA0008     LNK #0x8
004A8C  980720     MOV W0, [W14+4]
004A8E  984761     MOV.B W1, [W14+6]
157:               	// rotate the vector by angle,
158:               	// where vector is [ x, y ], angle is in byte-circular scaling
159:               	int16_t rotate[2];
160:               
161:               	rotate[1] = sine(angle);
004A90  90406E     MOV.B [W14+6], W0
004A92  07FF10     RCALL sine
004A94  980710     MOV W0, [W14+2]
162:               	rotate[0] = cosine(angle);
004A96  90406E     MOV.B [W14+6], W0
004A98  07FF8B     RCALL cosine
004A9A  780F00     MOV W0, [W14]
163:               	rotate_2D_vector_by_vector(vector, rotate);
004A9C  78008E     MOV W14, W1
004A9E  90002E     MOV [W14+4], W0
004AA0  07FF8E     RCALL rotate_2D_vector_by_vector
164:               }
004AA2  FA8000     ULNK
004AA4  060000     RETURN
165:               
166:               void rotate_2D(struct relative2D* xy, int8_t angle)
167:               {
004AA6  FA0010     LNK #0x10
004AA8  980760     MOV W0, [W14+12]
004AAA  984F61     MOV.B W1, [W14+14]
168:               	// rotates xy by angle, measured in a counter clockwise sense.
169:               	// A mathematical angle of plus or minus pi is represented digitally as plus or minus 128.
170:               	int16_t cosang, sinang, newx, newy;
171:               	union longww accum;
172:               
173:               	sinang = sine(angle);
004AAC  90486E     MOV.B [W14+14], W0
004AAE  07FF02     RCALL sine
004AB0  780F00     MOV W0, [W14]
174:               	cosang = cosine(angle);
004AB2  90486E     MOV.B [W14+14], W0
004AB4  07FF7D     RCALL cosine
004AB6  980710     MOV W0, [W14+2]
175:               	accum.WW = ((__builtin_mulss(cosang, xy->x) - __builtin_mulss(sinang, xy->y)) << 2) + 0x00008000;
004AB8  90006E     MOV [W14+12], W0
004ABA  780090     MOV [W0], W1
004ABC  90001E     MOV [W14+2], W0
004ABE  B98101     MUL.SS W0, W1, W2
004AC0  90006E     MOV [W14+12], W0
004AC2  900090     MOV [W0+2], W1
004AC4  78001E     MOV [W14], W0
004AC6  B98001     MUL.SS W0, W1, W0
004AC8  510000     SUB W2, W0, W0
004ACA  598081     SUBB W3, W1, W1
004ACC  DD0942     SL W1, #2, W2
004ACE  DE01CE     LSR W0, #14, W3
004AD0  710183     IOR W2, W3, W3
004AD2  DD0142     SL W0, #2, W2
004AD4  280000     MOV #0x8000, W0
004AD6  200001     MOV #0x0, W1
004AD8  400002     ADD W0, W2, W0
004ADA  488083     ADDC W1, W3, W1
004ADC  980740     MOV W0, [W14+8]
004ADE  980751     MOV W1, [W14+10]
176:               	newx = accum._.W1;
004AE0  90005E     MOV [W14+10], W0
004AE2  980720     MOV W0, [W14+4]
177:               	accum.WW = ((__builtin_mulss(sinang, xy->x) + __builtin_mulss(cosang, xy->y)) << 2) + 0x00008000;
004AE4  90006E     MOV [W14+12], W0
004AE6  780090     MOV [W0], W1
004AE8  78001E     MOV [W14], W0
004AEA  B98101     MUL.SS W0, W1, W2
004AEC  90006E     MOV [W14+12], W0
004AEE  900090     MOV [W0+2], W1
004AF0  90001E     MOV [W14+2], W0
004AF2  B98001     MUL.SS W0, W1, W0
004AF4  400002     ADD W0, W2, W0
004AF6  488083     ADDC W1, W3, W1
004AF8  DD0942     SL W1, #2, W2
004AFA  DE01CE     LSR W0, #14, W3
004AFC  710183     IOR W2, W3, W3
004AFE  DD0142     SL W0, #2, W2
004B00  280000     MOV #0x8000, W0
004B02  200001     MOV #0x0, W1
004B04  400002     ADD W0, W2, W0
004B06  488083     ADDC W1, W3, W1
004B08  980740     MOV W0, [W14+8]
004B0A  980751     MOV W1, [W14+10]
178:               	newy = accum._.W1;
004B0C  9000DE     MOV [W14+10], W1
004B0E  980731     MOV W1, [W14+6]
179:               	xy->x = newx;
004B10  90006E     MOV [W14+12], W0
004B12  9000AE     MOV [W14+4], W1
004B14  780801     MOV W1, [W0]
180:               	xy->y = newy;
004B16  90006E     MOV [W14+12], W0
004B18  9000BE     MOV [W14+6], W1
004B1A  980011     MOV W1, [W0+2]
181:               }
004B1C  FA8000     ULNK
004B1E  060000     RETURN
182:               
183:               int8_t rect_to_polar(struct relative2D* xy)
184:               {
004B20  FA0008     LNK #0x8
004B22  980730     MOV W0, [W14+6]
185:               	// Convert from rectangular to polar coordinates using "CORDIC" arithmetic, which is basically
186:               	// a binary search for the angle.
187:               	// As a by product, the xy is rotated onto the x axis, so that y is driven to zero,
188:               	// and the magnitude of the vector winds up as the x component.
189:               
190:               	int8_t theta = 0;
004B24  EB4000     CLR.B W0
004B26  784F00     MOV.B W0, [W14]
191:               	int8_t delta_theta = 64;
004B28  B3C400     MOV.B #0x40, W0
004B2A  984710     MOV.B W0, [W14+1]
192:               	int8_t theta_rot;
193:               	int8_t steps = 7;
004B2C  B3C070     MOV.B #0x7, W0
004B2E  984730     MOV.B W0, [W14+3]
194:               	int16_t scaleShift;
195:               
196:               	if (((xy-> x) <  255) &&
004B30  90003E     MOV [W14+6], W0
004B32  780090     MOV [W0], W1
004B34  200FE0     MOV #0xFE, W0
004B36  508F80     SUB W1, W0, [W15]
004B38  3C001C     BRA GT, .L22, .LSM78
004B3E  2FF020     MOV #0xFF02, W0
004B40  508F80     SUB W1, W0, [W15]
004B42  350017     BRA LT, .L22, .LSM78
197:               		((xy-> x) > -255) &&
004B3A  90003E     MOV [W14+6], W0
004B3C  780090     MOV [W0], W1
004B48  200FE0     MOV #0xFE, W0
004B4A  508F80     SUB W1, W0, [W15]
004B4C  3C0012     BRA GT, .L22, .LSM78
198:               		((xy-> y) <  255) &&
004B44  90003E     MOV [W14+6], W0
004B46  900090     MOV [W0+2], W1
004B52  2FF020     MOV #0xFF02, W0
004B54  508F80     SUB W1, W0, [W15]
004B56  35000D     BRA LT, .L22, .LSM78
199:               		((xy-> y) > -255))
004B4E  90003E     MOV [W14+6], W0
004B50  900090     MOV [W0+2], W1
200:               	{
201:               		scaleShift = 6;
004B58  200060     MOV #0x6, W0
004B5A  980720     MOV W0, [W14+4]
202:               		xy->x = (xy->x << 6);
004B5C  90003E     MOV [W14+6], W0
004B5E  780010     MOV [W0], W0
004B60  DD00C6     SL W0, #6, W1
004B62  90003E     MOV [W14+6], W0
004B64  780801     MOV W1, [W0]
203:               		xy->y = (xy->y << 6);
004B66  90003E     MOV [W14+6], W0
004B68  900010     MOV [W0+2], W0
004B6A  DD00C6     SL W0, #6, W1
004B6C  90003E     MOV [W14+6], W0
004B6E  980011     MOV W1, [W0+2]
204:               	}
205:               	else
206:               	{
207:               		scaleShift = 0;
004B72  EB0000     CLR W0
004B74  980720     MOV W0, [W14+4]
208:               	}
209:               	while (steps > 0)
004B70  37001A     BRA .L24, .LSM86
004B76  370017     BRA .L24, .LSM86
004BA6  90403E     MOV.B [W14+3], W0
004BA8  504FE0     SUB.B W0, #0x0, [W15]
004BAA  3CFFE6     BRA GT, .L26, .LSM80
210:               	{
211:               		theta_rot = delta_theta;
004B78  90401E     MOV.B [W14+1], W0
004B7A  984720     MOV.B W0, [W14+2]
212:               		if (xy->y  > 0) theta_rot = -theta_rot;
004B7C  90003E     MOV [W14+6], W0
004B7E  900010     MOV [W0+2], W0
004B80  500FE0     SUB W0, #0x0, [W15]
004B82  340003     BRA LE, .L25, .LSM82
004B84  90402E     MOV.B [W14+2], W0
004B86  EA4000     NEG.B W0, W0
004B88  984720     MOV.B W0, [W14+2]
213:               		rotate_2D(xy, theta_rot);
004B8A  9040AE     MOV.B [W14+2], W1
004B8C  90003E     MOV [W14+6], W0
004B8E  07FF8B     RCALL rotate_2D
214:               		theta += theta_rot;
004B90  78409E     MOV.B [W14], W1
004B92  90402E     MOV.B [W14+2], W0
004B94  40C000     ADD.B W1, W0, W0
004B96  784F00     MOV.B W0, [W14]
215:               		delta_theta = (delta_theta >> 1);
004B98  90401E     MOV.B [W14+1], W0
004B9A  FB0000     SE W0, W0
004B9C  D18000     ASR W0, W0
004B9E  984710     MOV.B W0, [W14+1]
216:               		steps--;
004BA0  90403E     MOV.B [W14+3], W0
004BA2  E94000     DEC.B W0, W0
004BA4  984730     MOV.B W0, [W14+3]
217:               	}
218:               	if (xy->y > 0) theta--;
004BAC  90003E     MOV [W14+6], W0
004BAE  900010     MOV [W0+2], W0
004BB0  500FE0     SUB W0, #0x0, [W15]
004BB2  340001     BRA LE, .L27, .LSM88
004BB4  E94F1E     DEC.B [W14], [W14]
219:               	xy->x = (xy->x >> scaleShift);
004BB6  90003E     MOV [W14+6], W0
004BB8  780090     MOV [W0], W1
004BBA  90002E     MOV [W14+4], W0
004BBC  DE8880     ASR W1, W0, W1
004BBE  90003E     MOV [W14+6], W0
004BC0  780801     MOV W1, [W0]
220:               	xy->y = (xy->y >> scaleShift);
004BC2  90003E     MOV [W14+6], W0
004BC4  900090     MOV [W0+2], W1
004BC6  90002E     MOV [W14+4], W0
004BC8  DE8880     ASR W1, W0, W1
004BCA  90003E     MOV [W14+6], W0
004BCC  980011     MOV W1, [W0+2]
221:               	return (-theta);
004BCE  EA401E     NEG.B [W14], W0
222:               }
004BD0  FA8000     ULNK
004BD2  060000     RETURN
223:               
224:               int16_t rect_to_polar16(struct relative2D* xy)
225:               {
004BD4  FA000A     LNK #0xA
004BD6  980740     MOV W0, [W14+8]
226:               	// Convert from rectangular to polar coordinates using "CORDIC" arithmetic, which is basically
227:               	// a binary search for the angle.
228:               	// As a by product, the xy is rotated onto the x axis, so that y is driven to zero,
229:               	// and the magnitude of the vector winds up as the x component.
230:               	// Returns a value as a 16 bit "circular" so that 180 degrees yields 2**15
231:               	int16_t scaleShift;
232:               	int16_t theta16;
233:               	int8_t theta = 0;
004BD8  EB4000     CLR.B W0
004BDA  984740     MOV.B W0, [W14+4]
234:               	int8_t delta_theta = 64;
004BDC  B3C400     MOV.B #0x40, W0
004BDE  984750     MOV.B W0, [W14+5]
235:               	int8_t theta_rot;
236:               	int8_t steps = 7;
004BE0  B3C070     MOV.B #0x7, W0
004BE2  984770     MOV.B W0, [W14+7]
237:               
238:               	if (((xy-> x) < 255)  &&
004BE4  90004E     MOV [W14+8], W0
004BE6  780090     MOV [W0], W1
004BE8  200FE0     MOV #0xFE, W0
004BEA  508F80     SUB W1, W0, [W15]
004BEC  3C001C     BRA GT, .L29, .LSM107
004BF2  2FF020     MOV #0xFF02, W0
004BF4  508F80     SUB W1, W0, [W15]
004BF6  350017     BRA LT, .L29, .LSM107
239:               		((xy-> x) > -255) &&
004BEE  90004E     MOV [W14+8], W0
004BF0  780090     MOV [W0], W1
004BFC  200FE0     MOV #0xFE, W0
004BFE  508F80     SUB W1, W0, [W15]
004C00  3C0012     BRA GT, .L29, .LSM107
240:               		((xy-> y) < 255)  &&
004BF8  90004E     MOV [W14+8], W0
004BFA  900090     MOV [W0+2], W1
004C06  2FF020     MOV #0xFF02, W0
004C08  508F80     SUB W1, W0, [W15]
004C0A  35000D     BRA LT, .L29, .LSM107
241:               		((xy-> y) > -255))
004C02  90004E     MOV [W14+8], W0
004C04  900090     MOV [W0+2], W1
242:               	{
243:               		scaleShift = 6;
004C0C  200060     MOV #0x6, W0
004C0E  780F00     MOV W0, [W14]
244:               		xy->x = (xy->x << 6);
004C10  90004E     MOV [W14+8], W0
004C12  780010     MOV [W0], W0
004C14  DD00C6     SL W0, #6, W1
004C16  90004E     MOV [W14+8], W0
004C18  780801     MOV W1, [W0]
245:               		xy->y = (xy->y << 6);
004C1A  90004E     MOV [W14+8], W0
004C1C  900010     MOV [W0+2], W0
004C1E  DD00C6     SL W0, #6, W1
004C20  90004E     MOV [W14+8], W0
004C22  980011     MOV W1, [W0+2]
246:               	}
247:               	else
248:               	{
249:               		scaleShift = 0;
004C26  EB0000     CLR W0
004C28  780F00     MOV W0, [W14]
250:               	}
251:               	while (steps > 0)
004C24  37001A     BRA .L31, .LSM115
004C2A  370017     BRA .L31, .LSM115
004C5A  90407E     MOV.B [W14+7], W0
004C5C  504FE0     SUB.B W0, #0x0, [W15]
004C5E  3CFFE6     BRA GT, .L33, .LSM109
252:               	{
253:               		theta_rot = delta_theta;
004C2C  90405E     MOV.B [W14+5], W0
004C2E  984760     MOV.B W0, [W14+6]
254:               		if (xy->y  > 0) theta_rot = -theta_rot;
004C30  90004E     MOV [W14+8], W0
004C32  900010     MOV [W0+2], W0
004C34  500FE0     SUB W0, #0x0, [W15]
004C36  340003     BRA LE, .L32, .LSM111
004C38  90406E     MOV.B [W14+6], W0
004C3A  EA4000     NEG.B W0, W0
004C3C  984760     MOV.B W0, [W14+6]
255:               		rotate_2D(xy, theta_rot);
004C3E  9040EE     MOV.B [W14+6], W1
004C40  90004E     MOV [W14+8], W0
004C42  07FF31     RCALL rotate_2D
256:               		theta += theta_rot;
004C44  9040CE     MOV.B [W14+4], W1
004C46  90406E     MOV.B [W14+6], W0
004C48  40C000     ADD.B W1, W0, W0
004C4A  984740     MOV.B W0, [W14+4]
257:               		delta_theta = (delta_theta >> 1);
004C4C  90405E     MOV.B [W14+5], W0
004C4E  FB0000     SE W0, W0
004C50  D18000     ASR W0, W0
004C52  984750     MOV.B W0, [W14+5]
258:               		steps--;
004C54  90407E     MOV.B [W14+7], W0
004C56  E94000     DEC.B W0, W0
004C58  984770     MOV.B W0, [W14+7]
259:               	}
260:               	theta = -theta;
004C60  90404E     MOV.B [W14+4], W0
004C62  EA4000     NEG.B W0, W0
004C64  984740     MOV.B W0, [W14+4]
261:               	theta16 = theta << 8;
004C66  90404E     MOV.B [W14+4], W0
004C68  FB0000     SE W0, W0
004C6A  DD0048     SL W0, #8, W0
004C6C  980710     MOV W0, [W14+2]
262:               	if (xy->x > 0)
004C6E  90004E     MOV [W14+8], W0
004C70  780010     MOV [W0], W0
004C72  500FE0     SUB W0, #0x0, [W15]
004C74  34000D     BRA LE, .L34, .LSM120
263:               	{
264:               		theta16 += __builtin_divsd(__builtin_mulss(RADIANTOCIRCULAR, xy->y), xy->x);
004C76  90004E     MOV [W14+8], W0
004C78  780110     MOV [W0], W2
004C7A  90004E     MOV [W14+8], W0
004C7C  900090     MOV [W0+2], W1
004C7E  228BE0     MOV #0x28BE, W0
004C80  B98001     MUL.SS W0, W1, W0
004C82  781F81     MOV W1, [W15++]
004C84  090011     REPEAT #0x11
004C86  D80842     DIV.SD W0, W2
004C88  7800CF     MOV [--W15], W1
004C8A  90009E     MOV [W14+2], W1
004C8C  408000     ADD W1, W0, W0
004C8E  980710     MOV W0, [W14+2]
265:               	}
266:               	xy->x = (xy->x >> scaleShift);
004C90  90004E     MOV [W14+8], W0
004C92  780090     MOV [W0], W1
004C94  78001E     MOV [W14], W0
004C96  DE8880     ASR W1, W0, W1
004C98  90004E     MOV [W14+8], W0
004C9A  780801     MOV W1, [W0]
267:               	xy->y = (xy->y >> scaleShift);
004C9C  90004E     MOV [W14+8], W0
004C9E  900090     MOV [W0+2], W1
004CA0  78001E     MOV [W14], W0
004CA2  DE8880     ASR W1, W0, W1
004CA4  90004E     MOV [W14+8], W0
004CA6  980011     MOV W1, [W0+2]
268:               	return (theta16);
004CA8  90001E     MOV [W14+2], W0
269:               }
004CAA  FA8000     ULNK
004CAC  060000     RETURN
270:               
271:               uint16_t sqrt_int(uint16_t sqr)
272:               {
004CAE  FA0008     LNK #0x8
004CB0  980730     MOV W0, [W14+6]
273:               	// based on Heron's algorithm
274:               	uint16_t binary_point = 0;
004CB2  EB0000     CLR W0
004CB4  780F00     MOV W0, [W14]
275:               	uint16_t result = 255;
004CB6  200FF0     MOV #0xFF, W0
004CB8  980710     MOV W0, [W14+2]
276:               //	int16_t iterations = 3;
277:               	int16_t iterations = 6; // for more precision
004CBA  200060     MOV #0x6, W0
004CBC  980720     MOV W0, [W14+4]
278:               
279:               	if (sqr == 0)
004CBE  90003E     MOV [W14+6], W0
004CC0  500FE0     SUB W0, #0x0, [W15]
004CC2  3A0007     BRA NZ, .L42, .LSM132
280:               	{
281:               		return 0;
004CC4  EB0000     CLR W0
004CC6  370026     BRA .L37, .LSM140
282:               	}
283:               	while ((sqr & 0xC000) == 0) // shift left to get a 1 in the 2 MSbits
004CD2  000000     NOP
004CD4  9000BE     MOV [W14+6], W1
004CD6  2C0000     MOV #0xC000, W0
004CD8  608000     AND W1, W0, W0
004CDA  500FE0     SUB W0, #0x0, [W15]
004CDC  32FFF5     BRA Z, .L39, .LSM130
284:               	{
285:               		sqr = sqr*4;            // shift 2 bits
004CC8  90003E     MOV [W14+6], W0
004CCA  DD0042     SL W0, #2, W0
004CCC  980730     MOV W0, [W14+6]
286:               		binary_point++;         // track half of the number of bits shifted
004CCE  E80F1E     INC [W14], [W14]
004CD0  370001     BRA .L38
287:               	}
288:               	sqr = sqr/2;                // for convenience, Herons formula is result = (result + sqr/result) / 2
004CDE  90003E     MOV [W14+6], W0
004CE0  D10000     LSR W0, W0
004CE2  980730     MOV W0, [W14+6]
289:               	while (iterations)
004CE4  37000F     BRA .L40, .LSM137
004D04  90002E     MOV [W14+4], W0
004D06  500FE0     SUB W0, #0x0, [W15]
004D08  3AFFEE     BRA NZ, .L41, .LSM135
290:               	{
291:               		iterations--;
004CE6  90002E     MOV [W14+4], W0
004CE8  E90000     DEC W0, W0
004CEA  980720     MOV W0, [W14+4]
292:               		result = result/2 + sqr/result;
004CEC  90001E     MOV [W14+2], W0
004CEE  D10080     LSR W0, W1
004CF0  90013E     MOV [W14+6], W2
004CF2  90001E     MOV [W14+2], W0
004CF4  780180     MOV W0, W3
004CF6  781F81     MOV W1, [W15++]
004CF8  090011     REPEAT #0x11
004CFA  D88103     DIV.UW W2, W3
004CFC  780101     MOV W1, W2
004CFE  7800CF     MOV [--W15], W1
004D00  408000     ADD W1, W0, W0
004D02  980710     MOV W0, [W14+2]
293:               	}
294:               	result = result >> binary_point; // shift result right to account for shift left of sqr 
004D0A  78001E     MOV [W14], W0
004D0C  90009E     MOV [W14+2], W1
004D0E  DE0800     LSR W1, W0, W0
004D10  980710     MOV W0, [W14+2]
295:               	return result;
004D12  90001E     MOV [W14+2], W0
296:               }
004D14  FA8000     ULNK
004D16  060000     RETURN
297:               
298:               uint16_t sqrt_long(uint32_t sqr)
299:               {
004D18  FA000A     LNK #0xA
004D1A  980730     MOV W0, [W14+6]
004D1C  980741     MOV W1, [W14+8]
300:               	// based on Heron's algorithm
301:               	uint16_t binary_point = 0;
004D1E  EB0000     CLR W0
004D20  780F00     MOV W0, [W14]
302:               	uint16_t result = 65535;    // need to start high and work down to avoid overflow in divud
004D22  EB8000     SETM W0
004D24  980710     MOV W0, [W14+2]
303:               //	int16_t iterations = 3;     // thats all you need
304:               	int16_t iterations = 6;		// lets improve the precision for luge IMU
004D26  200060     MOV #0x6, W0
004D28  980720     MOV W0, [W14+4]
305:               	if (sqr < 65536)            // use the 16 bit square root
004D2A  90013E     MOV [W14+6], W2
004D2C  9001CE     MOV [W14+8], W3
004D2E  2FFFF0     MOV #0xFFFF, W0
004D30  200001     MOV #0x0, W1
004D32  510F80     SUB W2, W0, [W15]
004D34  598F81     SUBB W3, W1, [W15]
004D36  3E000D     BRA GTU, .L50, .LSM149
306:               	{
307:               		return sqrt_int((uint16_t)sqr);
004D38  90003E     MOV [W14+6], W0
004D3A  07FFB9     RCALL sqrt_int
004D3C  37003C     BRA .L45, .LSM157
308:               	}
309:               	while ((sqr & 0xC0000000) == 0) // shift left to get a 1 in the 2 MSbits
004D52  000000     NOP
004D54  90013E     MOV [W14+6], W2
004D56  9001CE     MOV [W14+8], W3
004D58  200000     MOV #0x0, W0
004D5A  2C0001     MOV #0xC000, W1
004D5C  780202     MOV W2, W4
004D5E  780103     MOV W3, W2
004D60  780180     MOV W0, W3
004D62  780001     MOV W1, W0
004D64  620203     AND W4, W3, W4
004D66  610000     AND W2, W0, W0
004D68  200001     MOV #0x0, W1
004D6A  DD00C0     SL W0, #0, W1
004D6C  200000     MOV #0x0, W0
004D6E  BE0100     MOV.D W0, W2
004D70  B82061     MUL.UU W4, #1, W0
004D72  710100     IOR W2, W0, W2
004D74  718181     IOR W3, W1, W3
004D76  510FE0     SUB W2, #0x0, [W15]
004D78  598FE0     SUBB W3, #0x0, [W15]
004D7A  32FFE1     BRA Z, .L47, .LSM147
310:               	{
311:               		sqr = sqr << 2;
004D3E  90013E     MOV [W14+6], W2
004D40  9001CE     MOV [W14+8], W3
004D42  DD1842     SL W3, #2, W0
004D44  DE10CE     LSR W2, #14, W1
004D46  700081     IOR W0, W1, W1
004D48  DD1042     SL W2, #2, W0
004D4A  980730     MOV W0, [W14+6]
004D4C  980741     MOV W1, [W14+8]
312:               		binary_point++;         // track half of the number of bits shifted
004D4E  E80F1E     INC [W14], [W14]
004D50  370001     BRA .L46
313:               	}
314:               	sqr = sqr >> 1;             // for convenience, Herons formula is result = (result + sqr/result) / 2
004D7C  90003E     MOV [W14+6], W0
004D7E  9000CE     MOV [W14+8], W1
004D80  D10081     LSR W1, W1
004D82  D38000     RRC W0, W0
004D84  980730     MOV W0, [W14+6]
004D86  980741     MOV W1, [W14+8]
315:               	while (iterations)
004D88  37000E     BRA .L48, .LSM154
004DA6  90002E     MOV [W14+4], W0
004DA8  500FE0     SUB W0, #0x0, [W15]
004DAA  3AFFEF     BRA NZ, .L49, .LSM152
316:               	{
317:               		iterations--;
004D8A  90002E     MOV [W14+4], W0
004D8C  E90000     DEC W0, W0
004D8E  980720     MOV W0, [W14+4]
318:               		result = result/2 + __builtin_divud(sqr, result);
004D90  90001E     MOV [W14+2], W0
004D92  D10100     LSR W0, W2
004D94  90003E     MOV [W14+6], W0
004D96  9000CE     MOV [W14+8], W1
004D98  90019E     MOV [W14+2], W3
004D9A  781F81     MOV W1, [W15++]
004D9C  090011     REPEAT #0x11
004D9E  D88843     DIV.UD W0, W3
004DA0  7800CF     MOV [--W15], W1
004DA2  410000     ADD W2, W0, W0
004DA4  980710     MOV W0, [W14+2]
319:               	}
320:               	result = result >> binary_point; // shift result right to account for shift left of sqr 
004DAC  78001E     MOV [W14], W0
004DAE  90009E     MOV [W14+2], W1
004DB0  DE0800     LSR W1, W0, W0
004DB2  980710     MOV W0, [W14+2]
321:               	return result;
004DB4  90001E     MOV [W14+2], W0
322:               }
004DB6  FA8000     ULNK
004DB8  060000     RETURN
323:               
324:               uint16_t vector2_mag(int16_t x, int16_t y)
325:               {
004DBA  FA0008     LNK #0x8
004DBC  980720     MOV W0, [W14+4]
004DBE  980731     MOV W1, [W14+6]
326:               	uint32_t magsqr;
327:               
328:               	magsqr = __builtin_mulss(x, x) + __builtin_mulss(y, y);
004DC0  90002E     MOV [W14+4], W0
004DC2  9000AE     MOV [W14+4], W1
004DC4  B98101     MUL.SS W0, W1, W2
004DC6  90003E     MOV [W14+6], W0
004DC8  9000BE     MOV [W14+6], W1
004DCA  B98001     MUL.SS W0, W1, W0
004DCC  400002     ADD W0, W2, W0
004DCE  488083     ADDC W1, W3, W1
004DD0  BE8F00     MOV.D W0, [W14]
329:               	return sqrt_long(magsqr);
004DD2  BE001E     MOV.D [W14], W0
004DD4  07FFA1     RCALL sqrt_long
330:               }
004DD6  FA8000     ULNK
004DD8  060000     RETURN
331:               
332:               uint16_t vector3_mag(int16_t x, int16_t y, int16_t z)
333:               {
004DDA  FA000A     LNK #0xA
004DDC  980720     MOV W0, [W14+4]
004DDE  980731     MOV W1, [W14+6]
004DE0  980742     MOV W2, [W14+8]
334:               	uint32_t magsqr;
335:               
336:               	magsqr = __builtin_mulss(x, x) + __builtin_mulss(y, y) + __builtin_mulss(z, z);
004DE2  90002E     MOV [W14+4], W0
004DE4  9000AE     MOV [W14+4], W1
004DE6  B98101     MUL.SS W0, W1, W2
004DE8  90003E     MOV [W14+6], W0
004DEA  9000BE     MOV [W14+6], W1
004DEC  B98001     MUL.SS W0, W1, W0
004DEE  400102     ADD W0, W2, W2
004DF0  488183     ADDC W1, W3, W3
004DF2  90004E     MOV [W14+8], W0
004DF4  9000CE     MOV [W14+8], W1
004DF6  B98001     MUL.SS W0, W1, W0
004DF8  400002     ADD W0, W2, W0
004DFA  488083     ADDC W1, W3, W1
004DFC  BE8F00     MOV.D W0, [W14]
337:               	return sqrt_long(magsqr);
004DFE  BE001E     MOV.D [W14], W0
004E00  07FF8B     RCALL sqrt_long
338:               }
004E02  FA8000     ULNK
004E04  060000     RETURN
339:               
340:               uint16_t vector2_normalize(int16_t result[], int16_t input[])
341:               {
004E06  FA0008     LNK #0x8
004E08  980720     MOV W0, [W14+4]
004E0A  980731     MOV W1, [W14+6]
342:               	uint16_t half_magnitude;
343:               	uint16_t magnitude;
344:               
345:               	magnitude = vector2_mag(input[0], input[1]);
004E0C  90003E     MOV [W14+6], W0
004E0E  E88000     INC2 W0, W0
004E10  780090     MOV [W0], W1
004E12  90003E     MOV [W14+6], W0
004E14  780010     MOV [W0], W0
004E16  07FFD1     RCALL vector2_mag
004E18  780F00     MOV W0, [W14]
346:               	half_magnitude = magnitude/2 ; // needed because divsd requires two signed values
004E1A  78001E     MOV [W14], W0
004E1C  D10000     LSR W0, W0
004E1E  980710     MOV W0, [W14+2]
347:               	if (half_magnitude > 0)
004E20  90001E     MOV [W14+2], W0
004E22  500FE0     SUB W0, #0x0, [W15]
004E24  320024     BRA Z, .L54, .LSM172
348:               	{
349:               		result[0] = __builtin_divsd(__builtin_mulss(RMAX, input[0]/2), half_magnitude);
004E26  90011E     MOV [W14+2], W2
004E28  90003E     MOV [W14+6], W0
004E2A  780090     MOV [W0], W1
004E2C  200020     MOV #0x2, W0
004E2E  780180     MOV W0, W3
004E30  090011     REPEAT #0x11
004E32  D80083     DIV.SW W1, W3
004E34  780080     MOV W0, W1
004E36  240000     MOV #0x4000, W0
004E38  B98001     MUL.SS W0, W1, W0
004E3A  781F80     MOV W0, [W15++]
004E3C  090011     REPEAT #0x11
004E3E  D80842     DIV.SD W0, W2
004E40  780080     MOV W0, W1
004E42  78004F     MOV [--W15], W0
004E44  90002E     MOV [W14+4], W0
004E46  780801     MOV W1, [W0]
350:               		result[1] = __builtin_divsd(__builtin_mulss(RMAX, input[1]/2), half_magnitude);
004E48  90002E     MOV [W14+4], W0
004E4A  E88100     INC2 W0, W2
004E4C  90019E     MOV [W14+2], W3
004E4E  90003E     MOV [W14+6], W0
004E50  E88000     INC2 W0, W0
004E52  780090     MOV [W0], W1
004E54  200020     MOV #0x2, W0
004E56  780200     MOV W0, W4
004E58  090011     REPEAT #0x11
004E5A  D80084     DIV.SW W1, W4
004E5C  780080     MOV W0, W1
004E5E  240000     MOV #0x4000, W0
004E60  B98001     MUL.SS W0, W1, W0
004E62  781F81     MOV W1, [W15++]
004E64  090011     REPEAT #0x11
004E66  D80843     DIV.SD W0, W3
004E68  7800CF     MOV [--W15], W1
004E6A  780900     MOV W0, [W2]
004E6C  370007     BRA .L55, .LSM173
351:               	}
352:               	else
353:               	{
354:               		result[0]=result[1]=0;
004E6E  90002E     MOV [W14+4], W0
004E70  E88000     INC2 W0, W0
004E72  EB0080     CLR W1
004E74  780801     MOV W1, [W0]
004E76  780090     MOV [W0], W1
004E78  90002E     MOV [W14+4], W0
004E7A  780801     MOV W1, [W0]
355:               	}
356:               	return magnitude;
004E7C  78001E     MOV [W14], W0
357:               }
004E7E  FA8000     ULNK
004E80  060000     RETURN
358:               
359:               uint16_t vector3_normalize(int16_t result[], int16_t input[])
360:               {
004E82  FA0008     LNK #0x8
004E84  980720     MOV W0, [W14+4]
004E86  980731     MOV W1, [W14+6]
361:               	uint16_t half_magnitude;
362:               	uint16_t magnitude;
363:               
364:               	magnitude = vector3_mag(input[0], input[1], input[2]);
004E88  90003E     MOV [W14+6], W0
004E8A  400064     ADD W0, #0x4, W0
004E8C  780110     MOV [W0], W2
004E8E  90003E     MOV [W14+6], W0
004E90  E88000     INC2 W0, W0
004E92  780090     MOV [W0], W1
004E94  90003E     MOV [W14+6], W0
004E96  780010     MOV [W0], W0
004E98  07FFA0     RCALL vector3_mag
004E9A  780F00     MOV W0, [W14]
365:               	half_magnitude = magnitude/2; // needed because divsd requires two signed values
004E9C  78001E     MOV [W14], W0
004E9E  D10000     LSR W0, W0
004EA0  980710     MOV W0, [W14+2]
366:               	if (half_magnitude > 0)
004EA2  90001E     MOV [W14+2], W0
004EA4  500FE0     SUB W0, #0x0, [W15]
004EA6  320036     BRA Z, .L57, .LSM182
367:               	{
368:               		result[0] = __builtin_divsd(__builtin_mulss(RMAX, input[0]/2), half_magnitude);
004EA8  90011E     MOV [W14+2], W2
004EAA  90003E     MOV [W14+6], W0
004EAC  780090     MOV [W0], W1
004EAE  200020     MOV #0x2, W0
004EB0  780180     MOV W0, W3
004EB2  090011     REPEAT #0x11
004EB4  D80083     DIV.SW W1, W3
004EB6  780080     MOV W0, W1
004EB8  240000     MOV #0x4000, W0
004EBA  B98001     MUL.SS W0, W1, W0
004EBC  781F80     MOV W0, [W15++]
004EBE  090011     REPEAT #0x11
004EC0  D80842     DIV.SD W0, W2
004EC2  780080     MOV W0, W1
004EC4  78004F     MOV [--W15], W0
004EC6  90002E     MOV [W14+4], W0
004EC8  780801     MOV W1, [W0]
369:               		result[1] = __builtin_divsd(__builtin_mulss(RMAX, input[1]/2), half_magnitude);
004ECA  90002E     MOV [W14+4], W0
004ECC  E88100     INC2 W0, W2
004ECE  90019E     MOV [W14+2], W3
004ED0  90003E     MOV [W14+6], W0
004ED2  E88000     INC2 W0, W0
004ED4  780090     MOV [W0], W1
004ED6  200020     MOV #0x2, W0
004ED8  780200     MOV W0, W4
004EDA  090011     REPEAT #0x11
004EDC  D80084     DIV.SW W1, W4
004EDE  780080     MOV W0, W1
004EE0  240000     MOV #0x4000, W0
004EE2  B98001     MUL.SS W0, W1, W0
004EE4  781F81     MOV W1, [W15++]
004EE6  090011     REPEAT #0x11
004EE8  D80843     DIV.SD W0, W3
004EEA  7800CF     MOV [--W15], W1
004EEC  780900     MOV W0, [W2]
370:               		result[2] = __builtin_divsd(__builtin_mulss(RMAX, input[2]/2), half_magnitude);
004EEE  90002E     MOV [W14+4], W0
004EF0  400164     ADD W0, #0x4, W2
004EF2  90019E     MOV [W14+2], W3
004EF4  90003E     MOV [W14+6], W0
004EF6  400064     ADD W0, #0x4, W0
004EF8  780090     MOV [W0], W1
004EFA  200020     MOV #0x2, W0
004EFC  780200     MOV W0, W4
004EFE  090011     REPEAT #0x11
004F00  D80084     DIV.SW W1, W4
004F02  780080     MOV W0, W1
004F04  240000     MOV #0x4000, W0
004F06  B98001     MUL.SS W0, W1, W0
004F08  781F81     MOV W1, [W15++]
004F0A  090011     REPEAT #0x11
004F0C  D80843     DIV.SD W0, W3
004F0E  7800CF     MOV [--W15], W1
004F10  780900     MOV W0, [W2]
004F12  37000B     BRA .L58, .LSM183
371:               	}
372:               	else
373:               	{
374:               		result[0] = result[1] = result[2] = 0;
004F14  90002E     MOV [W14+4], W0
004F16  E88000     INC2 W0, W0
004F18  9000AE     MOV [W14+4], W1
004F1A  4080E4     ADD W1, #0x4, W1
004F1C  EB0100     CLR W2
004F1E  780882     MOV W2, [W1]
004F20  780091     MOV [W1], W1
004F22  780801     MOV W1, [W0]
004F24  780090     MOV [W0], W1
004F26  90002E     MOV [W14+4], W0
004F28  780801     MOV W1, [W0]
375:               	}
376:               	return magnitude;
004F2A  78001E     MOV [W14], W0
377:               }
004F2C  FA8000     ULNK
004F2E  060000     RETURN
378:               
379:               int32_t long_scale(int32_t arg1, int16_t arg2)
380:               {
004F30  FA0014     LNK #0x14
004F32  980770     MOV W0, [W14+14]
004F34  980F01     MOV W1, [W14+16]
004F36  980F12     MOV W2, [W14+18]
381:               	// returns arg1*arg2/RMAX
382:               	// usually this is used where arg2 is a Q14.2 fractional number
383:               	int8_t sign_result = 1;
004F38  B3C010     MOV.B #0x1, W0
004F3A  784F00     MOV.B W0, [W14]
384:               	int32_t product;
385:               	union longww accum;
386:               	union longww arg1ww;
387:               
388:               	arg1ww.WW = arg1;
004F3C  90007E     MOV [W14+14], W0
004F3E  90088E     MOV [W14+16], W1
004F40  980750     MOV W0, [W14+10]
004F42  980761     MOV W1, [W14+12]
389:               	if (arg1ww._.W1 < 0)
004F44  90006E     MOV [W14+12], W0
004F46  500FE0     SUB W0, #0x0, [W15]
004F48  3D0007     BRA GE, .L60, .LSM191
390:               	{
391:               		sign_result = -sign_result;
004F4A  EA4F1E     NEG.B [W14], [W14]
392:               		arg1ww.WW = -arg1ww.WW;
004F4C  90005E     MOV [W14+10], W0
004F4E  9000EE     MOV [W14+12], W1
004F50  100060     SUBR W0, #0x0, W0
004F52  1880E0     SUBBR W1, #0x0, W1
004F54  980750     MOV W0, [W14+10]
004F56  980761     MOV W1, [W14+12]
393:               	}
394:               	if (arg2 < 0)
004F58  90081E     MOV [W14+18], W0
004F5A  500FE0     SUB W0, #0x0, [W15]
004F5C  3D0004     BRA GE, .L61, .LSM194
395:               	{
396:               		sign_result = -sign_result;
004F5E  EA4F1E     NEG.B [W14], [W14]
397:               		arg2 = -arg2;
004F60  90081E     MOV [W14+18], W0
004F62  EA0000     NEG W0, W0
004F64  980F10     MOV W0, [W14+18]
398:               	}
399:               	product  = __builtin_muluu(arg2, arg1ww._.W1);
004F66  90006E     MOV [W14+12], W0
004F68  780080     MOV W0, W1
004F6A  90081E     MOV [W14+18], W0
004F6C  B80001     MUL.UU W0, W1, W0
004F6E  980710     MOV W0, [W14+2]
004F70  980721     MOV W1, [W14+4]
400:               	product <<= 2;
004F72  90011E     MOV [W14+2], W2
004F74  9001AE     MOV [W14+4], W3
004F76  DD1842     SL W3, #2, W0
004F78  DE10CE     LSR W2, #14, W1
004F7A  700081     IOR W0, W1, W1
004F7C  DD1042     SL W2, #2, W0
004F7E  980710     MOV W0, [W14+2]
004F80  980721     MOV W1, [W14+4]
401:               	accum.WW = __builtin_muluu(arg2, arg1ww._.W0);
004F82  90005E     MOV [W14+10], W0
004F84  780080     MOV W0, W1
004F86  90081E     MOV [W14+18], W0
004F88  B80001     MUL.UU W0, W1, W0
004F8A  980730     MOV W0, [W14+6]
004F8C  980741     MOV W1, [W14+8]
402:               	accum.WW <<= 2;
004F8E  90013E     MOV [W14+6], W2
004F90  9001CE     MOV [W14+8], W3
004F92  DD1842     SL W3, #2, W0
004F94  DE10CE     LSR W2, #14, W1
004F96  700081     IOR W0, W1, W1
004F98  DD1042     SL W2, #2, W0
004F9A  980730     MOV W0, [W14+6]
004F9C  980741     MOV W1, [W14+8]
403:               	accum._.W0 = accum._.W1;
004F9E  90004E     MOV [W14+8], W0
004FA0  980730     MOV W0, [W14+6]
404:               	accum._.W1 = 0;
004FA2  EB0000     CLR W0
004FA4  980740     MOV W0, [W14+8]
405:               	product += accum.WW;
004FA6  90003E     MOV [W14+6], W0
004FA8  9000CE     MOV [W14+8], W1
004FAA  90011E     MOV [W14+2], W2
004FAC  9001AE     MOV [W14+4], W3
004FAE  400002     ADD W0, W2, W0
004FB0  488083     ADDC W1, W3, W1
004FB2  980710     MOV W0, [W14+2]
004FB4  980721     MOV W1, [W14+4]
406:               	if (sign_result > 0)
004FB6  78401E     MOV.B [W14], W0
004FB8  504FE0     SUB.B W0, #0x0, [W15]
004FBA  340003     BRA LE, .L62, .LSM203
407:               	{
408:               		return product;
004FBC  90001E     MOV [W14+2], W0
004FBE  9000AE     MOV [W14+4], W1
004FC0  370004     BRA .L63, .LSM204
409:               	}
410:               	else
411:               	{
412:               		return -product;
004FC2  90001E     MOV [W14+2], W0
004FC4  9000AE     MOV [W14+4], W1
004FC6  100060     SUBR W0, #0x0, W0
004FC8  1880E0     SUBBR W1, #0x0, W1
413:               	}
414:               }
004FCA  FA8000     ULNK
004FCC  060000     RETURN
415:               
416:               int16_t find_first_bit_int16(int16_t argument)
417:               {
004FCE  FA0004     LNK #0x4
004FD0  980710     MOV W0, [W14+2]
418:               	// finds first bit position in the absolute value of a 16 bit signed integer
419:               	// returns the position of the first significant bit
420:               	// MSB position is 0
421:               	// LSB position is 15
422:               	// returns 16 for input=0 and 0 for input=0x8000H
423:               	int16_t input;
424:               
425:               	if (argument == 0)
004FD2  90001E     MOV [W14+2], W0
004FD4  500FE0     SUB W0, #0x0, [W15]
004FD6  3A0002     BRA NZ, .L65, .LSM208
426:               	{
427:               		return 16;
004FD8  200100     MOV #0x10, W0
004FDA  37000C     BRA .L66, .LSM212
428:               	}
429:               	if (argument < 0)
004FDC  90001E     MOV [W14+2], W0
004FDE  500FE0     SUB W0, #0x0, [W15]
004FE0  3D0003     BRA GE, .L67, .LSM210
430:               	{
431:               		input = - argument;
004FE2  90001E     MOV [W14+2], W0
004FE4  EA0F00     NEG W0, [W14]
004FE6  370002     BRA .L68, .LSM211
432:               	}
433:               	else
434:               	{
435:               		input = argument;
004FE8  90001E     MOV [W14+2], W0
004FEA  780F00     MOV W0, [W14]
436:               	}
437:               	return FindFirstBitFromLeft(input) - 1;
004FEC  78001E     MOV [W14], W0
004FEE  0208E6     CALL _FindFirstBitFromLeft
004FF0  000000     NOP
004FF2  E90000     DEC W0, W0
438:               }
004FF4  FA8000     ULNK
004FF6  060000     RETURN
439:               
440:               int16_t find_first_bit_int32(int32_t argument)
441:               {
004FF8  FA000C     LNK #0xC
004FFA  980740     MOV W0, [W14+8]
004FFC  980751     MOV W1, [W14+10]
442:               	// finds first bit position in the absolute value of a 32 bit signed integer
443:               	// returns the position of the first significan bit
444:               	// MSB position is 0
445:               	// LSB position is 31
446:               	// returns 32 for input=0 and 0 for input=0x80000000H
447:               	union longww input;
448:               	int16_t binw0;
449:               	int16_t binw1;
450:               
451:               	if (argument == 0)
004FFE  90004E     MOV [W14+8], W0
005000  9000DE     MOV [W14+10], W1
005002  500FE0     SUB W0, #0x0, [W15]
005004  588FE0     SUBB W1, #0x0, [W15]
005006  3A0002     BRA NZ, .L70, .LSM216
452:               	{
453:               		return 32;
005008  200200     MOV #0x20, W0
00500A  37001F     BRA .L71, .LSM224
454:               	}
455:               	if (argument < 0)
00500C  90004E     MOV [W14+8], W0
00500E  9000DE     MOV [W14+10], W1
005010  500FE0     SUB W0, #0x0, [W15]
005012  588FE0     SUBB W1, #0x0, [W15]
005014  3D0007     BRA GE, .L72, .LSM218
456:               	{
457:               		input.WW = -argument;
005016  90004E     MOV [W14+8], W0
005018  9000DE     MOV [W14+10], W1
00501A  100060     SUBR W0, #0x0, W0
00501C  1880E0     SUBBR W1, #0x0, W1
00501E  980720     MOV W0, [W14+4]
005020  980731     MOV W1, [W14+6]
005022  370004     BRA .L73, .LSM219
458:               	}
459:               	else
460:               	{
461:               		input.WW = argument;
005024  90004E     MOV [W14+8], W0
005026  9000DE     MOV [W14+10], W1
005028  980720     MOV W0, [W14+4]
00502A  980731     MOV W1, [W14+6]
462:               	}
463:               	binw1 = FindFirstBitFromLeft(input._.W1);
00502C  90003E     MOV [W14+6], W0
00502E  0208E6     CALL _FindFirstBitFromLeft
005030  000000     NOP
005032  780F00     MOV W0, [W14]
464:               	binw0 = FindFirstBitFromLeft(input._.W0);
005034  90002E     MOV [W14+4], W0
005036  0208E6     CALL _FindFirstBitFromLeft
005038  000000     NOP
00503A  980710     MOV W0, [W14+2]
465:               	if (binw1 == 0)
00503C  78001E     MOV [W14], W0
00503E  500FE0     SUB W0, #0x0, [W15]
005040  3A0003     BRA NZ, .L74, .LSM223
466:               	{
467:               		return binw0 + 15;
005042  90001E     MOV [W14+2], W0
005044  40006F     ADD W0, #0xF, W0
005046  370001     BRA .L71, .LSM224
468:               	}
469:               	else
470:               	{
471:               		return binw1 - 1;
005048  E9001E     DEC [W14], W0
472:               	}
473:               }
00504A  FA8000     ULNK
00504C  060000     RETURN
474:               
475:               void VectorCross(int16_t * dest, int16_t * src1, int16_t * src2)
476:               {
00504E  FA000A     LNK #0xA
005050  980720     MOV W0, [W14+4]
005052  980731     MOV W1, [W14+6]
005054  980742     MOV W2, [W14+8]
477:               	// Implement the cross product. *dest = *src1X*src2;
478:               	union longww crossaccum;
479:               	crossaccum.WW = __builtin_mulss(src1[1], src2[2]);
005056  90004E     MOV [W14+8], W0
005058  400064     ADD W0, #0x4, W0
00505A  780090     MOV [W0], W1
00505C  90003E     MOV [W14+6], W0
00505E  E88000     INC2 W0, W0
005060  780010     MOV [W0], W0
005062  B98001     MUL.SS W0, W1, W0
005064  BE8F00     MOV.D W0, [W14]
480:               	crossaccum.WW -= __builtin_mulss(src1[2], src2[1]);
005066  BE011E     MOV.D [W14], W2
005068  90004E     MOV [W14+8], W0
00506A  E88000     INC2 W0, W0
00506C  780090     MOV [W0], W1
00506E  90003E     MOV [W14+6], W0
005070  400064     ADD W0, #0x4, W0
005072  780010     MOV [W0], W0
005074  B98001     MUL.SS W0, W1, W0
005076  510000     SUB W2, W0, W0
005078  598081     SUBB W3, W1, W1
00507A  BE8F00     MOV.D W0, [W14]
481:               	crossaccum.WW *= 4;
00507C  BE011E     MOV.D [W14], W2
00507E  DD1842     SL W3, #2, W0
005080  DE10CE     LSR W2, #14, W1
005082  700081     IOR W0, W1, W1
005084  DD1042     SL W2, #2, W0
005086  BE8F00     MOV.D W0, [W14]
482:               	dest[0] = crossaccum._.W1;
005088  90009E     MOV [W14+2], W1
00508A  90002E     MOV [W14+4], W0
00508C  780801     MOV W1, [W0]
483:               	crossaccum.WW = __builtin_mulss(src1[2], src2[0]);
00508E  90004E     MOV [W14+8], W0
005090  780090     MOV [W0], W1
005092  90003E     MOV [W14+6], W0
005094  400064     ADD W0, #0x4, W0
005096  780010     MOV [W0], W0
005098  B98001     MUL.SS W0, W1, W0
00509A  BE8F00     MOV.D W0, [W14]
484:               	crossaccum.WW -= __builtin_mulss(src1[0], src2[2]);
00509C  BE011E     MOV.D [W14], W2
00509E  90004E     MOV [W14+8], W0
0050A0  400064     ADD W0, #0x4, W0
0050A2  780090     MOV [W0], W1
0050A4  90003E     MOV [W14+6], W0
0050A6  780010     MOV [W0], W0
0050A8  B98001     MUL.SS W0, W1, W0
0050AA  510000     SUB W2, W0, W0
0050AC  598081     SUBB W3, W1, W1
0050AE  BE8F00     MOV.D W0, [W14]
485:               	crossaccum.WW *= 4;
0050B0  BE011E     MOV.D [W14], W2
0050B2  DD1842     SL W3, #2, W0
0050B4  DE10CE     LSR W2, #14, W1
0050B6  700081     IOR W0, W1, W1
0050B8  DD1042     SL W2, #2, W0
0050BA  BE8F00     MOV.D W0, [W14]
486:               	dest[1] = crossaccum._.W1;
0050BC  90002E     MOV [W14+4], W0
0050BE  E88000     INC2 W0, W0
0050C0  90009E     MOV [W14+2], W1
0050C2  780801     MOV W1, [W0]
487:               	crossaccum.WW = __builtin_mulss(src1[0], src2[1]);
0050C4  90004E     MOV [W14+8], W0
0050C6  E88000     INC2 W0, W0
0050C8  780090     MOV [W0], W1
0050CA  90003E     MOV [W14+6], W0
0050CC  780010     MOV [W0], W0
0050CE  B98001     MUL.SS W0, W1, W0
0050D0  BE8F00     MOV.D W0, [W14]
488:               	crossaccum.WW -= __builtin_mulss(src1[1], src2[0]);
0050D2  BE011E     MOV.D [W14], W2
0050D4  90004E     MOV [W14+8], W0
0050D6  780090     MOV [W0], W1
0050D8  90003E     MOV [W14+6], W0
0050DA  E88000     INC2 W0, W0
0050DC  780010     MOV [W0], W0
0050DE  B98001     MUL.SS W0, W1, W0
0050E0  510000     SUB W2, W0, W0
0050E2  598081     SUBB W3, W1, W1
0050E4  BE8F00     MOV.D W0, [W14]
489:               	crossaccum.WW *= 4;
0050E6  BE011E     MOV.D [W14], W2
0050E8  DD1842     SL W3, #2, W0
0050EA  DE10CE     LSR W2, #14, W1
0050EC  700081     IOR W0, W1, W1
0050EE  DD1042     SL W2, #2, W0
0050F0  BE8F00     MOV.D W0, [W14]
490:               	dest[2] = crossaccum._.W1;
0050F2  90002E     MOV [W14+4], W0
0050F4  400064     ADD W0, #0x4, W0
0050F6  90009E     MOV [W14+2], W1
0050F8  780801     MOV W1, [W0]
491:               }
0050FA  FA8000     ULNK
0050FC  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libDCM/mathlib.c  -----------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "dcmTypes.h"
23:                #include "mathlibNAV.h"
24:                #include "mathlib.h"
25:                #if (WIN == 1 || NIX == 1)
26:                #include "../Tools/MatrixPilot-SIL/SIL-udb.h"
27:                #endif // (WIN == 1 || NIX == 1)
28:                
29:                #ifndef NULL
30:                #define NULL 0
31:                #endif
32:                
33:                //  math libraray
34:                
35:                int16_t add_saturate(int16_t x , int16_t y , int16_t margin)
36:                {
0058C6  FA0012     LNK #0x12
0058C8  980760     MOV W0, [W14+12]
0058CA  980771     MOV W1, [W14+14]
0058CC  980F02     MOV W2, [W14+16]
37:                	int32_t total = ((int32_t) x );
0058CE  90006E     MOV [W14+12], W0
0058D0  DE80CF     ASR W0, #15, W1
0058D2  BE8F00     MOV.D W0, [W14]
38:                	total = total + ((int32_t) y) ;
0058D4  90007E     MOV [W14+14], W0
0058D6  DE80CF     ASR W0, #15, W1
0058D8  400F1E     ADD W0, [W14], [W14]
0058DA  48975E     ADDC W1, [++W14], [W14--]
39:                	int32_t maximum = ((int32_t)(32767-margin));
0058DC  27FFF1     MOV #0x7FFF, W1
0058DE  90080E     MOV [W14+16], W0
0058E0  508000     SUB W1, W0, W0
0058E2  DE80CF     ASR W0, #15, W1
0058E4  980720     MOV W0, [W14+4]
0058E6  980731     MOV W1, [W14+6]
40:                	int32_t minimum = ((int32_t)(-32767+margin));
0058E8  90088E     MOV [W14+16], W1
0058EA  280010     MOV #0x8001, W0
0058EC  408000     ADD W1, W0, W0
0058EE  DE80CF     ASR W0, #15, W1
0058F0  980740     MOV W0, [W14+8]
0058F2  980751     MOV W1, [W14+10]
41:                	if ((total<=maximum)&&(total>=minimum))
0058F4  90002E     MOV [W14+4], W0
0058F6  9000BE     MOV [W14+6], W1
0058F8  BE011E     MOV.D [W14], W2
0058FA  510F80     SUB W2, W0, [W15]
0058FC  598F81     SUBB W3, W1, [W15]
0058FE  3C0008     BRA GT, .L2, .LSM7
005900  90004E     MOV [W14+8], W0
005902  9000DE     MOV [W14+10], W1
005904  BE011E     MOV.D [W14], W2
005906  510F80     SUB W2, W0, [W15]
005908  598F81     SUBB W3, W1, [W15]
00590A  350002     BRA LT, .L2, .LSM7
42:                	{
43:                		return ((int16_t)total );
00590C  78001E     MOV [W14], W0
00590E  370007     BRA .L3, .LSM10
44:                	}
45:                	else if ( total > 0 )
005910  BE001E     MOV.D [W14], W0
005912  500FE0     SUB W0, #0x0, [W15]
005914  588FE0     SUBB W1, #0x0, [W15]
005916  340002     BRA LE, .L4, .LSM9
46:                	{
47:                		return ((int16_t)maximum) ;
005918  90002E     MOV [W14+4], W0
00591A  370001     BRA .L3, .LSM10
48:                	}
49:                	else
50:                	{
51:                		return ((int16_t)minimum) ;
00591C  90004E     MOV [W14+8], W0
52:                	}
53:                }
00591E  FA8000     ULNK
005920  060000     RETURN
54:                
55:                int16_t subtract_saturate(int16_t x , int16_t y , int16_t margin)
56:                {
005922  FA0012     LNK #0x12
005924  980760     MOV W0, [W14+12]
005926  980771     MOV W1, [W14+14]
005928  980F02     MOV W2, [W14+16]
57:                	int32_t total = ((int32_t) x );
00592A  90006E     MOV [W14+12], W0
00592C  DE80CF     ASR W0, #15, W1
00592E  BE8F00     MOV.D W0, [W14]
58:                	total = total - ((int32_t) y) ;
005930  90007E     MOV [W14+14], W0
005932  DE80CF     ASR W0, #15, W1
005934  101F1E     SUBR W0, [W14], [W14++]
005936  18971E     SUBBR W1, [W14], [W14--]
59:                	int32_t maximum = ((int32_t)(32767-margin));
005938  27FFF1     MOV #0x7FFF, W1
00593A  90080E     MOV [W14+16], W0
00593C  508000     SUB W1, W0, W0
00593E  DE80CF     ASR W0, #15, W1
005940  980720     MOV W0, [W14+4]
005942  980731     MOV W1, [W14+6]
60:                	int32_t minimum = ((int32_t)(-32767+margin));
005944  90088E     MOV [W14+16], W1
005946  280010     MOV #0x8001, W0
005948  408000     ADD W1, W0, W0
00594A  DE80CF     ASR W0, #15, W1
00594C  980740     MOV W0, [W14+8]
00594E  980751     MOV W1, [W14+10]
61:                	if ((total<=maximum)&&(total>=minimum))
005950  90002E     MOV [W14+4], W0
005952  9000BE     MOV [W14+6], W1
005954  BE011E     MOV.D [W14], W2
005956  510F80     SUB W2, W0, [W15]
005958  598F81     SUBB W3, W1, [W15]
00595A  3C0008     BRA GT, .L6, .LSM18
00595C  90004E     MOV [W14+8], W0
00595E  9000DE     MOV [W14+10], W1
005960  BE011E     MOV.D [W14], W2
005962  510F80     SUB W2, W0, [W15]
005964  598F81     SUBB W3, W1, [W15]
005966  350002     BRA LT, .L6, .LSM18
62:                	{
63:                		return ((int16_t)total );
005968  78001E     MOV [W14], W0
00596A  370007     BRA .L7, .LSM21
64:                	}
65:                	else if ( total > 0 )
00596C  BE001E     MOV.D [W14], W0
00596E  500FE0     SUB W0, #0x0, [W15]
005970  588FE0     SUBB W1, #0x0, [W15]
005972  340002     BRA LE, .L8, .LSM20
66:                	{
67:                		return ((int16_t)maximum) ;
005974  90002E     MOV [W14+4], W0
005976  370001     BRA .L7, .LSM21
68:                	}
69:                	else
70:                	{
71:                		return ((int16_t)minimum) ;
005978  90004E     MOV [W14+8], W0
72:                	}
73:                }
00597A  FA8000     ULNK
00597C  060000     RETURN
74:                
75:                
76:                
77:                #define RADIANTOCIRCULAR 10430
78:                
79:                void vect2_16x16_rotate(vect2_16t* vector, const vect2_16t* rotate)
80:                {
00597E  FA000A     LNK #0xA
005980  980730     MOV W0, [W14+6]
005982  980741     MOV W1, [W14+8]
81:                	// rotate the vector by the implicit angle of rotate
82:                	// rotate is RMAX*[ cosine(theta), sine(theta) ], theta is the desired rotation angle
83:                	// upon exit, the vector [ x, y ] will be rotated by the angle theta.
84:                	// theta is positive in the counter clockwise direction.
85:                	// This routine can also be used to do a complex multiply, with 1/RMAX scaling,
86:                	// and where vector and rotate are viewed as complex numbers
87:                	union longww accum;
88:                	int16_t newx;
89:                
90:                	accum.WW = ((__builtin_mulss(rotate->x, vector->x) - __builtin_mulss(rotate->y, vector->y)) << 2);
005984  90003E     MOV [W14+6], W0
005986  780090     MOV [W0], W1
005988  90004E     MOV [W14+8], W0
00598A  780010     MOV [W0], W0
00598C  B98101     MUL.SS W0, W1, W2
00598E  90003E     MOV [W14+6], W0
005990  900090     MOV [W0+2], W1
005992  90004E     MOV [W14+8], W0
005994  900010     MOV [W0+2], W0
005996  B98001     MUL.SS W0, W1, W0
005998  510100     SUB W2, W0, W2
00599A  598181     SUBB W3, W1, W3
00599C  DD1842     SL W3, #2, W0
00599E  DE10CE     LSR W2, #14, W1
0059A0  700081     IOR W0, W1, W1
0059A2  DD1042     SL W2, #2, W0
0059A4  980710     MOV W0, [W14+2]
0059A6  980721     MOV W1, [W14+4]
91:                	newx = accum._.W1;
0059A8  90002E     MOV [W14+4], W0
0059AA  780F00     MOV W0, [W14]
92:                	accum.WW = ((__builtin_mulss(rotate->y, vector->x) + __builtin_mulss(rotate->x, vector->y)) << 2);
0059AC  90003E     MOV [W14+6], W0
0059AE  780090     MOV [W0], W1
0059B0  90004E     MOV [W14+8], W0
0059B2  900010     MOV [W0+2], W0
0059B4  B98101     MUL.SS W0, W1, W2
0059B6  90003E     MOV [W14+6], W0
0059B8  900090     MOV [W0+2], W1
0059BA  90004E     MOV [W14+8], W0
0059BC  780010     MOV [W0], W0
0059BE  B98001     MUL.SS W0, W1, W0
0059C0  400102     ADD W0, W2, W2
0059C2  488183     ADDC W1, W3, W3
0059C4  DD1842     SL W3, #2, W0
0059C6  DE10CE     LSR W2, #14, W1
0059C8  700081     IOR W0, W1, W1
0059CA  DD1042     SL W2, #2, W0
0059CC  980710     MOV W0, [W14+2]
0059CE  980721     MOV W1, [W14+4]
93:                	vector->y = accum._.W1;
0059D0  9000AE     MOV [W14+4], W1
0059D2  90003E     MOV [W14+6], W0
0059D4  980011     MOV W1, [W0+2]
94:                	vector->x = newx;
0059D6  90003E     MOV [W14+6], W0
0059D8  78081E     MOV [W14], [W0]
95:                }
0059DA  FA8000     ULNK
0059DC  060000     RETURN
96:                
97:                void vect2_32x16_rotate(vect2_32t* vector, const vect2_16t* rotate)
98:                {
0059DE  FA0008     LNK #0x8
0059E0  BE9F88     MOV.D W8, [W15++]
0059E2  980720     MOV W0, [W14+4]
0059E4  980731     MOV W1, [W14+6]
99:                	// same as vect2_16x16_rotate, except the first vector is 32 bits
100:               	int32_t newx;
101:               
102:               	newx      = long_scale(vector->x, rotate->x) - long_scale(vector->y, rotate->y);
0059E6  90003E     MOV [W14+6], W0
0059E8  780110     MOV [W0], W2
0059EA  90002E     MOV [W14+4], W0
0059EC  BE0010     MOV.D [W0], W0
0059EE  024F30     CALL long_scale
0059F0  000000     NOP
0059F2  BE0400     MOV.D W0, W8
0059F4  90003E     MOV [W14+6], W0
0059F6  900110     MOV [W0+2], W2
0059F8  90002E     MOV [W14+4], W0
0059FA  9000B0     MOV [W0+6], W1
0059FC  900020     MOV [W0+4], W0
0059FE  024F30     CALL long_scale
005A00  000000     NOP
005A02  541F00     SUB W8, W0, [W14++]
005A04  5C9701     SUBB W9, W1, [W14--]
103:               	vector->y = long_scale(vector->x, rotate->y) + long_scale(vector->y, rotate->x);
005A06  90003E     MOV [W14+6], W0
005A08  900110     MOV [W0+2], W2
005A0A  90002E     MOV [W14+4], W0
005A0C  BE0010     MOV.D [W0], W0
005A0E  024F30     CALL long_scale
005A10  000000     NOP
005A12  BE0400     MOV.D W0, W8
005A14  90003E     MOV [W14+6], W0
005A16  780110     MOV [W0], W2
005A18  90002E     MOV [W14+4], W0
005A1A  9000B0     MOV [W0+6], W1
005A1C  900020     MOV [W0+4], W0
005A1E  024F30     CALL long_scale
005A20  000000     NOP
005A22  400008     ADD W0, W8, W0
005A24  488089     ADDC W1, W9, W1
005A26  90012E     MOV [W14+4], W2
005A28  980120     MOV W0, [W2+4]
005A2A  980131     MOV W1, [W2+6]
104:               	vector->x = newx;
005A2C  90002E     MOV [W14+4], W0
005A2E  BE011E     MOV.D [W14], W2
005A30  BE8802     MOV.D W2, [W0]
105:               }
005A32  BE044F     MOV.D [--W15], W8
005A34  FA8000     ULNK
005A36  060000     RETURN
106:               
107:               void vect2_16phi_rotate(vect2_16t* vector, int8_t angle)
108:               {
005A38  FA0008     LNK #0x8
005A3A  980720     MOV W0, [W14+4]
005A3C  984761     MOV.B W1, [W14+6]
109:               	// rotate the vector by an angle, phi
110:               	// where vector is [ x, y ], angle is in byte-circular scaling
111:               	vect2_16t rotate;
112:               
113:               	rotate.y = sine(angle);
005A3E  90406E     MOV.B [W14+6], W0
005A40  0248B4     CALL sine
005A42  000000     NOP
005A44  980710     MOV W0, [W14+2]
114:               	rotate.x = cosine(angle);
005A46  90406E     MOV.B [W14+6], W0
005A48  0249B0     CALL cosine
005A4A  000000     NOP
005A4C  780F00     MOV W0, [W14]
115:               	vect2_16x16_rotate(vector, &rotate);
005A4E  78008E     MOV W14, W1
005A50  90002E     MOV [W14+4], W0
005A52  07FF95     RCALL vect2_16x16_rotate
116:               }
005A54  FA8000     ULNK
005A56  060000     RETURN
117:               
118:               int8_t vect2_polar(polar_16t* polar, const vect2_16t* vector)
119:               {
005A58  FA000E     LNK #0xE
005A5A  980750     MOV W0, [W14+10]
005A5C  980761     MOV W1, [W14+12]
120:               	// Convert from rectangular to polar coordinates using "CORDIC" arithmetic, which is basically
121:               	// a binary search for the angle.
122:               	// As a by product, the xy is rotated onto the x axis, so that y is driven to zero,
123:               	// and the magnitude of the vector winds up as the x component.
124:               	int16_t scaleShift = 0;
005A5E  EB0000     CLR W0
005A60  780F00     MOV W0, [W14]
125:               	int8_t theta = 0;
005A62  EB4000     CLR.B W0
005A64  984720     MOV.B W0, [W14+2]
126:               	int8_t delta_theta = 64;
005A66  B3C400     MOV.B #0x40, W0
005A68  984730     MOV.B W0, [W14+3]
127:               	int8_t theta_rot;
128:               //	int8_t steps = 7;
129:               	vect2_16t xy;
130:               
131:               	if (((vector->x) <  255) && ((vector->x) > -255) &&
005A6A  90006E     MOV [W14+12], W0
005A6C  780090     MOV [W0], W1
005A6E  200FE0     MOV #0xFE, W0
005A70  508F80     SUB W1, W0, [W15]
005A72  3C0011     BRA GT, .L13, .LSM48
005A74  90006E     MOV [W14+12], W0
005A76  780090     MOV [W0], W1
005A78  2FF020     MOV #0xFF02, W0
005A7A  508F80     SUB W1, W0, [W15]
005A7C  35000C     BRA LT, .L13, .LSM48
005A82  200FE0     MOV #0xFE, W0
005A84  508F80     SUB W1, W0, [W15]
005A86  3C0007     BRA GT, .L13, .LSM48
132:               		((vector->y) <  255) &&	((vector->y) > -255))
005A7E  90006E     MOV [W14+12], W0
005A80  900090     MOV [W0+2], W1
005A88  90006E     MOV [W14+12], W0
005A8A  900090     MOV [W0+2], W1
005A8C  2FF020     MOV #0xFF02, W0
005A8E  508F80     SUB W1, W0, [W15]
005A90  350002     BRA LT, .L13, .LSM48
133:               	{
134:               		scaleShift = 6;
005A92  200060     MOV #0x6, W0
005A94  780F00     MOV W0, [W14]
135:               	}
136:               	xy.x = (vector->x << scaleShift);
005A96  90006E     MOV [W14+12], W0
005A98  780090     MOV [W0], W1
005A9A  78001E     MOV [W14], W0
005A9C  DD0800     SL W1, W0, W0
005A9E  980730     MOV W0, [W14+6]
137:               	xy.y = (vector->y << scaleShift);
005AA0  90006E     MOV [W14+12], W0
005AA2  900090     MOV [W0+2], W1
005AA4  78001E     MOV [W14], W0
005AA6  DD0800     SL W1, W0, W0
005AA8  980740     MOV W0, [W14+8]
138:               #if 0
139:               	while (steps > 0) // TODO: we could do away with 'steps' and instead test delta_theta for non-zero at the end of a do loop
140:               	{
141:               		theta_rot = delta_theta;
142:               		if (xy.y > 0) theta_rot = -theta_rot;
143:               		vect2_16phi_rotate(&xy, theta_rot);
144:               		theta += theta_rot;
145:               		delta_theta = (delta_theta >> 1);
146:               		steps--;
147:               	}
148:               #else
149:               	do {
150:               		theta_rot = delta_theta;
005AAA  90403E     MOV.B [W14+3], W0
005AAC  984740     MOV.B W0, [W14+4]
151:               		if (xy.y > 0) theta_rot = -theta_rot;
005AAE  90004E     MOV [W14+8], W0
005AB0  500FE0     SUB W0, #0x0, [W15]
005AB2  340003     BRA LE, .L14, .LSM52
005AB4  90404E     MOV.B [W14+4], W0
005AB6  EA4000     NEG.B W0, W0
005AB8  984740     MOV.B W0, [W14+4]
152:               		vect2_16phi_rotate(&xy, theta_rot);
005ABA  470066     ADD W14, #0x6, W0
005ABC  9040CE     MOV.B [W14+4], W1
005ABE  07FFBC     RCALL vect2_16phi_rotate
153:               		theta += theta_rot;
005AC0  9040AE     MOV.B [W14+2], W1
005AC2  90404E     MOV.B [W14+4], W0
005AC4  40C000     ADD.B W1, W0, W0
005AC6  984720     MOV.B W0, [W14+2]
154:               		delta_theta = (delta_theta >> 1);
005AC8  90403E     MOV.B [W14+3], W0
005ACA  FB0000     SE W0, W0
005ACC  D18000     ASR W0, W0
005ACE  984730     MOV.B W0, [W14+3]
155:               	} while (delta_theta);
005AD0  90403E     MOV.B [W14+3], W0
005AD2  504FE0     SUB.B W0, #0x0, [W15]
005AD4  3AFFEA     BRA NZ, .L15, .LSM50
156:               #endif
157:               	if (xy.y > 0) theta--;
005AD6  90004E     MOV [W14+8], W0
005AD8  500FE0     SUB W0, #0x0, [W15]
005ADA  340003     BRA LE, .L16, .LSM57
005ADC  90402E     MOV.B [W14+2], W0
005ADE  E94000     DEC.B W0, W0
005AE0  984720     MOV.B W0, [W14+2]
158:               	if (polar != NULL) {
005AE2  90005E     MOV [W14+10], W0
005AE4  500FE0     SUB W0, #0x0, [W15]
005AE6  320009     BRA Z, .L17, .LSM60
159:               		polar->r = (xy.x >> scaleShift);
005AE8  9000BE     MOV [W14+6], W1
005AEA  78001E     MOV [W14], W0
005AEC  DE8880     ASR W1, W0, W1
005AEE  90005E     MOV [W14+10], W0
005AF0  780801     MOV W1, [W0]
160:               //		polar->p = (xy.y >> scaleShift);
161:               		polar->p = -theta;
005AF2  90402E     MOV.B [W14+2], W0
005AF4  EA4000     NEG.B W0, W0
005AF6  9000DE     MOV [W14+10], W1
005AF8  9840A0     MOV.B W0, [W1+2]
162:               	}
163:               	return (-theta);
005AFA  90402E     MOV.B [W14+2], W0
005AFC  EA4000     NEG.B W0, W0
164:               }
005AFE  FA8000     ULNK
005B00  060000     RETURN
165:               
166:               int16_t vect2_polar_16(polar_32t* polar, const vect2_16t* vector)
167:               {
005B02  FA0010     LNK #0x10
005B04  980760     MOV W0, [W14+12]
005B06  980771     MOV W1, [W14+14]
168:               	// Convert from rectangular to polar coordinates using "CORDIC" arithmetic, which is basically
169:               	// a binary search for the angle.
170:               	// As a by product, the xy is rotated onto the x axis, so that y is driven to zero,
171:               	// and the magnitude of the vector winds up as the x component.
172:               	// Returns a value as a 16 bit "circular" so that 180 degrees yields 2**15
173:               	int16_t scaleShift = 0;
005B08  EB0000     CLR W0
005B0A  780F00     MOV W0, [W14]
174:               	int16_t theta16;
175:               	int8_t theta = 0;
005B0C  EB4000     CLR.B W0
005B0E  984740     MOV.B W0, [W14+4]
176:               	int8_t delta_theta = 64;
005B10  B3C400     MOV.B #0x40, W0
005B12  984750     MOV.B W0, [W14+5]
177:               	int8_t theta_rot;
178:               //	int8_t steps = 7;
179:               	vect2_16t xy;
180:               
181:               	if (((vector->x) <  255) && ((vector->x) > -255) &&
005B14  90007E     MOV [W14+14], W0
005B16  780090     MOV [W0], W1
005B18  200FE0     MOV #0xFE, W0
005B1A  508F80     SUB W1, W0, [W15]
005B1C  3C0011     BRA GT, .L19, .LSM71
005B1E  90007E     MOV [W14+14], W0
005B20  780090     MOV [W0], W1
005B22  2FF020     MOV #0xFF02, W0
005B24  508F80     SUB W1, W0, [W15]
005B26  35000C     BRA LT, .L19, .LSM71
005B2C  200FE0     MOV #0xFE, W0
005B2E  508F80     SUB W1, W0, [W15]
005B30  3C0007     BRA GT, .L19, .LSM71
182:               		((vector->y) <  255) &&	((vector->y) > -255))
005B28  90007E     MOV [W14+14], W0
005B2A  900090     MOV [W0+2], W1
005B32  90007E     MOV [W14+14], W0
005B34  900090     MOV [W0+2], W1
005B36  2FF020     MOV #0xFF02, W0
005B38  508F80     SUB W1, W0, [W15]
005B3A  350002     BRA LT, .L19, .LSM71
183:               	{
184:               		scaleShift = 6;
005B3C  200060     MOV #0x6, W0
005B3E  780F00     MOV W0, [W14]
185:               	}
186:               	xy.x = (vector->x << scaleShift);
005B40  90007E     MOV [W14+14], W0
005B42  780090     MOV [W0], W1
005B44  78001E     MOV [W14], W0
005B46  DD0800     SL W1, W0, W0
005B48  980740     MOV W0, [W14+8]
187:               	xy.y = (vector->y << scaleShift);
005B4A  90007E     MOV [W14+14], W0
005B4C  900090     MOV [W0+2], W1
005B4E  78001E     MOV [W14], W0
005B50  DD0800     SL W1, W0, W0
005B52  980750     MOV W0, [W14+10]
188:               #if 0
189:               	while (steps > 0) // TODO: we could do away with 'steps' and instead test delta_theta for non-zero at the end of a do loop
190:               	{
191:               		theta_rot = delta_theta;
192:               		if (xy.y > 0) theta_rot = -theta_rot;
193:               		vect2_16phi_rotate(&xy, theta_rot);
194:               		theta += theta_rot;
195:               		delta_theta = (delta_theta >> 1);
196:               		steps--;
197:               	}
198:               #else
199:               	do {
200:               		theta_rot = delta_theta;
005B54  90405E     MOV.B [W14+5], W0
005B56  984760     MOV.B W0, [W14+6]
201:               		if (xy.y > 0) theta_rot = -theta_rot;
005B58  90005E     MOV [W14+10], W0
005B5A  500FE0     SUB W0, #0x0, [W15]
005B5C  340003     BRA LE, .L20, .LSM75
005B5E  90406E     MOV.B [W14+6], W0
005B60  EA4000     NEG.B W0, W0
005B62  984760     MOV.B W0, [W14+6]
202:               		vect2_16phi_rotate(&xy, theta_rot);
005B64  470068     ADD W14, #0x8, W0
005B66  9040EE     MOV.B [W14+6], W1
005B68  07FF67     RCALL vect2_16phi_rotate
203:               		theta += theta_rot;
005B6A  9040CE     MOV.B [W14+4], W1
005B6C  90406E     MOV.B [W14+6], W0
005B6E  40C000     ADD.B W1, W0, W0
005B70  984740     MOV.B W0, [W14+4]
204:               		delta_theta = (delta_theta >> 1);
005B72  90405E     MOV.B [W14+5], W0
005B74  FB0000     SE W0, W0
005B76  D18000     ASR W0, W0
005B78  984750     MOV.B W0, [W14+5]
205:               	} while (delta_theta);
005B7A  90405E     MOV.B [W14+5], W0
005B7C  504FE0     SUB.B W0, #0x0, [W15]
005B7E  3AFFEA     BRA NZ, .L21, .LSM73
206:               #endif
207:               	theta = -theta;
005B80  90404E     MOV.B [W14+4], W0
005B82  EA4000     NEG.B W0, W0
005B84  984740     MOV.B W0, [W14+4]
208:               	theta16 = theta << 8;
005B86  90404E     MOV.B [W14+4], W0
005B88  FB0000     SE W0, W0
005B8A  DD0048     SL W0, #8, W0
005B8C  980710     MOV W0, [W14+2]
209:               	if (xy.x > 0)
005B8E  90004E     MOV [W14+8], W0
005B90  500FE0     SUB W0, #0x0, [W15]
005B92  34000B     BRA LE, .L22, .LSM83
210:               	{
211:               		theta16 += __builtin_divsd(__builtin_mulss(RADIANTOCIRCULAR, xy.y), xy.x);
005B94  90014E     MOV [W14+8], W2
005B96  9000DE     MOV [W14+10], W1
005B98  228BE0     MOV #0x28BE, W0
005B9A  B98001     MUL.SS W0, W1, W0
005B9C  781F81     MOV W1, [W15++]
005B9E  090011     REPEAT #0x11
005BA0  D80842     DIV.SD W0, W2
005BA2  7800CF     MOV [--W15], W1
005BA4  90009E     MOV [W14+2], W1
005BA6  408000     ADD W1, W0, W0
005BA8  980710     MOV W0, [W14+2]
212:               	}
213:               	if (polar != NULL) {
005BAA  90006E     MOV [W14+12], W0
005BAC  500FE0     SUB W0, #0x0, [W15]
005BAE  320009     BRA Z, .L23, .LSM86
214:               		polar->r = (xy.x >> scaleShift);
005BB0  9000CE     MOV [W14+8], W1
005BB2  78001E     MOV [W14], W0
005BB4  DE8800     ASR W1, W0, W0
005BB6  DE80CF     ASR W0, #15, W1
005BB8  90016E     MOV [W14+12], W2
005BBA  BE8900     MOV.D W0, [W2]
215:               //		polar->p = (xy.y >> scaleShift);
216:               		polar->p = theta16;
005BBC  90006E     MOV [W14+12], W0
005BBE  90009E     MOV [W14+2], W1
005BC0  980021     MOV W1, [W0+4]
217:               	}
218:               	return (theta16);
005BC2  90001E     MOV [W14+2], W0
219:               }
005BC4  FA8000     ULNK
005BC6  060000     RETURN
220:               
221:               uint16_t vect2_16_mag(const vect2_16t* v)
222:               {
005BC8  FA0006     LNK #0x6
005BCA  980720     MOV W0, [W14+4]
223:               	uint32_t magsqr = __builtin_mulss(v->x, v->x) + __builtin_mulss(v->y, v->y);
005BCC  90002E     MOV [W14+4], W0
005BCE  780090     MOV [W0], W1
005BD0  90002E     MOV [W14+4], W0
005BD2  780010     MOV [W0], W0
005BD4  B98101     MUL.SS W0, W1, W2
005BD6  90002E     MOV [W14+4], W0
005BD8  900090     MOV [W0+2], W1
005BDA  90002E     MOV [W14+4], W0
005BDC  900010     MOV [W0+2], W0
005BDE  B98001     MUL.SS W0, W1, W0
005BE0  400002     ADD W0, W2, W0
005BE2  488083     ADDC W1, W3, W1
005BE4  BE8F00     MOV.D W0, [W14]
224:               	return sqrt_long(magsqr);
005BE6  BE001E     MOV.D [W14], W0
005BE8  024D18     CALL sqrt_long
005BEA  000000     NOP
225:               }
005BEC  FA8000     ULNK
005BEE  060000     RETURN
226:               
227:               uint16_t vect3_16_mag(const vect3_16t* v)
228:               {
005BF0  FA0006     LNK #0x6
005BF2  980720     MOV W0, [W14+4]
229:               	uint32_t magsqr = __builtin_mulss(v->x, v->x) + __builtin_mulss(v->y, v->y) + __builtin_mulss(v->z, v->z);
005BF4  90002E     MOV [W14+4], W0
005BF6  780090     MOV [W0], W1
005BF8  90002E     MOV [W14+4], W0
005BFA  780010     MOV [W0], W0
005BFC  B98101     MUL.SS W0, W1, W2
005BFE  90002E     MOV [W14+4], W0
005C00  900090     MOV [W0+2], W1
005C02  90002E     MOV [W14+4], W0
005C04  900010     MOV [W0+2], W0
005C06  B98001     MUL.SS W0, W1, W0
005C08  400102     ADD W0, W2, W2
005C0A  488183     ADDC W1, W3, W3
005C0C  90002E     MOV [W14+4], W0
005C0E  9000A0     MOV [W0+4], W1
005C10  90002E     MOV [W14+4], W0
005C12  900020     MOV [W0+4], W0
005C14  B98001     MUL.SS W0, W1, W0
005C16  400002     ADD W0, W2, W0
005C18  488083     ADDC W1, W3, W1
005C1A  BE8F00     MOV.D W0, [W14]
230:               	return sqrt_long(magsqr);
005C1C  BE001E     MOV.D [W14], W0
005C1E  024D18     CALL sqrt_long
005C20  000000     NOP
231:               }
005C22  FA8000     ULNK
005C24  060000     RETURN
232:               
233:               uint16_t vect2_16_norm(vect2_16t* result, const vect2_16t* v)
234:               {
005C26  FA0006     LNK #0x6
005C28  980710     MOV W0, [W14+2]
005C2A  980721     MOV W1, [W14+4]
235:               	uint16_t mag = vect2_16_mag(v);
005C2C  90002E     MOV [W14+4], W0
005C2E  07FFCC     RCALL vect2_16_mag
005C30  780F00     MOV W0, [W14]
236:               	if (mag > 0)
005C32  78001E     MOV [W14], W0
005C34  500FE0     SUB W0, #0x0, [W15]
005C36  320019     BRA Z, .L27, .LSM101
237:               	{
238:               		result->x = __builtin_divsd(__builtin_mulss(RMAX, v->x), mag);
005C38  78011E     MOV [W14], W2
005C3A  90002E     MOV [W14+4], W0
005C3C  780090     MOV [W0], W1
005C3E  240000     MOV #0x4000, W0
005C40  B98001     MUL.SS W0, W1, W0
005C42  781F80     MOV W0, [W15++]
005C44  090011     REPEAT #0x11
005C46  D80842     DIV.SD W0, W2
005C48  780080     MOV W0, W1
005C4A  78004F     MOV [--W15], W0
005C4C  90001E     MOV [W14+2], W0
005C4E  780801     MOV W1, [W0]
239:               		result->y = __builtin_divsd(__builtin_mulss(RMAX, v->y), mag);
005C50  78011E     MOV [W14], W2
005C52  90002E     MOV [W14+4], W0
005C54  900090     MOV [W0+2], W1
005C56  240000     MOV #0x4000, W0
005C58  B98001     MUL.SS W0, W1, W0
005C5A  781F80     MOV W0, [W15++]
005C5C  090011     REPEAT #0x11
005C5E  D80842     DIV.SD W0, W2
005C60  780080     MOV W0, W1
005C62  78004F     MOV [--W15], W0
005C64  90001E     MOV [W14+2], W0
005C66  980011     MOV W1, [W0+2]
005C68  370007     BRA .L28, .LSM102
240:               	}
241:               	else
242:               	{
243:               		result->x = result->y = 0;
005C6A  90001E     MOV [W14+2], W0
005C6C  EB0080     CLR W1
005C6E  980011     MOV W1, [W0+2]
005C70  90001E     MOV [W14+2], W0
005C72  900090     MOV [W0+2], W1
005C74  90001E     MOV [W14+2], W0
005C76  780801     MOV W1, [W0]
244:               	}
245:               	return mag;
005C78  78001E     MOV [W14], W0
246:               }
005C7A  FA8000     ULNK
005C7C  060000     RETURN
247:               
248:               uint16_t vect3_16_norm(vect3_16t* result, const vect3_16t* v)
249:               {
005C7E  FA0006     LNK #0x6
005C80  980710     MOV W0, [W14+2]
005C82  980721     MOV W1, [W14+4]
250:               	uint16_t mag = vect3_16_mag(v);
005C84  90002E     MOV [W14+4], W0
005C86  07FFB4     RCALL vect3_16_mag
005C88  780F00     MOV W0, [W14]
251:               	if (mag > 0)
005C8A  78001E     MOV [W14], W0
005C8C  500FE0     SUB W0, #0x0, [W15]
005C8E  320025     BRA Z, .L30, .LSM110
252:               	{
253:               		result->x = __builtin_divsd(__builtin_mulss(RMAX, v->x), mag);
005C90  78011E     MOV [W14], W2
005C92  90002E     MOV [W14+4], W0
005C94  780090     MOV [W0], W1
005C96  240000     MOV #0x4000, W0
005C98  B98001     MUL.SS W0, W1, W0
005C9A  781F80     MOV W0, [W15++]
005C9C  090011     REPEAT #0x11
005C9E  D80842     DIV.SD W0, W2
005CA0  780080     MOV W0, W1
005CA2  78004F     MOV [--W15], W0
005CA4  90001E     MOV [W14+2], W0
005CA6  780801     MOV W1, [W0]
254:               		result->y = __builtin_divsd(__builtin_mulss(RMAX, v->y), mag);
005CA8  78011E     MOV [W14], W2
005CAA  90002E     MOV [W14+4], W0
005CAC  900090     MOV [W0+2], W1
005CAE  240000     MOV #0x4000, W0
005CB0  B98001     MUL.SS W0, W1, W0
005CB2  781F80     MOV W0, [W15++]
005CB4  090011     REPEAT #0x11
005CB6  D80842     DIV.SD W0, W2
005CB8  780080     MOV W0, W1
005CBA  78004F     MOV [--W15], W0
005CBC  90001E     MOV [W14+2], W0
005CBE  980011     MOV W1, [W0+2]
255:               		result->z = __builtin_divsd(__builtin_mulss(RMAX, v->z), mag);
005CC0  78011E     MOV [W14], W2
005CC2  90002E     MOV [W14+4], W0
005CC4  9000A0     MOV [W0+4], W1
005CC6  240000     MOV #0x4000, W0
005CC8  B98001     MUL.SS W0, W1, W0
005CCA  781F80     MOV W0, [W15++]
005CCC  090011     REPEAT #0x11
005CCE  D80842     DIV.SD W0, W2
005CD0  780080     MOV W0, W1
005CD2  78004F     MOV [--W15], W0
005CD4  90001E     MOV [W14+2], W0
005CD6  980021     MOV W1, [W0+4]
005CD8  37000B     BRA .L31, .LSM111
256:               	}
257:               	else
258:               	{
259:               		result->x = result->y = result->z = 0;
005CDA  90001E     MOV [W14+2], W0
005CDC  EB0080     CLR W1
005CDE  980021     MOV W1, [W0+4]
005CE0  90001E     MOV [W14+2], W0
005CE2  9000A0     MOV [W0+4], W1
005CE4  90001E     MOV [W14+2], W0
005CE6  980011     MOV W1, [W0+2]
005CE8  90001E     MOV [W14+2], W0
005CEA  900090     MOV [W0+2], W1
005CEC  90001E     MOV [W14+2], W0
005CEE  780801     MOV W1, [W0]
260:               	}
261:               	return mag;
005CF0  78001E     MOV [W14], W0
262:               }
005CF2  FA8000     ULNK
005CF4  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libDCM/libDCM.c  ------------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libDCM.h"
23:                #include "gpsData.h"
24:                #include "gpsParseCommon.h"
25:                #include "../libUDB/heartbeat.h"
26:                #include "../libUDB/magnetometer.h"
27:                #include "../libUDB/barometer.h"
28:                #include "../libUDB/ADchannel.h"
29:                #include "estAltitude.h"
30:                #include "mathlibNAV.h"
31:                #include "rmat.h"
32:                #include "mag_drift.h"
33:                
34:                
35:                union dcm_fbts_word dcm_flags;
36:                int16_t angleOfAttack;
37:                
38:                void send_HILSIM_outputs(void);
39:                
40:                void SetAofA(int16_t AofA)
41:                {
007408  FA0002     LNK #0x2
00740A  780F00     MOV W0, [W14]
42:                	angleOfAttack = AofA;
00740C  78001E     MOV [W14], W0
00740E  88F300     MOV W0, angleOfAttack
43:                }
007410  FA8000     ULNK
007412  060000     RETURN
44:                
45:                int16_t GetAofA(void)
46:                {
007414  FA0000     LNK #0x0
47:                	return angleOfAttack;
007416  80F300     MOV angleOfAttack, W0
48:                }
007418  FA8000     ULNK
00741A  060000     RETURN
49:                
50:                
51:                void offsets_init(void)
52:                {
00741C  FA0000     LNK #0x0
53:                	
54:                	udb_xaccel.offset = XACCEL_OFFSET ;
00741E  2009F0     MOV #0x9F, W0
007420  88E480     MOV W0, 0x1C90
55:                	udb_yaccel.offset = YACCEL_OFFSET ;
007422  200260     MOV #0x26, W0
007424  88E4D0     MOV W0, 0x1C9A
56:                	udb_zaccel.offset = ZACCEL_OFFSET ;
007426  2FE110     MOV #0xFE11, W0
007428  88E520     MOV W0, 0x1CA4
57:                //	udb_xrate.offset  = XRATE_OFFSET;
58:                //	udb_yrate.offset  = YRATE_OFFSET;
59:                //	udb_zrate.offset  = ZRATE_OFFSET;
60:                }
00742A  FA8000     ULNK
00742C  060000     RETURN
61:                
62:                
63:                void dcm_init(void)
64:                {
00742E  FA0000     LNK #0x0
65:                	dcm_flags.W = 0;
007430  EB0000     CLR W0
007432  88F2F0     MOV W0, dcm_flags
66:                	dcm_flags._.first_mag_reading = 1;
007434  80F2F1     MOV dcm_flags, W1
007436  200800     MOV #0x80, W0
007438  708000     IOR W1, W0, W0
00743A  88F2F0     MOV W0, dcm_flags
67:                	dcm_init_rmat();
00743C  0234C8     CALL dcm_init_rmat
00743E  000000     NOP
68:                }
007440  FA8000     ULNK
007442  060000     RETURN
69:                
70:                #if (DCM_CALIB_COUNT > DCM_GPS_COUNT)
71:                #error here
72:                #endif
73:                
74:                void dcm_run_calib_step(uint16_t count)
75:                {
007444  FA0002     LNK #0x2
007446  780F00     MOV W0, [W14]
76:                	if (count == DCM_CALIB_COUNT)
007448  200500     MOV #0x50, W0
00744A  78009E     MOV [W14], W1
00744C  508F80     SUB W1, W0, [W15]
00744E  3A0005     BRA NZ, .L5, .LSM20
77:                	{
78:                		DPRINT("calib_finished\r\n");
79:                		dcm_flags._.calib_finished = 1;
007450  80F2F1     MOV dcm_flags, W1
007452  240000     MOV #0x4000, W0
007454  708000     IOR W1, W0, W0
007456  88F2F0     MOV W0, dcm_flags
80:                		dcm_calibrate();    // Finish calibration
007458  07005A     RCALL dcm_calibrate
81:                	}
82:                }
00745A  FA8000     ULNK
00745C  060000     RETURN
83:                
84:                static boolean gps_run_init_step(uint16_t count)
85:                {
00745E  FA0002     LNK #0x2
007460  780F00     MOV W0, [W14]
86:                	if (count <= DCM_GPS_COUNT)
007462  203E80     MOV #0x3E8, W0
007464  78009E     MOV [W14], W1
007466  508F80     SUB W1, W0, [W15]
007468  3E0006     BRA GTU, .L8, .LSM25
87:                	{
88:                		gps_startup_sequence(DCM_GPS_COUNT - count); // Counts down from GPS_COUNT to 0
00746A  203E80     MOV #0x3E8, W0
00746C  50001E     SUB W0, [W14], W0
00746E  02614E     CALL gps_startup_sequence
007470  000000     NOP
89:                	}
90:                	else
91:                	{
92:                		DPRINT("init_finished\r\n");
93:                		return true;    // indicate that we are done
007476  B3C010     MOV.B #0x1, W0
94:                	}
95:                	return false;
007472  EB4000     CLR.B W0
007474  370001     BRA .L9, .LSM26
96:                }
007478  FA8000     ULNK
00747A  060000     RETURN
97:                
98:                
99:                // We want to be returning reading from both the magnetometer and the barometer at 4Hz.
100:               // However each device may need to be called many times before a reading is returned.
101:               // The code below ensures that a given sensor is called repeatedly until it reaches
102:               // a state where the other device can be called safely over the same I2C2 bus, even if 
103:               // the first device has not yet returned a complete set of sensor data.
104:               // For example, at startup the barometer could need 9 calls before returning pressure.
105:               // But in normal operation it will need 5 calls.
106:               // By contrast in normal operations the magnetometer only needs one call, once it is calibrated.
107:               
108:               void get_data_from_I2C_sensors(void) // Expected to be called at 40Hz
109:               {
00747C  FA0000     LNK #0x0
110:               	static uint8_t barometer_needs_servicing = BAROMETER_SERVICE_CAN_PAUSE;
111:               	static uint8_t magnetometer_needs_servicing = MAGNETOMETER_SERVICE_CAN_PAUSE;
112:               	static uint8_t counter_40Hz = 0;
113:               	
114:               	// Split a 1 second interval (40 calls) into 8 interleaved segments using the following logic
115:               	if ((counter_40Hz == 0) || (counter_40Hz == 10) || (counter_40Hz == 20) || ( counter_40Hz == 30))
00747E  21E620     MOV #0x1E62, W0
007480  784010     MOV.B [W0], W0
007482  504FE0     SUB.B W0, #0x0, [W15]
007484  32000C     BRA Z, .L11, .LSM29
007486  21E620     MOV #0x1E62, W0
007488  784010     MOV.B [W0], W0
00748A  504FEA     SUB.B W0, #0xA, [W15]
00748C  320008     BRA Z, .L11, .LSM29
00748E  21E620     MOV #0x1E62, W0
007490  784010     MOV.B [W0], W0
007492  504FF4     SUB.B W0, #0x14, [W15]
007494  320004     BRA Z, .L11, .LSM29
007496  21E620     MOV #0x1E62, W0
007498  784010     MOV.B [W0], W0
00749A  504FFE     SUB.B W0, #0x1E, [W15]
00749C  320000     BRA Z, .L11, .LSM29
116:               	{
117:               #if (USE_BAROMETER_ALTITUDE == 1 && HILSIM != 1)
118:               		barometer_needs_servicing = rxBarometer(udb_barometer_callback);
119:               #endif // (USE_BAROMETER_ALTITUDE == 1 && HILSIM != 1)
120:               	}
121:               	else if // Allow a total of 6 consecutive calls to the barometer to return pressure
122:               		(((counter_40Hz >= 1) && (counter_40Hz <= 5))
123:               		|| ((counter_40Hz >= 11) && (counter_40Hz <= 15))
124:               		|| ((counter_40Hz >= 21) && (counter_40Hz <= 25))
125:               		|| ((counter_40Hz >= 31) && (counter_40Hz <= 35)))
126:               	{
127:               		if (barometer_needs_servicing)
128:               		{
129:               #if (USE_BAROMETER_ALTITUDE == 1 && HILSIM != 1)
130:               			barometer_needs_servicing = rxBarometer(udb_barometer_callback);
131:               #endif // (USE_BAROMETER_ALTITUDE == 1 && HILSIM != 1)
132:               		}
133:               	}
134:               	else if ((counter_40Hz == 6) || (counter_40Hz == 16) || (counter_40Hz == 26) || ( counter_40Hz == 36))
135:               	{
136:               #if (MAG_YAW_DRIFT == 1)
137:               		magnetometer_needs_servicing = rxMagnetometer(mag_drift_callback);
138:               #endif // (MAG_YAW_DRIFT == 1)
139:               	}
140:               	else // Should be my_modulo at 7,8,9  17,18,19   27,28,29  37,38,39 : a total of 4 consecutively calls to mag.
141:               	{
142:               		if (magnetometer_needs_servicing)
143:               		{
144:               #if (MAG_YAW_DRIFT == 1 && HILSIM != 1)
145:               			magnetometer_needs_servicing = rxMagnetometer(mag_drift_callback);
146:               #endif  // (MAG_YAW_DRIFT == 1 && HILSIM != 1)
147:               		}	   
148:               	}
149:               	counter_40Hz++;
00749E  21E620     MOV #0x1E62, W0
0074A0  784010     MOV.B [W0], W0
0074A2  E84000     INC.B W0, W0
0074A4  21E621     MOV #0x1E62, W1
0074A6  784880     MOV.B W0, [W1]
150:               	if (counter_40Hz >= 40) counter_40Hz = 0;
0074A8  21E620     MOV #0x1E62, W0
0074AA  784090     MOV.B [W0], W1
0074AC  B3C270     MOV.B #0x27, W0
0074AE  50CF80     SUB.B W1, W0, [W15]
0074B0  360003     BRA LEU, .L10, .LSM31
0074B2  21E621     MOV #0x1E62, W1
0074B4  EB4000     CLR.B W0
0074B6  784880     MOV.B W0, [W1]
151:               }
0074B8  FA8000     ULNK
0074BA  060000     RETURN
152:               
153:               // Called at HEARTBEAT_HZ
154:               void udb_heartbeat_callback(void)
155:               {
0074BC  FA0000     LNK #0x0
156:               	if (udb_pulse_counter % (HEARTBEAT_HZ / 40) == 0)
0074BE  80F411     MOV 0x1E82, W1
0074C0  200050     MOV #0x5, W0
0074C2  780100     MOV W0, W2
0074C4  090011     REPEAT #0x11
0074C6  D88082     DIV.UW W1, W2
0074C8  FD0080     EXCH W0, W1
0074CA  500FE0     SUB W0, #0x0, [W15]
0074CC  3A0001     BRA NZ, .L14, .LSM35
157:               	{
158:               		get_data_from_I2C_sensors(); // TODO: this should always be be called at 40Hz
0074CE  07FFD6     RCALL get_data_from_I2C_sensors
159:               	}
160:               //  when we move the IMU step to the MPU call back, to run at 200 Hz, remove this
161:               	if (dcm_flags._.calib_finished)
0074D0  80F2F1     MOV dcm_flags, W1
0074D2  240000     MOV #0x4000, W0
0074D4  608000     AND W1, W0, W0
0074D6  500FE0     SUB W0, #0x0, [W15]
0074D8  320003     BRA Z, .L15, .LSM37
162:               	{
163:               		dcm_run_imu_step(angleOfAttack);
0074DA  80F300     MOV angleOfAttack, W0
0074DC  023C66     CALL dcm_run_imu_step
0074DE  000000     NOP
164:               	}
165:               
166:               	dcm_heartbeat_callback();    // this was called dcm_servo_callback_prepare_outputs();
0074E0  026C88     CALL dcm_heartbeat_callback
0074E2  000000     NOP
167:               
168:               	if (udb_pulse_counter % (HEARTBEAT_HZ / 40) == 0)
0074E4  80F411     MOV 0x1E82, W1
0074E6  200050     MOV #0x5, W0
0074E8  780100     MOV W0, W2
0074EA  090011     REPEAT #0x11
0074EC  D88082     DIV.UW W1, W2
0074EE  FD0080     EXCH W0, W1
0074F0  500FE0     SUB W0, #0x0, [W15]
0074F2  3A000B     BRA NZ, .L13, .LSM41
169:               	{
170:               		if (!dcm_flags._.calib_finished)
0074F4  80F2F1     MOV dcm_flags, W1
0074F6  240000     MOV #0x4000, W0
0074F8  608000     AND W1, W0, W0
0074FA  500FE0     SUB W0, #0x0, [W15]
0074FC  3A0006     BRA NZ, .L13, .LSM41
171:               		{
172:               			dcm_run_calib_step(udb_pulse_counter / (HEARTBEAT_HZ / 40));
0074FE  80F411     MOV 0x1E82, W1
007500  200050     MOV #0x5, W0
007502  780100     MOV W0, W2
007504  090011     REPEAT #0x11
007506  D88082     DIV.UW W1, W2
007508  07FF9D     RCALL dcm_run_calib_step
173:               		}
174:               		if ((!dcm_flags._.init_finished)&&(GPS_TYPE != GPS_NONE))
175:               		{
176:               			dcm_flags._.init_finished = gps_run_init_step(udb_pulse_counter / (HEARTBEAT_HZ / 40));
177:               		}
178:               	}
179:               
180:               #if (HILSIM == 1)
181:               	send_HILSIM_outputs();
182:               #endif
183:               }
00750A  FA8000     ULNK
00750C  060000     RETURN
184:               
185:               // dcm_calibrate is called twice during the startup sequence.
186:               // Firstly 10 seconds after startup, then immediately before the first waggle, which is 10 seconds after getting radio link.  
187:               // This makes sure we get initialized when there's no radio, or when bench testing, 
188:               // and 2nd time is at a time the user knows to keep the plane steady before a flight.
189:               void dcm_calibrate(void)
190:               {
00750E  FA0000     LNK #0x0
191:               	
192:               }
007510  FA8000     ULNK
007512  060000     RETURN
193:               
194:               void dcm_set_origin_location(int32_t o_lon, int32_t o_lat, int32_t o_alt)
195:               {
007514  FA0012     LNK #0x12
007516  980730     MOV W0, [W14+6]
007518  980741     MOV W1, [W14+8]
00751A  980752     MOV W2, [W14+10]
00751C  980763     MOV W3, [W14+12]
00751E  980774     MOV W4, [W14+14]
007520  980F05     MOV W5, [W14+16]
196:               	union longbbbb accum_nav;
197:               	unsigned char lat_cir;
198:               
199:               	lat_origin.WW = o_lat;
007522  90005E     MOV [W14+10], W0
007524  9000EE     MOV [W14+12], W1
007526  88EBC0     MOV W0, lat_origin
007528  88EBD1     MOV W1, 0x1D7A
200:               	lon_origin.WW = o_lon;
00752A  90003E     MOV [W14+6], W0
00752C  9000CE     MOV [W14+8], W1
00752E  88EBE0     MOV W0, lon_origin
007530  88EBF1     MOV W1, .L36
201:               	alt_origin.WW = o_alt;
007532  90007E     MOV [W14+14], W0
007534  90088E     MOV [W14+16], W1
007536  88EC00     MOV W0, alt_origin
007538  88EC11     MOV W1, 0x1D82
202:               
203:               	// scale the low 16 bits of latitude from GPS units to gentleNAV units
204:               	accum_nav.WW = __builtin_mulss(LONGDEG_2_BYTECIR, lat_origin._.W1);
00753A  80EBD1     MOV 0x1D7A, W1
00753C  201310     MOV #0x131, W0
00753E  B98001     MUL.SS W0, W1, W0
007540  980710     MOV W0, [W14+2]
007542  980721     MOV W1, [W14+4]
205:               
206:               	lat_cir = accum_nav.__.B2;  // effectively divides by 256
007544  9040CE     MOV.B [W14+4], W1
007546  784F01     MOV.B W1, [W14]
207:               	// estimate the cosine of the latitude, which is used later computing desired course
208:               	cos_lat = cosine(lat_cir);
007548  78401E     MOV.B [W14], W0
00754A  0249B0     CALL cosine
00754C  000000     NOP
00754E  88F060     MOV W0, 0x1E0C
209:               }
007550  FA8000     ULNK
007552  060000     RETURN
210:               
211:               struct relative3D dcm_absolute_to_relative(struct waypoint3D absolute)
212:               {
007554  FA0010     LNK #0x10
007556  BE9F88     MOV.D W8, [W15++]
007558  780400     MOV W0, W8
00755A  470066     ADD W14, #0x6, W0
00755C  780801     MOV W1, [W0]
00755E  980012     MOV W2, [W0+2]
007560  980023     MOV W3, [W0+4]
007562  980034     MOV W4, [W0+6]
007564  980045     MOV W5, [W0+8]
213:               	struct relative3D rel;
214:               
215:               	rel.z = absolute.z;
007566  470066     ADD W14, #0x6, W0
007568  900040     MOV [W0+8], W0
00756A  980720     MOV W0, [W14+4]
216:               	rel.y = (absolute.y - lat_origin.WW) / 90; // in meters
00756C  470066     ADD W14, #0x6, W0
00756E  900120     MOV [W0+4], W2
007570  9001B0     MOV [W0+6], W3
007572  80EBC0     MOV lat_origin, W0
007574  80EBD1     MOV 0x1D7A, W1
007576  510000     SUB W2, W0, W0
007578  598081     SUBB W3, W1, W1
00757A  2005A2     MOV #0x5A, W2
00757C  200003     MOV #0x0, W3
00757E  02102A     CALL ___divsi3
007580  000000     NOP
007582  780000     MOV W0, W0
007584  980710     MOV W0, [W14+2]
217:               	rel.x = long_scale((absolute.x - lon_origin.WW) / 90, cos_lat);
007586  80F069     MOV 0x1E0C, W9
007588  470066     ADD W14, #0x6, W0
00758A  BE0110     MOV.D [W0], W2
00758C  80EBE0     MOV lon_origin, W0
00758E  80EBF1     MOV .L36, W1
007590  510000     SUB W2, W0, W0
007592  598081     SUBB W3, W1, W1
007594  2005A2     MOV #0x5A, W2
007596  200003     MOV #0x0, W3
007598  02102A     CALL ___divsi3
00759A  000000     NOP
00759C  780109     MOV W9, W2
00759E  024F30     CALL long_scale
0075A0  000000     NOP
0075A2  780000     MOV W0, W0
0075A4  780F00     MOV W0, [W14]
218:               	return rel;
0075A6  BE001E     MOV.D [W14], W0
0075A8  BE8C00     MOV.D W0, [W8]
0075AA  9000AE     MOV [W14+4], W1
0075AC  980421     MOV W1, [W8+4]
219:               }
0075AE  780008     MOV W8, W0
0075B0  BE044F     MOV.D [--W15], W8
0075B2  FA8000     ULNK
0075B4  060000     RETURN
220:               
221:               #ifdef USE_EXTENDED_NAV
222:               struct relative3D_32 dcm_absolute_to_relative_32(struct waypoint3D absolute)
223:               {
224:               	struct relative3D_32 rel;
225:               
226:               	rel.z = absolute.z;
227:               	rel.y = (absolute.y - lat_origin.WW) / 90; // in meters
228:               	rel.x = long_scale((absolute.x - lon_origin.WW) / 90, cos_lat);
229:               	return rel;
230:               }
231:               #endif // USE_EXTENDED_NAV
232:               
233:               vect3_32t dcm_rel2abs(vect3_32t rel)
234:               {
0075B6  FA0018     LNK #0x18
0075B8  780380     MOV W0, W7
0075BA  47006C     ADD W14, #0xC, W0
0075BC  780801     MOV W1, [W0]
0075BE  980012     MOV W2, [W0+2]
0075C0  980023     MOV W3, [W0+4]
0075C2  980034     MOV W4, [W0+6]
0075C4  980045     MOV W5, [W0+8]
0075C6  980056     MOV W6, [W0+10]
235:               	vect3_32t abs;
236:               
237:               	abs.z = rel.z;
0075C8  47006C     ADD W14, #0xC, W0
0075CA  9000D0     MOV [W0+10], W1
0075CC  900040     MOV [W0+8], W0
0075CE  980740     MOV W0, [W14+8]
0075D0  980751     MOV W1, [W14+10]
238:               	abs.y = (rel.y * 90) + lat_origin.WW;
0075D2  47006C     ADD W14, #0xC, W0
0075D4  9000B0     MOV [W0+6], W1
0075D6  900020     MOV [W0+4], W0
0075D8  2005A2     MOV #0x5A, W2
0075DA  B98902     MUL.SS W1, W2, W2
0075DC  780102     MOV W2, W2
0075DE  B90260     MUL.SU W0, #0, W4
0075E0  780184     MOV W4, W3
0075E2  410103     ADD W2, W3, W2
0075E4  2005A3     MOV #0x5A, W3
0075E6  B80003     MUL.UU W0, W3, W0
0075E8  410101     ADD W2, W1, W2
0075EA  780082     MOV W2, W1
0075EC  80EBC2     MOV lat_origin, W2
0075EE  80EBD3     MOV 0x1D7A, W3
0075F0  410000     ADD W2, W0, W0
0075F2  498081     ADDC W3, W1, W1
0075F4  980720     MOV W0, [W14+4]
0075F6  980731     MOV W1, [W14+6]
239:               	abs.x = (rel.x * 90) + lon_origin.WW;
0075F8  47006C     ADD W14, #0xC, W0
0075FA  BE0010     MOV.D [W0], W0
0075FC  2005A2     MOV #0x5A, W2
0075FE  B98902     MUL.SS W1, W2, W2
007600  780102     MOV W2, W2
007602  B90260     MUL.SU W0, #0, W4
007604  780184     MOV W4, W3
007606  410103     ADD W2, W3, W2
007608  2005A3     MOV #0x5A, W3
00760A  B80003     MUL.UU W0, W3, W0
00760C  410101     ADD W2, W1, W2
00760E  780082     MOV W2, W1
007610  80EBE2     MOV lon_origin, W2
007612  80EBF3     MOV .L36, W3
007614  410000     ADD W2, W0, W0
007616  498081     ADDC W3, W1, W1
007618  BE8F00     MOV.D W0, [W14]
240:               //	abs.x = long_scale((rel.x * 90), cos_lat) + lon_origin.WW;
241:               
242:               	return abs;
00761A  78000E     MOV W14, W0
00761C  780087     MOV W7, W1
00761E  BE0110     MOV.D [W0], W2
007620  BE8882     MOV.D W2, [W1]
007622  4080E4     ADD W1, #0x4, W1
007624  400064     ADD W0, #0x4, W0
007626  BE0110     MOV.D [W0], W2
007628  BE8882     MOV.D W2, [W1]
00762A  4080E4     ADD W1, #0x4, W1
00762C  400064     ADD W0, #0x4, W0
00762E  BE0110     MOV.D [W0], W2
007630  BE8882     MOV.D W2, [W1]
007632  4080E4     ADD W1, #0x4, W1
007634  400064     ADD W0, #0x4, W0
243:               }
007636  780007     MOV W7, W0
007638  FA8000     ULNK
00763A  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libDCM/gpsParseCommon.c  ----------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libDCM.h"
23:                #include "gpsData.h"
24:                #include "gpsParseCommon.h"
25:                #include "estLocation.h"
26:                #include "estAltitude.h"
27:                #include "estYawDrift.h"
28:                #include "estWind.h"
29:                #include "mathlibNAV.h"
30:                #include "rmat.h"
31:                #include "../libUDB/interrupt.h"
32:                #include "../libUDB/serialIO.h"
33:                #include <string.h>
34:                #include "../libUDB/servoOutPins.h"
35:                #include "../libUDB/heartbeat.h"
36:                
37:                // GPS parser modules variables
38:                union longbbbb lat_gps_, lon_gps_;
39:                union longbbbb alt_sl_gps_;
40:                union longbbbb tow_;
41:                union intbb hdop_;
42:                union intbb vdop_;
43:                union longbbbb date_gps_, time_gps_;
44:                
45:                extern void (*msg_parse)(uint8_t gpschar);
46:                
47:                static const uint8_t* gps_out_buffer = 0;
48:                static int16_t gps_out_buffer_length = 0;
49:                static int16_t gps_out_index = 0;
50:                uint16_t gps_parse_errors = 0;
51:                
52:                int32_t get_gps_date(void)
53:                {
00611C  FA0000     LNK #0x0
54:                	return date_gps_.WW;
00611E  80EDA0     MOV date_gps_, W0
006120  80EDB1     MOV 0x1DB6, W1
55:                }
006122  FA8000     ULNK
006124  060000     RETURN
56:                int32_t get_gps_time(void)
57:                {
006126  FA0000     LNK #0x0
58:                	return time_gps_.WW;
006128  80EDC0     MOV time_gps_, W0
00612A  80EDD1     MOV 0x1DBA, W1
59:                }
00612C  FA8000     ULNK
00612E  060000     RETURN
60:                
61:                void init_gps_std(void);
62:                void init_gps_ubx(void);
63:                void init_gps_mtek(void);
64:                void init_gps_nmea(void);
65:                void init_gps_none(void);
66:                
67:                void gps_init(void)
68:                {
006130  FA0000     LNK #0x0
69:                #if (GPS_TYPE == GPS_STD)
70:                	init_gps_std();
71:                #elif (GPS_TYPE == GPS_UBX_2HZ || GPS_TYPE == GPS_UBX_4HZ)
72:                	init_gps_ubx();
73:                #elif (GPS_TYPE == GPS_MTEK)
74:                	init_gps_mtek();
75:                #elif (GPS_TYPE == GPS_NMEA)
76:                	init_gps_nmea();
77:                #elif (GPS_TYPE == GPS_NONE)
78:                	init_gps_none();
006132  070006     RCALL init_gps_none
79:                #endif
80:                
81:                #if (CONSOLE_UART != 1)
82:                	udb_init_GPS(&udb_gps_callback_get_byte_to_send, &udb_gps_callback_received_byte);
006134  261C61     MOV #0x61C6, W1
006136  2619A0     MOV #0x619A, W0
006138  026D28     CALL udb_init_GPS
00613A  000000     NOP
83:                #endif
84:                }
00613C  FA8000     ULNK
00613E  060000     RETURN
85:                
86:                #if (GPS_TYPE == GPS_NONE)
87:                void init_gps_none(void) { }
006140  FA0000     LNK #0x0
006142  FA8000     ULNK
006144  060000     RETURN
88:                boolean gps_nav_valid(void) { return 0; }
006146  FA0000     LNK #0x0
006148  EB4000     CLR.B W0
00614A  FA8000     ULNK
00614C  060000     RETURN
89:                void gps_startup_sequence(int16_t gpscount) { }
00614E  FA0002     LNK #0x2
006150  780F00     MOV W0, [W14]
006152  FA8000     ULNK
006154  060000     RETURN
90:                void gps_commit_data(void) { }
006156  FA0000     LNK #0x0
006158  FA8000     ULNK
00615A  060000     RETURN
91:                void gps_parse_none(uint8_t gpschar) { }
00615C  FA0002     LNK #0x2
00615E  784F00     MOV.B W0, [W14]
006160  FA8000     ULNK
006162  060000     RETURN
92:                void (*msg_parse)(uint8_t) = &gps_parse_none;
93:                #endif // GPS_TYPE
94:                
95:                
96:                void gpsoutbin(int16_t length, const uint8_t msg[]) // output a binary message to the GPS
97:                {
006164  FA0004     LNK #0x4
006166  780F00     MOV W0, [W14]
006168  980711     MOV W1, [W14+2]
98:                	gps_out_buffer = 0; // clear the buffer pointer first, for safety, in case we're interrupted
00616A  EB0000     CLR W0
00616C  88EDE0     MOV W0, gps_out_buffer
99:                	gps_out_index = 0;
00616E  EB0000     CLR W0
006170  88EE00     MOV W0, gps_out_index
100:               	gps_out_buffer_length = length;
006172  78001E     MOV [W14], W0
006174  88EDF0     MOV W0, gps_out_buffer_length
101:               	gps_out_buffer = (uint8_t*)msg;
006176  90001E     MOV [W14+2], W0
006178  88EDE0     MOV W0, gps_out_buffer
102:               
103:               	udb_gps_start_sending_data();
00617A  026DF0     CALL udb_gps_start_sending_data
00617C  000000     NOP
104:               }
00617E  FA8000     ULNK
006180  060000     RETURN
105:               
106:               void gpsoutline(const char *message) // output one NMEA line to the GPS
107:               {
006182  FA0002     LNK #0x2
006184  781F88     MOV W8, [W15++]
006186  780F00     MOV W0, [W14]
108:               	gpsoutbin(strlen(message), (const uint8_t*)message);
006188  78041E     MOV [W14], W8
00618A  78001E     MOV [W14], W0
00618C  02156A     CALL _strlen
00618E  000000     NOP
006190  780088     MOV W8, W1
006192  07FFE8     RCALL gpsoutbin
109:               }
006194  78044F     MOV [--W15], W8
006196  FA8000     ULNK
006198  060000     RETURN
110:               
111:               int16_t udb_gps_callback_get_byte_to_send(void)
112:               {
00619A  FA0000     LNK #0x0
113:               	if (gps_out_buffer != 0 && gps_out_index < gps_out_buffer_length)
00619C  80EDE0     MOV gps_out_buffer, W0
00619E  500FE0     SUB W0, #0x0, [W15]
0061A0  32000D     BRA Z, .L12, .LSM33
0061A2  80EE01     MOV gps_out_index, W1
0061A4  80EDF0     MOV gps_out_buffer_length, W0
0061A6  508F80     SUB W1, W0, [W15]
0061A8  3D0009     BRA GE, .L12, .LSM33
114:               	{
115:               		// We have a byte to send
116:               		return (uint8_t)(gps_out_buffer[gps_out_index++]);
0061AA  80EDE2     MOV gps_out_buffer, W2
0061AC  80EE01     MOV gps_out_index, W1
0061AE  780001     MOV W1, W0
0061B0  410000     ADD W2, W0, W0
0061B2  784010     MOV.B [W0], W0
0061B4  FB8000     ZE W0, W0
0061B6  E80081     INC W1, W1
0061B8  88EE01     MOV W1, gps_out_index
0061BA  370003     BRA .L13, .LSM35
117:               	}
118:               	else
119:               	{
120:               		// No byte to send, so clear the link to the buffer
121:               		gps_out_buffer = 0;
0061BC  EB0000     CLR W0
0061BE  88EDE0     MOV W0, gps_out_buffer
122:               	}
123:               	return -1;
0061C0  EB8000     SETM W0
124:               }
0061C2  FA8000     ULNK
0061C4  060000     RETURN
125:               
126:               // Got a character from the GPS
127:               void udb_gps_callback_received_byte(uint8_t rxchar)
128:               {
0061C6  FA0002     LNK #0x2
0061C8  784F00     MOV.B W0, [W14]
129:               	//bin_out(rxchar);      // binary out to the debugging USART
130:               	(*msg_parse)(rxchar);   // parse the input byte
0061CA  80F211     MOV 0x1E42, W1
0061CC  78401E     MOV.B [W14], W0
0061CE  010001     CALL W1
131:               }
0061D0  FA8000     ULNK
0061D2  060000     RETURN
132:               
133:               boolean gps_nav_capable_check_set(void)
134:               { // TODO: gps_data_age is not being set by NMEA or STD parsers?
0061D4  FA0000     LNK #0x0
135:               	if (gps_data_age < GPS_DATA_MAX_AGE) gps_data_age++;
0061D6  80EB90     MOV gps_data_age, W0
0061D8  500FE8     SUB W0, #0x8, [W15]
0061DA  3C0003     BRA GT, .L16, .LSM41
0061DC  80EB90     MOV gps_data_age, W0
0061DE  E80000     INC W0, W0
0061E0  88EB90     MOV W0, gps_data_age
136:               	dcm_flags._.nav_capable = (gps_data_age < GPS_DATA_MAX_AGE);
0061E2  80EB91     MOV gps_data_age, W1
0061E4  B3C010     MOV.B #0x1, W0
0061E6  508FE8     SUB W1, #0x8, [W15]
0061E8  340001     BRA LE, .L17
0061EA  EB4000     CLR.B W0
0061EC  FB8000     ZE W0, W0
0061EE  600061     AND W0, #0x1, W0
0061F0  DD004B     SL W0, #11, W0
0061F2  80F2F2     MOV dcm_flags, W2
0061F4  2F7FF1     MOV #0xF7FF, W1
0061F6  610081     AND W2, W1, W1
0061F8  708000     IOR W1, W0, W0
0061FA  88F2F0     MOV W0, dcm_flags
137:               //	return (gps_data_age < GPS_DATA_MAX_AGE);
138:               	return dcm_flags._.nav_capable;
0061FC  80F2F0     MOV dcm_flags, W0
0061FE  DE004B     LSR W0, #11, W0
006200  604061     AND.B W0, #0x1, W0
139:               }
006202  FA8000     ULNK
006204  060000     RETURN
140:               
141:               extern boolean differential_gps(void) ;
142:               
143:               #define DR_PERIOD (int16_t)((HEARTBEAT_HZ/GPS_RATE)+16)
144:               int16_t dead_reckon_clock = DR_PERIOD ;
145:               
146:               boolean origin_recorded = false ;
147:               #define LOCK_DELAY_COUNT 240
148:               uint16_t lock_count = 0 ;
149:               static void gps_parse_common_callback(void)
150:               {
006206  FA0000     LNK #0x0
151:               	dirOverGndHrmat[0] = rmat[1];
006208  80D230     MOV .L8, W0
00620A  88D4F0     MOV W0, 0x1A9E
152:               	dirOverGndHrmat[1] = rmat[4];
00620C  80D260     MOV 0x1A4C, W0
00620E  88D500     MOV W0, 0x1AA0
153:               	dirOverGndHrmat[2] = 0;
006210  EB0000     CLR W0
006212  88D510     MOV W0, .L4
154:               //	udb_led_toggle(LED_GREEN);
155:               	if (gps_nav_valid())
006214  07FF98     RCALL gps_nav_valid
006216  504FE0     SUB.B W0, #0x0, [W15]
006218  32002C     BRA Z, .L19, .LSM60
156:               	{
157:               		
158:               		dead_reckon_clock = DR_PERIOD ;
00621A  200D80     MOV #0xD8, W0
00621C  88F220     MOV W0, 0x1E44
159:               #if (GPS_TYPE == GPS_UBX_4HZ )		
160:               		if ( differential_gps())
161:               		{
162:               			udb_led_toggle(SERVO_OUT_PIN_5);
163:               		}
164:               		else
165:               		{
166:               			led_on(SERVO_OUT_PIN_5) ;
167:               		}
168:               #endif // GPS_UBX_4HZ
169:               		gps_commit_data();
00621E  07FF9B     RCALL gps_commit_data
170:               		gps_data_age = 0;
006220  EB0000     CLR W0
006222  88EB90     MOV W0, gps_data_age
171:               		dcm_callback_gps_location_updated();
006224  026B3E     CALL dcm_callback_gps_location_updated
006226  000000     NOP
172:               		
173:               		if (!origin_recorded&&(lock_count > LOCK_DELAY_COUNT ))
006228  21E460     MOV #0x1E46, W0
00622A  784010     MOV.B [W0], W0
00622C  504FE0     SUB.B W0, #0x0, [W15]
00622E  3A0013     BRA NZ, .L20, .LSM56
006230  80F241     MOV 0x1E48, W1
006232  200F00     MOV #0xF0, W0
006234  508F80     SUB W1, W0, [W15]
006236  36000F     BRA LEU, .L20, .LSM56
174:               		{
175:               			dcm_set_origin_location( lon_gps.WW , lat_gps.WW, alt_sl_gps.WW ) ;
006238  80EC62     MOV alt_sl_gps, W2
00623A  80EC73     MOV 0x1D8E, W3
00623C  80EC20     MOV lat_gps, W0
00623E  80EC31     MOV 0x1D86, W1
006240  80EC46     MOV lon_gps, W6
006242  80EC57     MOV 0x1D8A, W7
006244  BE0202     MOV.D W2, W4
006246  BE0100     MOV.D W0, W2
006248  BE0006     MOV.D W6, W0
00624A  027514     CALL dcm_set_origin_location
00624C  000000     NOP
176:               			origin_recorded = true ;
00624E  21E461     MOV #0x1E46, W1
006250  B3C010     MOV.B #0x1, W0
006252  784880     MOV.B W0, [W1]
006254  370003     BRA .L21, .LSM57
177:               		}
178:               		else
179:               		{
180:               			lock_count ++ ;
006256  80F240     MOV 0x1E48, W0
006258  E80000     INC W0, W0
00625A  88F240     MOV W0, 0x1E48
181:               		}
182:               		if (origin_recorded)
00625C  21E460     MOV #0x1E46, W0
00625E  784010     MOV.B [W0], W0
006260  504FE0     SUB.B W0, #0x0, [W15]
006262  320018     BRA Z, .L18, .LSM67
183:               		{
184:               			estLocation();
006264  0276C8     CALL estLocation
006266  000000     NOP
185:               			//estWind(GetAofA());
186:               			//estAltitude();
187:               			//estYawDrift();
188:               
189:               			//dcm_flags._.yaw_req = 1;       // request yaw drift correction
190:               			dcm_flags._.reckon_req = 1;    // request dead reckoning correction
006268  80F2F1     MOV dcm_flags, W1
00626A  200400     MOV #0x40, W0
00626C  708000     IOR W1, W0, W0
00626E  88F2F0     MOV W0, dcm_flags
006270  370011     BRA .L18, .LSM67
191:               			//dcm_flags._.rollpitch_req = 1;
192:               #if (DEADRECKONING == 0)
193:               			navigate_process_flightplan();
194:               #endif
195:               		}
196:               	}
197:               	else
198:               	{
199:               		led_off(SERVO_OUT_PIN_5) ;
006272  A882D6     BSET LATD, #4
200:               		gps_data_age = GPS_DATA_MAX_AGE+1;
006274  2000A0     MOV #0xA, W0
006276  88EB90     MOV W0, gps_data_age
201:               
202:               		dirOverGndHGPS[0] = dirOverGndHrmat[0];
006278  80D4F0     MOV 0x1A9E, W0
00627A  88D4C0     MOV W0, 0x1A98
203:               		dirOverGndHGPS[1] = dirOverGndHrmat[1];
00627C  80D500     MOV 0x1AA0, W0
00627E  88D4D0     MOV W0, .L7
204:               		dirOverGndHGPS[2] = 0;
006280  EB0000     CLR W0
006282  88D4E0     MOV W0, 0x1A9C
205:               		dcm_flags._.yaw_req = 1;            // request yaw drift correction
006284  80F2F1     MOV dcm_flags, W1
006286  202000     MOV #0x200, W0
006288  708000     IOR W1, W0, W0
00628A  88F2F0     MOV W0, dcm_flags
206:               		dcm_flags._.gps_history_valid = 0;  // gps history has to be restarted
00628C  80F2F1     MOV dcm_flags, W1
00628E  2FFEF0     MOV #0xFFEF, W0
006290  608000     AND W1, W0, W0
006292  88F2F0     MOV W0, dcm_flags
207:               #if (GPS_TYPE != GPS_NONE)
208:               		gps_update_basic_data();            // update svs
209:               #endif
210:               	}
211:               }
006294  FA8000     ULNK
006296  060000     RETURN
212:               
213:               // Received a full set of GPS messages
214:               void gps_parse_common(void)
215:               {
006298  FA0000     LNK #0x0
216:               	// TODO: perhaps have a boolean variable to reset gps_data_age??
217:               	udb_background_trigger(&gps_parse_common_callback);
00629A  262060     MOV #0x6206, W0
00629C  027D20     CALL udb_background_trigger
00629E  000000     NOP
218:               }
0062A0  FA8000     ULNK
0062A2  060000     RETURN
219:               
220:               #define MS_PER_DAY 86400000 // = (24 * 60 * 60 * 1000)
221:               const uint8_t days_in_month[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
222:               static uint8_t day_of_week;
223:               
224:               int16_t calculate_week_num(int32_t date)
225:               {
0062A4  FA000C     LNK #0xC
0062A6  980740     MOV W0, [W14+8]
0062A8  980751     MOV W1, [W14+10]
226:               	uint8_t year;
227:               	uint8_t month;
228:               	int16_t day;
229:               	uint8_t m;
230:               	uint8_t y;
231:               	int16_t c;
232:               	
233:               //	DPRINT("date %li\r\n", date);
234:               
235:               	// Convert date from DDMMYY to week_num and day_of_week
236:               	year = date % 100;
0062AA  90004E     MOV [W14+8], W0
0062AC  9000DE     MOV [W14+10], W1
0062AE  200642     MOV #0x64, W2
0062B0  200003     MOV #0x0, W3
0062B2  021194     CALL ___modsi3
0062B4  000000     NOP
0062B6  984760     MOV.B W0, [W14+6]
237:               	date /= 100;
0062B8  90004E     MOV [W14+8], W0
0062BA  9000DE     MOV [W14+10], W1
0062BC  200642     MOV #0x64, W2
0062BE  200003     MOV #0x0, W3
0062C0  02102A     CALL ___divsi3
0062C2  000000     NOP
0062C4  980740     MOV W0, [W14+8]
0062C6  980751     MOV W1, [W14+10]
238:               	month = date % 100;
0062C8  90004E     MOV [W14+8], W0
0062CA  9000DE     MOV [W14+10], W1
0062CC  200642     MOV #0x64, W2
0062CE  200003     MOV #0x0, W3
0062D0  021194     CALL ___modsi3
0062D2  000000     NOP
0062D4  984770     MOV.B W0, [W14+7]
239:               	date /= 100;
0062D6  90004E     MOV [W14+8], W0
0062D8  9000DE     MOV [W14+10], W1
0062DA  200642     MOV #0x64, W2
0062DC  200003     MOV #0x0, W3
0062DE  02102A     CALL ___divsi3
0062E0  000000     NOP
0062E2  980740     MOV W0, [W14+8]
0062E4  980751     MOV W1, [W14+10]
240:               	day = date % 100;
0062E6  90004E     MOV [W14+8], W0
0062E8  9000DE     MOV [W14+10], W1
0062EA  200642     MOV #0x64, W2
0062EC  200003     MOV #0x0, W3
0062EE  021194     CALL ___modsi3
0062F0  000000     NOP
0062F2  780F00     MOV W0, [W14]
241:               
242:               	// Wait until we have real date data
243:               	if (day < 1 || day > 31 || month < 1 || month > 12) return 0;
0062F4  78001E     MOV [W14], W0
0062F6  500FE0     SUB W0, #0x0, [W15]
0062F8  340009     BRA LE, .L25
0062FA  78001E     MOV [W14], W0
0062FC  500FFF     SUB W0, #0x1F, [W15]
0062FE  3C0006     BRA GT, .L25
006300  90407E     MOV.B [W14+7], W0
006302  504FE0     SUB.B W0, #0x0, [W15]
006304  320003     BRA Z, .L25
006306  90407E     MOV.B [W14+7], W0
006308  504FEC     SUB.B W0, #0xC, [W15]
00630A  360002     BRA LEU, .L26, .LSM78
00630C  EB0000     CLR W0
00630E  37004E     BRA .L27, .LSM94
244:               
245:               	// Begin counting at May 1, 2011 since this 1st was a Sunday
246:               	m = 5;                          // May
006310  B3C050     MOV.B #0x5, W0
006312  984720     MOV.B W0, [W14+2]
247:               	y = 11;                         // 2011
006314  B3C0B0     MOV.B #0xB, W0
006316  984730     MOV.B W0, [W14+3]
248:               	c = 0;                          // loop counter
006318  EB0000     CLR W0
00631A  980720     MOV W0, [W14+4]
249:               
250:               	while (m < month || y < year)
00631C  37002B     BRA .L28, .LSM90
006374  9040AE     MOV.B [W14+2], W1
006376  90407E     MOV.B [W14+7], W0
006378  50CF80     SUB.B W1, W0, [W15]
00637A  39FFD1     BRA NC, .L32, .LSM82
00637C  9040BE     MOV.B [W14+3], W1
00637E  90406E     MOV.B [W14+6], W0
006380  50CF80     SUB.B W1, W0, [W15]
006382  39FFCD     BRA NC, .L32, .LSM82
006384  370001     BRA .L31, .LSM92
251:               	{
252:               		day += days_in_month[m-1];          // (m == 1) means Jan, so use days_in_month[0]
00631E  90402E     MOV.B [W14+2], W0
006320  FB8000     ZE W0, W0
006322  E90000     DEC W0, W0
006324  2B4A81     MOV #0xB4A8, W1
006326  784061     MOV.B [W1+W0], W0
006328  FB8000     ZE W0, W0
00632A  400F1E     ADD W0, [W14], [W14]
253:               		if ((m == 2) && (y % 4 == 0) && (y % 100 != 0))
00632C  90402E     MOV.B [W14+2], W0
00632E  504FE2     SUB.B W0, #0x2, [W15]
006330  3A000F     BRA NZ, .L29, .LSM85
006332  90403E     MOV.B [W14+3], W0
006334  604063     AND.B W0, #0x3, W0
006336  504FE0     SUB.B W0, #0x0, [W15]
006338  3A000B     BRA NZ, .L29, .LSM85
00633A  90403E     MOV.B [W14+3], W0
00633C  FB8080     ZE W0, W1
00633E  200640     MOV #0x64, W0
006340  780100     MOV W0, W2
006342  090011     REPEAT #0x11
006344  D88082     DIV.UW W1, W2
006346  FD0080     EXCH W0, W1
006348  784000     MOV.B W0, W0
00634A  504FE0     SUB.B W0, #0x0, [W15]
00634C  320001     BRA Z, .L29, .LSM85
254:               		{
255:               			day += 1;                       // Add leap day
00634E  E80F1E     INC [W14], [W14]
256:               		}
257:               		m++;
006350  90402E     MOV.B [W14+2], W0
006352  E84000     INC.B W0, W0
006354  984720     MOV.B W0, [W14+2]
258:               		if (m == 13)
006356  90402E     MOV.B [W14+2], W0
006358  504FED     SUB.B W0, #0xD, [W15]
00635A  3A0005     BRA NZ, .L30, .LSM89
259:               		{
260:               			m = 1;
00635C  B3C010     MOV.B #0x1, W0
00635E  984720     MOV.B W0, [W14+2]
261:               			y++;
006360  90403E     MOV.B [W14+3], W0
006362  E84000     INC.B W0, W0
006364  984730     MOV.B W0, [W14+3]
262:               		}
263:               		if (++c > 1200) break;              // Emergency escape from this loop.  Works correctly until May 2111.
006366  90002E     MOV [W14+4], W0
006368  E80000     INC W0, W0
00636A  980720     MOV W0, [W14+4]
00636C  9000AE     MOV [W14+4], W1
00636E  204B00     MOV #0x4B0, W0
006370  508F80     SUB W1, W0, [W15]
006372  3C0009     BRA GT, .L33, .LSM91
006386  000000     NOP
264:               	}
265:               	day_of_week = (day % 7) - 1;
006388  78009E     MOV [W14], W1
00638A  200070     MOV #0x7, W0
00638C  780100     MOV W0, W2
00638E  090011     REPEAT #0x11
006390  D80082     DIV.SW W1, W2
006392  FD0080     EXCH W0, W1
006394  784000     MOV.B W0, W0
006396  E94000     DEC.B W0, W0
006398  21DC21     MOV #0x1DC2, W1
00639A  784880     MOV.B W0, [W1]
266:               	return (1634 + (day / 7));              // We started at week number 1634
00639C  78009E     MOV [W14], W1
00639E  200070     MOV #0x7, W0
0063A0  780100     MOV W0, W2
0063A2  090011     REPEAT #0x11
0063A4  D80082     DIV.SW W1, W2
0063A6  780080     MOV W0, W1
0063A8  206620     MOV #0x662, W0
0063AA  408000     ADD W1, W0, W0
267:               }
0063AC  FA8000     ULNK
0063AE  060000     RETURN
268:               
269:               int32_t calculate_time_of_week(int32_t time)
270:               {
0063B0  FA000A     LNK #0xA
0063B2  980730     MOV W0, [W14+6]
0063B4  980741     MOV W1, [W14+8]
271:               	int16_t ms;
272:               	uint8_t s;
273:               	uint8_t m;
274:               	uint8_t h;
275:               	
276:               //	DPRINT("time %li\r\n", time);
277:               
278:               	// Convert time from HHMMSSmil to time_of_week in ms
279:               	ms = time % 1000;
0063B6  90003E     MOV [W14+6], W0
0063B8  9000CE     MOV [W14+8], W1
0063BA  203E82     MOV #0x3E8, W2
0063BC  200003     MOV #0x0, W3
0063BE  021194     CALL ___modsi3
0063C0  000000     NOP
0063C2  780F00     MOV W0, [W14]
280:               	time /= 1000;
0063C4  90003E     MOV [W14+6], W0
0063C6  9000CE     MOV [W14+8], W1
0063C8  203E82     MOV #0x3E8, W2
0063CA  200003     MOV #0x0, W3
0063CC  02102A     CALL ___divsi3
0063CE  000000     NOP
0063D0  980730     MOV W0, [W14+6]
0063D2  980741     MOV W1, [W14+8]
281:               	s = time % 100;
0063D4  90003E     MOV [W14+6], W0
0063D6  9000CE     MOV [W14+8], W1
0063D8  200642     MOV #0x64, W2
0063DA  200003     MOV #0x0, W3
0063DC  021194     CALL ___modsi3
0063DE  000000     NOP
0063E0  984720     MOV.B W0, [W14+2]
282:               	time /= 100;
0063E2  90003E     MOV [W14+6], W0
0063E4  9000CE     MOV [W14+8], W1
0063E6  200642     MOV #0x64, W2
0063E8  200003     MOV #0x0, W3
0063EA  02102A     CALL ___divsi3
0063EC  000000     NOP
0063EE  980730     MOV W0, [W14+6]
0063F0  980741     MOV W1, [W14+8]
283:               	m = time % 100;
0063F2  90003E     MOV [W14+6], W0
0063F4  9000CE     MOV [W14+8], W1
0063F6  200642     MOV #0x64, W2
0063F8  200003     MOV #0x0, W3
0063FA  021194     CALL ___modsi3
0063FC  000000     NOP
0063FE  984730     MOV.B W0, [W14+3]
284:               	time /= 100;
006400  90003E     MOV [W14+6], W0
006402  9000CE     MOV [W14+8], W1
006404  200642     MOV #0x64, W2
006406  200003     MOV #0x0, W3
006408  02102A     CALL ___divsi3
00640A  000000     NOP
00640C  980730     MOV W0, [W14+6]
00640E  980741     MOV W1, [W14+8]
285:               	h = time % 100;
006410  90003E     MOV [W14+6], W0
006412  9000CE     MOV [W14+8], W1
006414  200642     MOV #0x64, W2
006416  200003     MOV #0x0, W3
006418  021194     CALL ___modsi3
00641A  000000     NOP
00641C  984740     MOV.B W0, [W14+4]
286:               	time = (((((int32_t)(h)) * 60) + m) * 60 + s) * 1000 + ms;
00641E  90404E     MOV.B [W14+4], W0
006420  FB8000     ZE W0, W0
006422  200001     MOV #0x0, W1
006424  2003C2     MOV #0x3C, W2
006426  B98902     MUL.SS W1, W2, W2
006428  780102     MOV W2, W2
00642A  B90260     MUL.SU W0, #0, W4
00642C  780184     MOV W4, W3
00642E  410103     ADD W2, W3, W2
006430  2003C3     MOV #0x3C, W3
006432  B80003     MUL.UU W0, W3, W0
006434  410101     ADD W2, W1, W2
006436  780082     MOV W2, W1
006438  90413E     MOV.B [W14+3], W2
00643A  FB8102     ZE W2, W2
00643C  200003     MOV #0x0, W3
00643E  410000     ADD W2, W0, W0
006440  498081     ADDC W3, W1, W1
006442  2003C2     MOV #0x3C, W2
006444  B98902     MUL.SS W1, W2, W2
006446  780102     MOV W2, W2
006448  B90260     MUL.SU W0, #0, W4
00644A  780184     MOV W4, W3
00644C  410103     ADD W2, W3, W2
00644E  2003C3     MOV #0x3C, W3
006450  B80003     MUL.UU W0, W3, W0
006452  410101     ADD W2, W1, W2
006454  780082     MOV W2, W1
006456  90412E     MOV.B [W14+2], W2
006458  FB8102     ZE W2, W2
00645A  200003     MOV #0x0, W3
00645C  410000     ADD W2, W0, W0
00645E  498081     ADDC W3, W1, W1
006460  203E82     MOV #0x3E8, W2
006462  B98902     MUL.SS W1, W2, W2
006464  780102     MOV W2, W2
006466  B90260     MUL.SU W0, #0, W4
006468  780184     MOV W4, W3
00646A  410103     ADD W2, W3, W2
00646C  203E83     MOV #0x3E8, W3
00646E  B80003     MUL.UU W0, W3, W0
006470  410101     ADD W2, W1, W2
006472  780082     MOV W2, W1
006474  78011E     MOV [W14], W2
006476  DE91CF     ASR W2, #15, W3
006478  410000     ADD W2, W0, W0
00647A  498081     ADDC W3, W1, W1
00647C  980730     MOV W0, [W14+6]
00647E  980741     MOV W1, [W14+8]
287:               	return (time + (((int32_t)day_of_week) * MS_PER_DAY));
006480  21DC20     MOV #0x1DC2, W0
006482  784010     MOV.B [W0], W0
006484  FB8000     ZE W0, W0
006486  200001     MOV #0x0, W1
006488  25C002     MOV #0x5C00, W2
00648A  B98902     MUL.SS W1, W2, W2
00648C  780102     MOV W2, W2
00648E  205263     MOV #0x526, W3
006490  B98203     MUL.SS W0, W3, W4
006492  780184     MOV W4, W3
006494  410103     ADD W2, W3, W2
006496  25C003     MOV #0x5C00, W3
006498  B80003     MUL.UU W0, W3, W0
00649A  410101     ADD W2, W1, W2
00649C  780082     MOV W2, W1
00649E  90013E     MOV [W14+6], W2
0064A0  9001CE     MOV [W14+8], W3
0064A2  410000     ADD W2, W0, W0
0064A4  498081     ADDC W3, W1, W1
288:               }
0064A6  FA8000     ULNK
0064A8  060000     RETURN
289:               
290:               boolean gps_check_startup_metrics(void)
291:               {
0064AA  FA0000     LNK #0x0
292:               	return 0 ;
0064AC  EB4000     CLR.B W0
293:               }
0064AE  FA8000     ULNK
0064B0  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/libDCM/estLocation.c  -------------------------------------
1:                 // This file is part of MatrixPilot.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "libDCM.h"
23:                #include "gpsData.h"
24:                #include "gpsParseCommon.h"
25:                #include "estLocation.h"
26:                #include "estAltitude.h"  //USE_BAROMETER_ALTITUDE
27:                #include "mathlibNAV.h"
28:                #include "estWind.h"
29:                
30:                
31:                #ifdef USE_EXTENDED_NAV
32:                static void location_plane(int32_t* location)
33:                {
34:                	location[1] = ((lat_gps.WW - lat_origin.WW)/90); // in meters, range is about 20 miles
35:                	location[0] = long_scale((lon_gps.WW - lon_origin.WW)/90, cos_lat);
36:                #if (USE_BAROMETER_ALTITUDE == 1 ) 
37:                #warning "using pressure altitude instead of GPS altitude"
38:                	// division by 100 implies alt_origin is in centimeters; not documented elsewhere
39:                	// longword result = (longword/10 - longword)/100 : range
40:                	location[2] = ((get_barometer_altitude()/10) - alt_origin.WW)/100; // height in meters
41:                #else
42:                	location[2] = (alt_sl_gps.WW - alt_origin.WW)/100; // height in meters
43:                #endif // USE_BAROMETER_ALTITUDE
44:                
45:                }
46:                #else // !USE_EXTENDED_NAV
47:                static void location_plane(int16_t* location)
48:                {
00763C  FA0006     LNK #0x6
00763E  781F88     MOV W8, [W15++]
007640  980720     MOV W0, [W14+4]
49:                	union longbbbb accum_nav;
50:                
51:                	accum_nav.WW = ((100*(lat_gps.WW - lat_origin.WW))/90); // in cm, range is about 1000 feet
007642  80EC22     MOV lat_gps, W2
007644  80EC33     MOV 0x1D86, W3
007646  80EBC0     MOV lat_origin, W0
007648  80EBD1     MOV 0x1D7A, W1
00764A  510000     SUB W2, W0, W0
00764C  598081     SUBB W3, W1, W1
00764E  200642     MOV #0x64, W2
007650  B98902     MUL.SS W1, W2, W2
007652  780102     MOV W2, W2
007654  B90260     MUL.SU W0, #0, W4
007656  780184     MOV W4, W3
007658  410103     ADD W2, W3, W2
00765A  200643     MOV #0x64, W3
00765C  B80003     MUL.UU W0, W3, W0
00765E  410101     ADD W2, W1, W2
007660  780082     MOV W2, W1
007662  2005A2     MOV #0x5A, W2
007664  200003     MOV #0x0, W3
007666  02102A     CALL ___divsi3
007668  000000     NOP
00766A  BE8F00     MOV.D W0, [W14]
52:                	location[1] = accum_nav._.W0;
00766C  90002E     MOV [W14+4], W0
00766E  E88000     INC2 W0, W0
007670  78009E     MOV [W14], W1
007672  780801     MOV W1, [W0]
53:                	accum_nav.WW = long_scale((100*(lon_gps.WW - lon_origin.WW))/90, cos_lat);
007674  80F068     MOV 0x1E0C, W8
007676  80EC42     MOV lon_gps, W2
007678  80EC53     MOV 0x1D8A, W3
00767A  80EBE0     MOV lon_origin, W0
00767C  80EBF1     MOV .L36, W1
00767E  510000     SUB W2, W0, W0
007680  598081     SUBB W3, W1, W1
007682  200642     MOV #0x64, W2
007684  B98902     MUL.SS W1, W2, W2
007686  780102     MOV W2, W2
007688  B90260     MUL.SU W0, #0, W4
00768A  780184     MOV W4, W3
00768C  410103     ADD W2, W3, W2
00768E  200643     MOV #0x64, W3
007690  B80003     MUL.UU W0, W3, W0
007692  410101     ADD W2, W1, W2
007694  780082     MOV W2, W1
007696  2005A2     MOV #0x5A, W2
007698  200003     MOV #0x0, W3
00769A  02102A     CALL ___divsi3
00769C  000000     NOP
00769E  780108     MOV W8, W2
0076A0  024F30     CALL long_scale
0076A2  000000     NOP
0076A4  BE8F00     MOV.D W0, [W14]
54:                	location[0] = accum_nav._.W0;
0076A6  78009E     MOV [W14], W1
0076A8  90002E     MOV [W14+4], W0
0076AA  780801     MOV W1, [W0]
55:                #if (USE_BAROMETER_ALTITUDE == 1 ) 
56:                #warning "using pressure altitude instead of GPS altitude"
57:                	// division by 100 implies alt_origin is in centimeters; not documented elsewhere
58:                	// longword result = (longword/10 - longword)/100 : range
59:                	accum_nav.WW = ((get_barometer_altitude()/10) - alt_origin.WW)/100; // height in meters
60:                #else
61:                	accum_nav.WW = (alt_sl_gps.WW - alt_origin.WW); // height in cm
0076AC  80EC62     MOV alt_sl_gps, W2
0076AE  80EC73     MOV 0x1D8E, W3
0076B0  80EC00     MOV alt_origin, W0
0076B2  80EC11     MOV 0x1D82, W1
0076B4  510000     SUB W2, W0, W0
0076B6  598081     SUBB W3, W1, W1
0076B8  BE8F00     MOV.D W0, [W14]
62:                #endif // USE_BAROMETER_ALTITUDE
63:                	location[2] = accum_nav._.W0;
0076BA  90002E     MOV [W14+4], W0
0076BC  400064     ADD W0, #0x4, W0
0076BE  78009E     MOV [W14], W1
0076C0  780801     MOV W1, [W0]
64:                }
0076C2  78044F     MOV [--W15], W8
0076C4  FA8000     ULNK
0076C6  060000     RETURN
65:                #endif // USE_EXTENDED_NAV
66:                
67:                void estLocation(void)
68:                {
0076C8  FA0022     LNK #0x22
0076CA  781F88     MOV W8, [W15++]
69:                	static int8_t cog_previous = 64;
70:                	static int16_t sog_previous = 0;
71:                	static int16_t climb_rate_previous = 0;
72:                	static uint16_t velocity_previous = 0;
73:                	static int16_t location_previous[] = { 0, 0, 0 };
74:                
75:                	union longbbbb accum;
76:                	union longww accum_velocity;
77:                	int8_t cog_circular;
78:                	int8_t cog_delta;
79:                	int16_t sog_delta;
80:                	int16_t climb_rate_delta;
81:                #ifdef USE_EXTENDED_NAV
82:                	int32_t location[3];
83:                #else
84:                	int16_t location[3];
85:                #endif // USE_EXTENDED_NAV
86:                	int16_t location_deltaZ;
87:                	struct relative2D location_deltaXY;
88:                	struct relative2D velocity_thru_air;
89:                	int16_t velocity_thru_airz;
90:                
91:                	location_plane(&location[0]);
0076CC  470074     ADD W14, #0x14, W0
0076CE  07FFB6     RCALL _location_plane, .Ltext0, .LFB0, .LSM0, .Letext0, .LFE11
92:                
93:                	// convert GPS course of 360 degrees to a binary model with 256
94:                	accum.WW = __builtin_muluu(COURSEDEG_2_BYTECIR, cog_gps.BB) + 0x00008000;
0076D0  80ECC1     MOV cog_gps, W1
0076D2  201D20     MOV #0x1D2, W0
0076D4  B80101     MUL.UU W0, W1, W2
0076D6  280000     MOV #0x8000, W0
0076D8  200001     MOV #0x0, W1
0076DA  400002     ADD W0, W2, W0
0076DC  488083     ADDC W1, W3, W1
0076DE  980760     MOV W0, [W14+12]
0076E0  980771     MOV W1, [W14+14]
95:                	// re-orientate from compass (clockwise) to maths (anti-clockwise) with 0 degrees in East
96:                	cog_circular = -accum.__.B2 + 64;
0076E2  90486E     MOV.B [W14+14], W0
0076E4  B3C401     MOV.B #0x40, W1
0076E6  50C000     SUB.B W1, W0, W0
0076E8  984F00     MOV.B W0, [W14+8]
97:                
98:                	// compensate for GPS reporting latency.
99:                	// The dynamic model of the EM406 and uBlox is not well known.
100:               	// However, it seems likely much of it is simply reporting latency.
101:               	// This section of the code compensates for reporting latency.
102:               	// markw: what is the latency? It doesn't appear numerically or as a comment
103:               	// in the following code. Since this method is called at the GPS reporting rate
104:               	// it must be assumed to be one reporting interval?
105:               #if (HILSIM != 1)
106:               	if (dcm_flags._.gps_history_valid)
0076EA  80F2F0     MOV dcm_flags, W0
0076EC  600070     AND W0, #0x10, W0
0076EE  500FE0     SUB W0, #0x0, [W15]
0076F0  32001D     BRA Z, .L3, .LSM19
107:               	{
108:               		cog_delta = cog_circular - cog_previous;
0076F2  90488E     MOV.B [W14+8], W1
0076F4  27FFE0     MOV #0x7FFE, W0
0076F6  784010     MOV.B [W0], W0
0076F8  50C000     SUB.B W1, W0, W0
0076FA  784F00     MOV.B W0, [W14]
109:               		sog_delta = sog_gps.BB - sog_previous;
0076FC  80ECB1     MOV sog_gps, W1
0076FE  80F140     MOV _sog_previous.9192, W0
007700  508000     SUB W1, W0, W0
007702  980710     MOV W0, [W14+2]
110:               		climb_rate_delta = climb_gps.BB - climb_rate_previous;
007704  80ECD1     MOV climb_gps, W1
007706  80F150     MOV _climb_rate_previous.9193, W0
007708  508000     SUB W1, W0, W0
00770A  980720     MOV W0, [W14+4]
111:               
112:               		location_deltaXY.x = location[0] - location_previous[0];
00770C  470074     ADD W14, #0x14, W0
00770E  780090     MOV [W0], W1
007710  80F160     MOV _location_previous.9195, W0
007712  508000     SUB W1, W0, W0
007714  980F50     MOV W0, [W14+26]
113:               		location_deltaXY.y = location[1] - location_previous[1];
007716  470074     ADD W14, #0x14, W0
007718  900090     MOV [W0+2], W1
00771A  80F170     MOV 0x1E2E, W0
00771C  508000     SUB W1, W0, W0
00771E  980F60     MOV W0, [W14+28]
114:               		location_deltaZ    = location[2] - location_previous[2];
007720  470074     ADD W14, #0x14, W0
007722  9000A0     MOV [W0+4], W1
007724  80F180     MOV 0x1E30, W0
007726  508000     SUB W1, W0, W0
007728  980730     MOV W0, [W14+6]
00772A  37000C     BRA .L4, .LSM23
115:               	}
116:               	else
117:               	{
118:               		cog_delta = 0;
00772C  EB4000     CLR.B W0
00772E  784F00     MOV.B W0, [W14]
119:               		sog_delta = 0;
007730  EB0000     CLR W0
007732  980710     MOV W0, [W14+2]
120:               		climb_rate_delta = 0;
007734  EB0000     CLR W0
007736  980720     MOV W0, [W14+4]
121:               		location_deltaXY.x = location_deltaXY.y = location_deltaZ = 0;
007738  EB0000     CLR W0
00773A  980730     MOV W0, [W14+6]
00773C  90003E     MOV [W14+6], W0
00773E  980F60     MOV W0, [W14+28]
007740  90086E     MOV [W14+28], W0
007742  980F50     MOV W0, [W14+26]
122:               	}
123:               #else
124:               	cog_delta = 0;
125:               	sog_delta = 0;
126:               	climb_rate_delta = 0;
127:               	location_deltaXY.x = location_deltaXY.y = location_deltaZ = 0;
128:               #endif //#if (HILSIM != 1)
129:               	dcm_flags._.gps_history_valid = 1;
007744  80F2F0     MOV dcm_flags, W0
007746  A04000     BSET W0, #4
007748  88F2F0     MOV W0, dcm_flags
130:               	actual_dir = cog_circular + cog_delta;
00774A  90488E     MOV.B [W14+8], W1
00774C  78401E     MOV.B [W14], W0
00774E  40C000     ADD.B W1, W0, W0
007750  21D741     MOV #0x1D74, W1
007752  784880     MOV.B W0, [W1]
131:               	cog_previous = cog_circular;
007754  27FFE0     MOV #0x7FFE, W0
007756  90488E     MOV.B [W14+8], W1
007758  784801     MOV.B W1, [W0]
132:               
133:               	// Note that all these velocities are in centimeters / second
134:               
135:               	ground_velocity_magnitudeXY = sog_gps.BB + sog_delta;
00775A  80ECB1     MOV sog_gps, W1
00775C  90001E     MOV [W14+2], W0
00775E  408000     ADD W1, W0, W0
007760  88F070     MOV W0, 0x1E0E
136:               	sog_previous = sog_gps.BB;
007762  80ECB0     MOV sog_gps, W0
007764  88F140     MOV W0, _sog_previous.9192
137:               
138:               	GPSvelocity.z = climb_gps.BB + climb_rate_delta;
007766  80ECD1     MOV climb_gps, W1
007768  90002E     MOV [W14+4], W0
00776A  408000     ADD W1, W0, W0
00776C  88F050     MOV W0, 0x1E0A
139:               	climb_rate_previous = climb_gps.BB;
00776E  80ECD0     MOV climb_gps, W0
007770  88F150     MOV W0, _climb_rate_previous.9193
140:               
141:               	accum_velocity.WW = (__builtin_mulss(cosine(actual_dir), ground_velocity_magnitudeXY) << 2) + 0x00008000;
007772  80F070     MOV 0x1E0E, W0
007774  780400     MOV W0, W8
007776  21D740     MOV #0x1D74, W0
007778  784010     MOV.B [W0], W0
00777A  0249B0     CALL cosine
00777C  000000     NOP
00777E  B98008     MUL.SS W0, W8, W0
007780  DD0942     SL W1, #2, W2
007782  DE01CE     LSR W0, #14, W3
007784  710183     IOR W2, W3, W3
007786  DD0142     SL W0, #2, W2
007788  280000     MOV #0x8000, W0
00778A  200001     MOV #0x0, W1
00778C  400002     ADD W0, W2, W0
00778E  488083     ADDC W1, W3, W1
007790  980F00     MOV W0, [W14+16]
007792  980F11     MOV W1, [W14+18]
142:               	GPSvelocity.x = accum_velocity._.W1;
007794  90081E     MOV [W14+18], W0
007796  88F030     MOV W0, 0x1E06
143:               
144:               	accum_velocity.WW = (__builtin_mulss(sine(actual_dir), ground_velocity_magnitudeXY) << 2) + 0x00008000;
007798  80F070     MOV 0x1E0E, W0
00779A  780400     MOV W0, W8
00779C  21D740     MOV #0x1D74, W0
00779E  784010     MOV.B [W0], W0
0077A0  0248B4     CALL sine
0077A2  000000     NOP
0077A4  B98008     MUL.SS W0, W8, W0
0077A6  DD0942     SL W1, #2, W2
0077A8  DE01CE     LSR W0, #14, W3
0077AA  710183     IOR W2, W3, W3
0077AC  DD0142     SL W0, #2, W2
0077AE  280000     MOV #0x8000, W0
0077B0  200001     MOV #0x0, W1
0077B2  400002     ADD W0, W2, W0
0077B4  488083     ADDC W1, W3, W1
0077B6  980F00     MOV W0, [W14+16]
0077B8  980F11     MOV W1, [W14+18]
145:               	GPSvelocity.y = accum_velocity._.W1;
0077BA  90081E     MOV [W14+18], W0
0077BC  88F040     MOV W0, 0x1E08
146:               
147:               	rotate_2D(&location_deltaXY, cog_delta); // this is a key step to account for rotation effects!!
0077BE  47007A     ADD W14, #0x1A, W0
0077C0  78409E     MOV.B [W14], W1
0077C2  024AA6     CALL rotate_2D
0077C4  000000     NOP
148:               
149:               	GPSlocation.x = location[0] + location_deltaXY.x;
0077C6  470074     ADD W14, #0x14, W0
0077C8  780090     MOV [W0], W1
0077CA  90085E     MOV [W14+26], W0
0077CC  408000     ADD W1, W0, W0
0077CE  88F000     MOV W0, 0x1E00
150:               	GPSlocation.y = location[1] + location_deltaXY.y;
0077D0  470074     ADD W14, #0x14, W0
0077D2  900090     MOV [W0+2], W1
0077D4  90086E     MOV [W14+28], W0
0077D6  408000     ADD W1, W0, W0
0077D8  88F010     MOV W0, 0x1E02
151:               	GPSlocation.z = location[2] + location_deltaZ;
0077DA  470074     ADD W14, #0x14, W0
0077DC  9000A0     MOV [W0+4], W1
0077DE  90003E     MOV [W14+6], W0
0077E0  408000     ADD W1, W0, W0
0077E2  88F020     MOV W0, 0x1E04
152:               
153:               	location_previous[0] = location[0];
0077E4  470074     ADD W14, #0x14, W0
0077E6  780010     MOV [W0], W0
0077E8  88F160     MOV W0, _location_previous.9195
154:               	location_previous[1] = location[1];
0077EA  470074     ADD W14, #0x14, W0
0077EC  900010     MOV [W0+2], W0
0077EE  88F170     MOV W0, 0x1E2E
155:               	location_previous[2] = location[2];
0077F0  470074     ADD W14, #0x14, W0
0077F2  900020     MOV [W0+4], W0
0077F4  88F180     MOV W0, 0x1E30
156:               
157:               	velocity_thru_air.y = GPSvelocity.y ;
0077F6  80F040     MOV 0x1E08, W0
0077F8  981700     MOV W0, [W14+32]
158:               	velocity_thru_air.x = GPSvelocity.x ;
0077FA  80F030     MOV 0x1E06, W0
0077FC  980F70     MOV W0, [W14+30]
159:               	velocity_thru_airz  = GPSvelocity.z ;
0077FE  80F050     MOV 0x1E0A, W0
007800  980750     MOV W0, [W14+10]
160:               
161:               	air_speed_3DGPS = vector3_mag(velocity_thru_air.x, velocity_thru_air.y, velocity_thru_airz);
007802  90108E     MOV [W14+32], W1
007804  90087E     MOV [W14+30], W0
007806  90015E     MOV [W14+10], W2
007808  024DDA     CALL vector3_mag
00780A  000000     NOP
00780C  88F0A0     MOV W0, 0x1E14
162:               
163:               	calculated_heading  = rect_to_polar(&velocity_thru_air);
00780E  47007E     ADD W14, #0x1E, W0
007810  024B20     CALL rect_to_polar
007812  000000     NOP
007814  21D751     MOV #0x1D75, W1
007816  784880     MOV.B W0, [W1]
164:               	// veclocity_thru_air.x becomes XY air speed as a by product of CORDIC routine in rect_to_polar()
165:               	air_speed_magnitudeXY = velocity_thru_air.x; // in cm / sec
007818  90087E     MOV [W14+30], W0
00781A  88F090     MOV W0, 0x1E12
166:               
167:               #if (GPS_RATE == 4)
168:               	forward_acceleration = (air_speed_3DGPS - velocity_previous) << 2; // Ublox enters code 4 times per second
169:               #elif (GPS_RATE == 2)
170:               	forward_acceleration = (air_speed_3DGPS - velocity_previous) << 1; // Ublox enters code 2 times per second
171:               #else
172:               	forward_acceleration = (air_speed_3DGPS - velocity_previous);      // EM406 standard GPS enters code once per second
00781C  80F0A1     MOV 0x1E14, W1
00781E  80F190     MOV _velocity_previous.9194, W0
007820  508000     SUB W1, W0, W0
007822  88F080     MOV W0, 0x1E10
173:               #endif
174:               
175:               	velocity_previous = air_speed_3DGPS;
007824  80F0A0     MOV 0x1E14, W0
007826  88F190     MOV W0, _velocity_previous.9194
176:               }
007828  78044F     MOV [--W15], W8
00782A  FA8000     ULNK
00782C  060000     RETURN
177:               
---  C:/Users/bill/Desktop/git_repos/git_luge/MultiRotor/telemetry.c  -----------------------------------
1:                 // This file is part of the MatrixPilotQuad firmware.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                #include "../libDCM/libDCM.h"
22:                #include "../libDCM/gpsData.h"
23:                #include "../libDCM/gpsParseCommon.h"
24:                #include "../libDCM/rmat.h"
25:                #include "../libUDB/heartbeat.h"
26:                #include "../libUDB/serialIO.h"
27:                #include "../libUDB/servoOut.h"
28:                #include "../libUDB/ADchannel.h"
29:                #include "../libUDB/mcu.h"
30:                
31:                // Used for serial debug output
32:                #include <stdio.h>
33:                #if ( GYRO_RANGE == 250 )
34:                #define GYRO_FACTOR ((double)(65.5))
35:                #elif ( GYRO_RANGE == 500 )
36:                #define GYRO_FACTOR ((double)(32.75))
37:                #elif ( GYRO_RANGE == 1000 )
38:                #define GYRO_FACTOR ((double)(16.375))
39:                #elif ( GYRO_RANGE == 2000 )
40:                #define GYRO_FACTOR ((double)(8.1875))
41:                #else
42:                #error "invalid GYRO_RANGE"
43:                #endif // GYRO_RANGE 	
44:                		
45:                #if ( ACCEL_RANGE == 2 )
46:                #define ACCEL_FACTOR ((double)(8192.0/32.17))
47:                #elif ( ACCEL_RANGE == 4 )
48:                #define ACCEL_FACTOR ((double)(4096.0/32.17))
49:                #elif ( ACCEL_RANGE == 8 )
50:                #define ACCEL_FACTOR ((double)(2048.0/32.17))
51:                #elif ( ACCEL_RANGE == 16 )
52:                #define ACCEL_FACTOR ((double)(1024.0/32.17))
53:                #else
54:                #error "invalid ACCEL_RANGE"
55:                #endif // ACCEL_RANGE 	
56:                
57:                
58:                char debug_buffer[1024] ;
59:                int db_index = 0 ;
60:                boolean hasWrittenHeader = 0 ;
61:                int header_line = 0 ;
62:                
63:                extern int16_t theta[3] , roll_control , pitch_control , yaw_control , accelEarth[3] , accel_feedback ;
64:                extern int16_t commanded_roll, commanded_pitch, commanded_yaw, pwManual[] ;
65:                extern int16_t roll_error , pitch_error , yaw_error ;
66:                extern union longww roll_error_integral, pitch_error_integral , yaw_error_integral ;
67:                extern int16_t target_rmat[9] ;
68:                extern int16_t altitude , altitude_control , climb_rate ;
69:                extern int16_t number_pulses ;
70:                extern int16_t IMU_climb , IMU_altitude ;
71:                extern int16_t target_rate[3] ;
72:                extern union longww IMUlocationx , IMUlocationy , IMUvelocityx , IMUvelocityy ;
73:                extern int16_t x_velocity_feedback , y_velocity_feedback ;
74:                extern int16_t x_velocity_target , y_velocity_target ;
75:                extern int16_t udb_magFieldBody[3] ;
76:                extern fractional magFieldEarth[3];
77:                extern fractional magAlignment[4];
78:                extern int16_t udb_magOffset[3] , errorYawplane[3] , magGain[3] ;
79:                extern uint16_t mission_time ;
80:                extern void compute_euler(void);
81:                extern void compute_bill_angles(void);
82:                extern void update_offset_table(void);
83:                extern float roll_angle , pitch_angle , yaw_angle ;
84:                extern float bill_angle_x , bill_angle_y , bill_angle_z ;
85:                extern int16_t omegacorrI[];
86:                extern uint16_t omega_magnitude ;
87:                extern uint16_t accel_magnitude ;
88:                extern union longww omegagyro_filtered[];
89:                extern struct ADchannel mpu_temp;
90:                extern uint16_t samples ;
91:                extern uint64_t samples_64t ;
92:                extern uint32_t samples_32t ;
93:                extern int16_t adjusted_temperature ;
94:                extern int16_t gyro_offset_entry[] ;
95:                extern uint64_t xx_sum ;
96:                extern int64_t xy_sum[] ;
97:                extern int32_t x_sum ;
98:                extern int32_t y_sum[] ;
99:                extern uint32_t xx_bar ;
100:               extern int32_t xy_bar[] ;
101:               extern int16_t x_bar ;
102:               extern int16_t y_bar[] ;
103:               extern int16_t gyro_offset[];
104:               
105:               extern int16_t gplane[];
106:               extern int16_t aero_force[];
107:               extern void serial_output(const char* format, ...);
108:               void serial_output_start_end_packet(boolean isStart);
109:               // Prepare a line of serial output and start it sending
110:               // GPS data needs to be passed in
111:               extern int16_t yaw_rmat[];
112:               extern int16_t target_altitude , target_climb_rate ;
113:               extern union longww throttle_accum ;
114:               extern void initialize_yaw_rmat(void) ;
115:               uint16_t record_number = 0 ;
116:               #define DIGITS_5 -12805
117:               extern float tilt_angle ;
118:               extern boolean start_log , stop_log ;
119:               boolean logging_on = 0 ;
120:               extern int16_t omega_dot_rmat6 ;
121:               extern int16_t omega_scaled[];
122:               extern int16_t omega_yaw_drift[];
123:               extern int16_t gravity_estimate[];
124:               extern int16_t acceleration[];
125:               boolean gyro_locking_on = 1;
126:               extern int16_t accelOn ;
127:               extern int16_t errorYawplane[];
128:               extern int16_t errorRP[];
129:               extern union longww gyroCorrectionIntegral[];
130:               extern float aero_force_float[];
131:               extern float gravity_float[];
132:               extern float acceleration_float[];
133:               extern float omegaAccum_float[];
134:               extern float velocity ;
135:               extern uint16_t index_msb , index_lsb ;
136:               float yaw_previous ;
137:               float heading ;
138:               float heading_previous ;
139:               float delta_yaw ;
140:               boolean is_first_header = 1;
141:               boolean log_residuals = 0 ;
142:               extern boolean start_residuals ;
143:               extern int16_t omega[];
144:               extern int16_t rup_copy[];
145:               extern union longww coning_angle_adjustment[];
146:               extern union longww omega32[];
147:               extern union longww theta_32[];
148:               extern union longww ggain_32[];
149:               extern int16_t theta_16[];
150:               					
151:               
152:               
153:               void send_residual_data(void)
154:               {
0067B8  FA0000     LNK #0x0
0067BA  BE9F88     MOV.D W8, [W15++]
0067BC  781F8A     MOV W10, [W15++]
155:               	if ( start_residuals == 1)
0067BE  21E5B0     MOV #0x1E5B, W0
0067C0  784010     MOV.B [W0], W0
0067C2  504FE1     SUB.B W0, #0x1, [W15]
0067C4  3A0009     BRA NZ, .L2, .LSM4
156:               	{
157:               		start_residuals = 0 ;
0067C6  21E5B1     MOV #0x1E5B, W1
0067C8  EB4000     CLR.B W0
0067CA  784880     MOV.B W0, [W1]
158:               		serial_output("\r\n\r\nimu_temp_yy,filter_en_yy,x_rate_yy,y_rate_yy,z_rate_yy,x_filt_16_yy,y_filt_16_yy,z_filt_16_yy,x_err_yy,y_err_yy,z_err_yy\r\n") ;
0067CC  2B0920     MOV #0xB092, W0
0067CE  781F80     MOV W0, [W15++]
0067D0  020336     CALL serial_output
0067D2  000000     NOP
0067D4  E9878F     DEC2 W15, W15
0067D6  370033     BRA .L1, .LSM16
159:               	}
160:               	else
161:               	{
162:               		serial_output("%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n",
0067DC  408500     ADD W1, W0, W10
0067E2  408480     ADD W1, W0, W9
0067E8  408400     ADD W1, W0, W8
0067F6  780380     MOV W0, W7
006804  780300     MOV W0, W6
006812  780280     MOV W0, W5
006814  80D2D4     MOV 0x1A5A, W4
006816  80D2C3     MOV 0x1A58, W3
006818  80D2B2     MOV .L3, W2
00681A  80CCE1     MOV accelOn, W1
00681C  80DBD0     MOV 0x1B7A, W0
00681E  781F8A     MOV W10, [W15++]
006820  781F89     MOV W9, [W15++]
006822  781F88     MOV W8, [W15++]
006824  781F87     MOV W7, [W15++]
006826  781F86     MOV W6, [W15++]
006828  781F85     MOV W5, [W15++]
00682A  781F84     MOV W4, [W15++]
00682C  781F83     MOV W3, [W15++]
00682E  781F82     MOV W2, [W15++]
006830  781F81     MOV W1, [W15++]
006832  781F80     MOV W0, [W15++]
006834  2B1110     MOV #0xB111, W0
006836  781F80     MOV W0, [W15++]
006838  020336     CALL serial_output
00683A  000000     NOP
00683C  5787F8     SUB W15, #0x18, W15
163:               				mpu_temp.value,
164:               				accelOn ,
165:               				omegagyro[0],
166:               				omegagyro[1],
167:               				omegagyro[2],
168:               				(int16_t)((omegagyro_filtered[0].WW)>>12) ,
006806  80D5B0     MOV .L10, W0
006808  80D5C1     MOV 0x1AB8, W1
00680A  DD0944     SL W1, #4, W2
00680C  DE004C     LSR W0, #12, W0
00680E  710000     IOR W2, W0, W0
006810  DE88CC     ASR W1, #12, W1
169:               				(int16_t)((omegagyro_filtered[1].WW)>>12) ,
0067F8  80D5D0     MOV 0x1ABA, W0
0067FA  80D5E1     MOV 0x1ABC, W1
0067FC  DD0944     SL W1, #4, W2
0067FE  DE004C     LSR W0, #12, W0
006800  710000     IOR W2, W0, W0
006802  DE88CC     ASR W1, #12, W1
170:               				(int16_t)((omegagyro_filtered[2].WW)>>12) ,
0067EA  80D5F0     MOV 0x1ABE, W0
0067EC  80D601     MOV 0x1AC0, W1
0067EE  DD0944     SL W1, #4, W2
0067F0  DE004C     LSR W0, #12, W0
0067F2  710000     IOR W2, W0, W0
0067F4  DE88CC     ASR W1, #12, W1
171:               				omegagyro[0] + omegagyro_filtered[0]._.W1 ,
0067E4  80D2B1     MOV .L3, W1
0067E6  80D5C0     MOV 0x1AB8, W0
172:               				omegagyro[1] + omegagyro_filtered[1]._.W1 ,
0067DE  80D2C1     MOV 0x1A58, W1
0067E0  80D5E0     MOV 0x1ABC, W0
173:               				omegagyro[2] + omegagyro_filtered[2]._.W1
0067D8  80D2D1     MOV 0x1A5A, W1
0067DA  80D600     MOV 0x1AC0, W0
174:               					);
175:               	}
176:               }
00683E  78054F     MOV [--W15], W10
006840  BE044F     MOV.D [--W15], W8
006842  FA8000     ULNK
006844  060000     RETURN
177:               
178:               void send_imu_data(void)
179:               {
006846  FA0006     LNK #0x6
006848  BE9F88     MOV.D W8, [W15++]
00684A  BE9F8A     MOV.D W10, [W15++]
00684C  BE9F8C     MOV.D W12, [W15++]
180:               #ifndef ALWAYS_LOG
181:               	if (start_log == 1)
00684E  21E550     MOV #0x1E55, W0
006850  784010     MOV.B [W0], W0
006852  504FE1     SUB.B W0, #0x1, [W15]
006854  3A001B     BRA NZ, .L5, .LSM28
182:               	{
183:                       serial_output_start_end_packet(true);
006856  B3C010     MOV.B #0x1, W0
006858  020370     CALL serial_output_start_end_packet
00685A  000000     NOP
184:               		hasWrittenHeader = 0 ;
00685C  21E361     MOV #0x1E36, W1
00685E  EB4000     CLR.B W0
006860  784880     MOV.B W0, [W1]
185:               #ifdef USE_PACKETIZED_TELEMERTY
186:                       is_first_header = 1;
187:               #endif
188:               		if ( is_first_header)
006862  21E3E0     MOV #0x1E3E, W0
006864  784010     MOV.B [W0], W0
006866  504FE0     SUB.B W0, #0x0, [W15]
006868  320006     BRA Z, .L6, .LSM24
189:               		{
190:               			header_line = 0 ;
00686A  EB0000     CLR W0
00686C  88F1C0     MOV W0, .L44
191:               			is_first_header = 0 ;
00686E  21E3E1     MOV #0x1E3E, W1
006870  EB4000     CLR.B W0
006872  784880     MOV.B W0, [W1]
006874  370002     BRA .L7, .LSM25
192:               		}
193:               		else
194:               		{	
195:               			header_line = 22 ;
006876  200160     MOV #0x16, W0
006878  88F1C0     MOV W0, .L44
196:               		}
197:               		start_log = 0 ;
00687A  21E551     MOV #0x1E55, W1
00687C  EB4000     CLR.B W0
00687E  784880     MOV.B W0, [W1]
198:               		logging_on = 1 ;
006880  21E3C1     MOV #0x1E3C, W1
006882  B3C010     MOV.B #0x1, W0
006884  784880     MOV.B W0, [W1]
199:               #ifdef		ALWAYS_SYNC_GYROS
200:               		gyro_locking_on = 1 ;
201:               #else
202:               		gyro_locking_on = 0 ;
006886  21E3D1     MOV #0x1E3D, W1
006888  EB4000     CLR.B W0
00688A  784880     MOV.B W0, [W1]
203:               #endif // ALWAYS_SYNC_GYROS	
204:               	}
205:               	if ( stop_log == 1)
00688C  21E560     MOV #0x1E56, W0
00688E  784010     MOV.B [W0], W0
006890  504FE1     SUB.B W0, #0x1, [W15]
006892  3A000C     BRA NZ, .L8, .LSM33
206:               	{
207:               		stop_log = 0 ;
006894  21E561     MOV #0x1E56, W1
006896  EB4000     CLR.B W0
006898  784880     MOV.B W0, [W1]
208:               		logging_on = 0 ;
00689A  21E3C1     MOV #0x1E3C, W1
00689C  EB4000     CLR.B W0
00689E  784880     MOV.B W0, [W1]
209:               		gyro_locking_on = 1 ;
0068A0  21E3D1     MOV #0x1E3D, W1
0068A2  B3C010     MOV.B #0x1, W0
0068A4  784880     MOV.B W0, [W1]
210:                       serial_output_start_end_packet(false);
0068A6  EB4000     CLR.B W0
0068A8  020370     CALL serial_output_start_end_packet
0068AA  000000     NOP
211:               	}
212:               	if (logging_on == 0 ) return ;
0068AC  21E3C0     MOV #0x1E3C, W0
0068AE  784010     MOV.B [W0], W0
0068B0  504FE0     SUB.B W0, #0x0, [W15]
0068B2  3200E8     BRA Z, .L35, .LSM85
006A84  000000     NOP
213:               #else
214:               	logging_on = 1 ;
215:               	if (start_log == 1)
216:               	{
217:               		start_log = 0 ;
218:               #ifdef		ALWAYS_SYNC_GYROS
219:               		gyro_locking_on = 1 ;
220:               #else
221:               		gyro_locking_on = 0 ;
222:               #endif // ALWAYS_SYNC_GYROS	
223:               	}
224:               	if ( stop_log == 1)
225:               	{
226:               		stop_log = 0 ;
227:               		gyro_locking_on = 1 ;
228:               	}
229:               #endif // ALWAYS_LOG
230:               	db_index = 0 ;
0068B4  EB0000     CLR W0
0068B6  88F1A0     MOV W0, .L45
231:               	if (!hasWrittenHeader)
0068B8  21E360     MOV #0x1E36, W0
0068BA  784010     MOV.B [W0], W0
0068BC  504FE0     SUB.B W0, #0x0, [W15]
0068BE  3A00C3     BRA NZ, .L11, .LSM81
232:               	{
233:               		header_line ++ ;
0068C0  80F1C0     MOV .L44, W0
0068C2  E80000     INC W0, W0
0068C4  88F1C0     MOV W0, .L44
234:               		switch ( header_line ) {
0068C6  80F1C0     MOV .L44, W0
0068C8  B90161     MUL.SU W0, #1, W2
0068CA  EB8000     SETM W0
0068CC  EB8080     SETM W1
0068CE  400002     ADD W0, W2, W0
0068D0  488083     ADDC W1, W3, W1
0068D2  200182     MOV #0x18, W2
0068D4  200003     MOV #0x0, W3
0068D6  500F82     SUB W0, W2, [W15]
0068D8  588F83     SUBB W1, W3, [W15]
0068DA  3E00B3     BRA GTU, .L12, .LSM79
0068DC  016000     BRA W0
0068DE  370018     BRA .L13, .LSM38
0068E0  37001A     BRA .L14, .LSM40
0068E2  370025     BRA .L15, .LSM42
0068E4  37002A     BRA .L16, .LSM44
0068E6  37002F     BRA .L17, .LSM46
0068E8  370034     BRA .L18, .LSM48
0068EA  370039     BRA .L19, .LSM50
0068EC  37003E     BRA .L20, .LSM52
0068EE  370043     BRA .L21, .LSM54
0068F0  37004A     BRA .L22, .LSM56
0068F2  3700A7     BRA .L12, .LSM79
0068F4  370050     BRA .L23, .LSM58
0068F6  3700A5     BRA .L12, .LSM79
0068F8  37005D     BRA .L24, .LSM60
0068FA  3700A3     BRA .L12, .LSM79
0068FC  37005C     BRA .L25, .LSM61
0068FE  3700A1     BRA .L12, .LSM79
006900  370064     BRA .L26, .LSM63
006902  37006F     BRA .L27, .LSM65
006904  37007A     BRA .L28, .LSM67
006906  370081     BRA .L29, .LSM69
006908  37009C     BRA .L12, .LSM79
00690A  37008E     BRA .L30, .LSM74
00690C  37009A     BRA .L12, .LSM79
00690E  370092     BRA .L31, .LSM76
235:               		case 1:
236:               			initialize_yaw_rmat();
006910  026714     CALL initialize_yaw_rmat
006912  000000     NOP
237:               			break ;
006914  370097     BRA .L33, .LSM80
238:               		case 2:
239:               			{
240:               #ifndef NAME
241:               				serial_output("WOLF-PAC SN%i%i%i IMU ", SERIAL_NUMBERD1 , SERIAL_NUMBERD2 , SERIAL_NUMBERD3 ) ;
006916  200020     MOV #0x2, W0
006918  781F80     MOV W0, [W15++]
00691A  EB0000     CLR W0
00691C  781F80     MOV W0, [W15++]
00691E  EB0000     CLR W0
006920  781F80     MOV W0, [W15++]
006922  2B1340     MOV #0xB134, W0
006924  781F80     MOV W0, [W15++]
006926  020336     CALL serial_output
006928  000000     NOP
00692A  5787E8     SUB W15, #0x8, W15
242:               #else
243:               				serial_output("WOLF-PAC SN%i%i%i IMU, assigned to %s, ", SERIAL_NUMBERD1 , SERIAL_NUMBERD2 , SERIAL_NUMBERD3, NAME ) ;
244:               #endif
245:               			}
246:               			break ;
00692C  37008B     BRA .L33, .LSM80
247:               		case 3:
248:               			{
249:               				serial_output(DATE);
00692E  2B14B0     MOV #0xB14B, W0
006930  781F80     MOV W0, [W15++]
006932  020336     CALL serial_output
006934  000000     NOP
006936  E9878F     DEC2 W15, W15
250:               			}
251:               			break;
006938  370085     BRA .L33, .LSM80
252:               		case 4:
253:               			{
254:               				serial_output("Measurements expressed in north-east-down body frame.\r\n") ;
00693A  2B1610     MOV #0xB161, W0
00693C  781F80     MOV W0, [W15++]
00693E  020336     CALL serial_output
006940  000000     NOP
006942  E9878F     DEC2 W15, W15
255:               			}
256:               			break ;	
006944  37007F     BRA .L33, .LSM80
257:               		case 5:
258:               			{
259:               #ifdef LOG_RATE
260:               				serial_output("gyro rate version\r\n");
261:               #endif // LOG_RATE
262:               				
263:               #ifdef LOG_EULER
264:               				serial_output("Euler angle version.\r\n");
006946  2B1990     MOV #0xB199, W0
006948  781F80     MOV W0, [W15++]
00694A  020336     CALL serial_output
00694C  000000     NOP
00694E  E9878F     DEC2 W15, W15
265:               #endif // LOG_EULER
266:               #ifdef LOG_RATE_AND_EULER
267:               			serial_output("gyro rates and euler angles version\r\n");	
268:               #endif // LOG_RATE_AND_EULER
269:               #ifdef LOG_PITCH_AND_TWO_FORCES
270:               			serial_output("x force, z force and pitch angle\r\n");
271:               #endif // LOG_PITCH_AND_TWO_FORCES
272:               			}
273:               			break ;
006950  370079     BRA .L33, .LSM80
274:               		case 6:
275:               			{
276:               				serial_output("Specific forces in ft/s^2.\r\n") ;
006952  2B1B00     MOV #0xB1B0, W0
006954  781F80     MOV W0, [W15++]
006956  020336     CALL serial_output
006958  000000     NOP
00695A  E9878F     DEC2 W15, W15
277:               			}
278:               			break ;	
00695C  370073     BRA .L33, .LSM80
279:               		case 7:
280:               			{
281:               				serial_output("CCW rotation rates in d/s.\r\n");
00695E  2B1CD0     MOV #0xB1CD, W0
006960  781F80     MOV W0, [W15++]
006962  020336     CALL serial_output
006964  000000     NOP
006966  E9878F     DEC2 W15, W15
282:               			}
283:               			break ;	
006968  37006D     BRA .L33, .LSM80
284:               		case 8:
285:               			{
286:               				serial_output( BOARD );
00696A  2B1EA0     MOV #0xB1EA, W0
00696C  781F80     MOV W0, [W15++]
00696E  020336     CALL serial_output
006970  000000     NOP
006972  E9878F     DEC2 W15, W15
287:               			}
288:               		break ;
006974  370067     BRA .L33, .LSM80
289:               		case 9:
290:               			{
291:               				serial_output( "Accelerometer range is %i times gravity.\r\n" , ACCEL_RANGE ) ;
006976  200080     MOV #0x8, W0
006978  781F80     MOV W0, [W15++]
00697A  2B2110     MOV #0xB211, W0
00697C  781F80     MOV W0, [W15++]
00697E  020336     CALL serial_output
006980  000000     NOP
006982  5787E4     SUB W15, #0x4, W15
292:               			}
293:               			break ;
006984  37005F     BRA .L33, .LSM80
294:               		case 10:
295:               			{
296:               				serial_output( "Gyro range is %i deg/sec.\r\n" , GYRO_RANGE ) ;
006986  203E80     MOV #0x3E8, W0
006988  781F80     MOV W0, [W15++]
00698A  2B23C0     MOV #0xB23C, W0
00698C  781F80     MOV W0, [W15++]
00698E  020336     CALL serial_output
006990  000000     NOP
006992  5787E4     SUB W15, #0x4, W15
297:               			}
298:               			break ;
006994  370057     BRA .L33, .LSM80
299:               		case 12:
300:               			{
301:               				serial_output("Gyro calibrations are x=%6.4f, y=%6.4f, z=%6.4f.\r\n", 
006996  254CA0     MOV #0x54CA, W0
006998  23F811     MOV #0x3F81, W1
00699A  BE9F80     MOV.D W0, [W15++]
00699C  2EBEE0     MOV #0xEBEE, W0
00699E  23F801     MOV #0x3F80, W1
0069A0  BE9F80     MOV.D W0, [W15++]
0069A2  248170     MOV #0x4817, W0
0069A4  23F801     MOV #0x3F80, W1
0069A6  BE9F80     MOV.D W0, [W15++]
0069A8  2B2580     MOV #0xB258, W0
0069AA  781F80     MOV W0, [W15++]
0069AC  020336     CALL serial_output
0069AE  000000     NOP
0069B0  5787EE     SUB W15, #0xE, W15
302:               						CALIBRATIONX ,CALIBRATIONY,CALIBRATIONZ );		
303:               			}
304:               			break ;
0069B2  370048     BRA .L33, .LSM80
305:               		case 14:
306:               			break ;
0069B4  370047     BRA .L33, .LSM80
307:               		case 16:
308:               			{
309:               				serial_output("Tilt start angle = %i deg, stop = %i deg.\r\n", TILT_START , TILT_STOP);
0069B6  2003C0     MOV #0x3C, W0
0069B8  781F80     MOV W0, [W15++]
0069BA  2000F0     MOV #0xF, W0
0069BC  781F80     MOV W0, [W15++]
0069BE  2B28B0     MOV #0xB28B, W0
0069C0  781F80     MOV W0, [W15++]
0069C2  020336     CALL serial_output
0069C4  000000     NOP
0069C6  5787E6     SUB W15, #0x6, W15
310:               			}
311:               			break ;
0069C8  37003D     BRA .L33, .LSM80
312:               		case 18:
313:               			{
314:               				serial_output( "Accel offsets are x=%i, y=%i, z=%i.\r\n",
0069CA  2FE110     MOV #0xFE11, W0
0069CC  781F80     MOV W0, [W15++]
0069CE  200260     MOV #0x26, W0
0069D0  781F80     MOV W0, [W15++]
0069D2  2009F0     MOV #0x9F, W0
0069D4  781F80     MOV W0, [W15++]
0069D6  2B2B70     MOV #0xB2B7, W0
0069D8  781F80     MOV W0, [W15++]
0069DA  020336     CALL serial_output
0069DC  000000     NOP
0069DE  5787E8     SUB W15, #0x8, W15
315:               					XACCEL_OFFSET ,
316:               					YACCEL_OFFSET , 
317:               					ZACCEL_OFFSET 
318:               					 );	
319:               			}
320:               			break;
0069E0  370031     BRA .L33, .LSM80
321:               		case 19:
322:               			{
323:               				serial_output( "Accel calibrations are x=%i, y=%i, z=%i.\r\n",
0069E2  210490     MOV #0x1049, W0
0069E4  781F80     MOV W0, [W15++]
0069E6  20FFE0     MOV #0xFFE, W0
0069E8  781F80     MOV W0, [W15++]
0069EA  210240     MOV #0x1024, W0
0069EC  781F80     MOV W0, [W15++]
0069EE  2B2DD0     MOV #0xB2DD, W0
0069F0  781F80     MOV W0, [W15++]
0069F2  020336     CALL serial_output
0069F4  000000     NOP
0069F6  5787E8     SUB W15, #0x8, W15
324:               					CAL_GRAV_X ,
325:               					CAL_GRAV_Y , 
326:               					CAL_GRAV_Z 
327:               					 );
328:               			}
329:               			break;
0069F8  370025     BRA .L33, .LSM80
330:               		case 20:
331:               			{
332:               				serial_output("Data rate is %i records/s.\r\n", LOGGER_HZ );
0069FA  200320     MOV #0x32, W0
0069FC  781F80     MOV W0, [W15++]
0069FE  2B3080     MOV #0xB308, W0
006A00  781F80     MOV W0, [W15++]
006A02  020336     CALL serial_output
006A04  000000     NOP
006A06  5787E4     SUB W15, #0x4, W15
333:               			}
334:               			break;
006A08  37001D     BRA .L33, .LSM80
335:               		case 21:
336:               			{
337:               				serial_output(FILTERING);
006A0A  2B3250     MOV #0xB325, W0
006A0C  781F80     MOV W0, [W15++]
006A0E  020336     CALL serial_output
006A10  000000     NOP
006A12  E9878F     DEC2 W15, W15
338:               #ifndef ALWAYS_LOG
339:               #ifndef USE_PACKETIZED_TELEMERTY
340:               				stop_log = 1 ;
006A14  21E561     MOV #0x1E56, W1
006A16  B3C010     MOV.B #0x1, W0
006A18  784880     MOV.B W0, [W1]
341:               				start_residuals = 1 ;
006A1A  21E5B1     MOV #0x1E5B, W1
006A1C  B3C010     MOV.B #0x1, W0
006A1E  784880     MOV.B W0, [W1]
342:               				hasWrittenHeader = 1 ;
006A20  21E361     MOV #0x1E36, W1
006A22  B3C010     MOV.B #0x1, W0
006A24  784880     MOV.B W0, [W1]
343:               #endif
344:               #endif // ALWAYS_LOG
345:               				
346:               			}
347:               			break;
006A26  37000E     BRA .L33, .LSM80
348:               		case 23:
349:               			{
350:               #ifdef LOG_IMU
351:               				// initialize the unwrapping of yaw angle
352:               				compute_euler();
353:               				yaw_previous = yaw_angle ;
354:               				heading_previous = 0.0 ;
355:               #ifdef LOG_RATE
356:               				serial_output( "forward_force , lateral , vertical , roll_rate , pitch , yaw\r\n" ) ;
357:               #endif // LOG_RATE
358:               #ifdef LOG_EULER
359:               #ifndef THETA_LOG
360:               				serial_output( "\r\n\r\nx_force_xx,y_force_xx,z_force_xx,yaw_xx,pitch_xx,roll_xx\r\n" ) ;
361:               #else
362:               				serial_output("\r\r\r\nx_theta,y_theta,x_omega,y_omega,pitch,roll\r\n") ;
363:               #endif // THETA_LOG
364:               #endif // LOG_EULER	
365:               #ifdef LOG_RATE_AND_EULER
366:               				serial_output( "\r\n\r\nx_rate_xx,y_rate_xx,z_rate_xx,yaw_xx,pitch_xx,roll_xx\r\n" ) ;		
367:               #endif // LOG_RATE_AND_EULER
368:               #ifdef LOG_PITCH_AND_TWO_FORCES
369:               				serial_output( "\r\n\r\nx_force_xx,z_force,pitch_xx\r\n" ) ;	
370:               #endif // LOG_PITCH_AND_TWO_FORCES
371:               #endif // LOG_IMU
372:               				
373:               #ifdef LOG_TIC_TOK_TEST
374:               //				serial_output("\r\n\r\ncpu,tlt_x,tlt_y,tlt_z,wx,wy,wz,theta_x,theta_y,theta_z,t32_x,t32_y,t32_z\r\n");
375:               				serial_output("\r\n\r\ncpu,tlt_x,tlt_y,tlt_z,t32_x,t32_y,t32_z\r\n");
006A28  2B3640     MOV #0xB364, W0
006A2A  781F80     MOV W0, [W15++]
006A2C  020336     CALL serial_output
006A2E  000000     NOP
006A30  E9878F     DEC2 W15, W15
376:               #endif // LOG_TIC_TOK_TEST
377:               				
378:               #ifdef RECORD_OFFSETS
379:               				serial_output("tmptur,ax,ay,az,gx_val,gy_val,gz_val,gyr_x,gyr_y,gyr_z\r\n");
380:               #endif // RECORD_OFFSETS
381:               				
382:               #ifdef TEST_LOGGER_HZ
383:               				serial_output("logger bandwidth test\r\n");
384:               #endif // TEST_LOGGER_HZ
385:               #ifdef GYRO_CALIB
386:               				serial_output("X, Y, Z calib angles\r\n") ;
387:               #endif // GYRO_CALIB
388:               #ifdef LOG_VELOCITY
389:               				serial_output( "gyro_sync,cpu,wx,wy,wz,fx,fy,fz,gx,gy,gz,ax,ay,az,vel\r\n");
390:               #endif // LOG_VELOCITY
391:               #ifdef TEST_GYRO_LOCK
392:               				serial_output("o_dot_r6,errYx,errYy,errYz,errRPx,errRPy,errRPz,wx,wy,wz\r\n" );
393:               #endif // TEST_GYRO_LOCK
394:               #ifdef GYRO_DRIFT
395:               //				serial_output("gx,gy,gyz,gxfilt,gyfilt,gzfilt,ax,ay,az,axfilt,ayfilt,azfilt\r\n");
396:               				serial_output("\r\ntmptur,synch,cpu_load,w_mag,acc_mag,yaw,pitch,roll,gx,gy,gz,gxlp,gylp,gzlp,errx,erry,errz\r\n");
397:               #endif // GYRO_DRIFT
398:               #ifdef GYRO_OFFSETS
399:               				serial_output("\r\ntmptr,ind_msb,ind_lsb,w_mag,acc_mag,xrv,yrv,zrv,xro,yro,zro,wx,wy,wz\r\n");
400:               #endif //				
401:               #ifdef ROAD_TEST
402:               		serial_output("synch,gx,gy,gyz,ax,ay,az,r6,r7,r8\r\n");
403:               #endif // ROAD_TEST
404:               #ifdef BUILD_OFFSET_TABLE
405:               		serial_output("\r\ncpu,samples,X_bar,Y_bar_x,Y_bar_y,Y_bar_z,XX_bar,XY_bar_x,XY_bar_y,XY_bar_z,denom,lft_o_x,lft_o_y,lft_o_z,rght_o_x,rght_o_y,rght_o_z,offx,offy,offz\r\n");
406:               #endif //BUILD_OFFSET_TABLE
407:               			}
408:               			break ;	
006A32  370008     BRA .L33, .LSM80
409:               		case 25:
410:                           start_residuals = 1 ;
006A34  21E5B1     MOV #0x1E5B, W1
006A36  B3C010     MOV.B #0x1, W0
006A38  784880     MOV.B W0, [W1]
411:                           hasWrittenHeader = 1 ;
006A3A  21E361     MOV #0x1E36, W1
006A3C  B3C010     MOV.B #0x1, W0
006A3E  784880     MOV.B W0, [W1]
412:               			break ;
006A40  370001     BRA .L33, .LSM80
413:               		default:
414:               			break ;
006A42  000000     NOP
415:               		}
416:               	}
417:               	else
418:               	{
419:               #ifdef RECORD_OFFSETS 
420:               		{	
421:               			serial_output( "%i,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n" ,
422:               			mpu_temp.value,
423:               			udb_xaccel.value , udb_yaccel.value , udb_zaccel.value ,
424:               			udb_xrate.value , udb_yrate.value , udb_zrate.value	,
425:               			omegagyro[0],omegagyro[1],omegagyro[2]
426:               			 ) ;
427:               		}
428:               #endif // RECORD_OFFSETS
429:               		
430:               #ifdef GYRO_OFFSETS
431:               		{
432:               			serial_output( "%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n" ,
433:               				mpu_temp.value,
434:               				index_msb , index_lsb ,
435:               				omega_magnitude ,
436:               				accel_magnitude ,
437:               				64*udb_xrate.value , 64*udb_yrate.value , 64*udb_zrate.value	,	
438:               				gyro_offset[0] , gyro_offset[1] , gyro_offset[2] ,
439:               				omegagyro[0] , omegagyro[1], omegagyro[2]
440:               			 ) ;
441:               		}
442:               #endif // 
443:               
444:               #ifdef TEST_LOGGER_HZ
445:               #ifdef PARTIAL_RECORD		
446:               		{
447:               			serial_output("22 chars test string\r\n") ;
448:               		}
449:               #endif // PARTIAL_RECORD
450:               #ifdef FULL_RECORD
451:               		{
452:               			serial_output("43 chars test string 43 chars test string\r\n") ;
453:               		}
454:               #endif	
455:               #endif // TEST_LOGGER_HZ
456:               
457:               #ifdef LOG_IMU
458:               #ifdef LOG_RATE
459:               		{
460:               			serial_output( "%.1f,%.1f,%.1f,%.1f,%.1f,%.1f\r\n" ,
461:               				((double)(aero_force[0]))/ACCEL_FACTOR ,
462:               				((double)(aero_force[1]))/ACCEL_FACTOR ,
463:               				((double)(aero_force[2]))/ACCEL_FACTOR ,
464:               				((double)(omegaAccum[0]))/GYRO_FACTOR ,
465:               				((double)(omegaAccum[1]))/GYRO_FACTOR , 
466:               				((double)(omegaAccum[2]))/GYRO_FACTOR ) ;	
467:               		}
468:               #endif // LOG_RATE
469:               #ifdef LOG_EULER
470:               		{
471:               			compute_euler();
472:               			delta_yaw = yaw_angle - yaw_previous ;
473:               			if (abs(delta_yaw)<90.0)
474:               			{
475:               				heading = heading_previous + delta_yaw ;
476:               			}
477:               			else if(delta_yaw>0)
478:               			{
479:               				heading = heading_previous + delta_yaw - 360.0 ;
480:               			}
481:               			else
482:               			{
483:               				heading = heading_previous + delta_yaw + 360.0 ;
484:               			}
485:               			heading_previous = heading ;
486:               			yaw_previous = yaw_angle ;
487:               #ifndef THETA_LOG
488:               			serial_output( "%.2f,%.1f,%.1f,%.1f,%.2f,%.1f\r\n" ,
489:               				((double)(aero_force[0]))/ACCEL_FACTOR ,
490:               				((double)(aero_force[1]))/ACCEL_FACTOR ,
491:               				((double)(aero_force[2]))/ACCEL_FACTOR ,
492:               				heading ,  pitch_angle , roll_angle  ) ;	
493:               #else
494:               			serial_output("%i,%i,%i,%i,%.2f,%.2f\r\n" ,
495:               					theta[0] , theta[1] ,
496:               					omega[0] , omega[1] ,
497:               					pitch_angle , roll_angle ) ;
498:               #endif // THETA_LOG
499:               		}
500:               #endif // LOG_EULER
501:               #ifdef LOG_RATE_AND_EULER
502:               		{
503:               			compute_euler();
504:               			serial_output( "%.1f,%.1f,%.1f,%.1f,%.2f,%.1f\r\n" ,
505:               				((double)(omegaAccum[0]))/GYRO_FACTOR ,
506:               				((double)(omegaAccum[1]))/GYRO_FACTOR , 
507:               				((double)(omegaAccum[2]))/GYRO_FACTOR ,
508:               				yaw_angle ,  pitch_angle , roll_angle ) ;	
509:               		}
510:               #endif // LOG_RATE_AND_EULER
511:               #ifdef LOG_PITCH_AND_TWO_FORCES
512:               		{
513:               			compute_euler();
514:               			serial_output( "%.2f,%.1f,%.2f\r\n" ,
515:               				((double)(aero_force[0]))/ACCEL_FACTOR ,
516:               				((double)(aero_force[2]))/ACCEL_FACTOR ,
517:               				pitch_angle   ) ;	
518:               		}	
519:               #endif // LOG_PITCH_AND_TWO_FORCES
520:               #endif // LOG_IMU
521:               #ifdef LOG_TIC_TOK_TEST
522:               		{
523:               			serial_output("%i,%i,%i,%i,%li,%li,%li\r\n" ,
006A46  80DD6C     MOV 0x1BAC, W12
006A48  80DD7D     MOV 0x1BAE, W13
006A4A  80DD4A     MOV 0x1BA8, W10
006A4C  80DD5B     MOV 0x1BAA, W11
006A4E  80DD28     MOV theta_32, W8
006A50  80DD39     MOV 0x1BA6, W9
006A52  80D2A0     MOV 0x1A54, W0
006A54  780F00     MOV W0, [W14]
006A56  80D291     MOV 0x1A52, W1
006A58  980711     MOV W1, [W14+2]
006A5A  80D280     MOV 0x1A50, W0
006A5C  980720     MOV W0, [W14+4]
006A62  FB8000     ZE W0, W0
006A64  BE9F8C     MOV.D W12, [W15++]
006A66  BE9F8A     MOV.D W10, [W15++]
006A68  BE9F88     MOV.D W8, [W15++]
006A6A  78009E     MOV [W14], W1
006A6C  781F81     MOV W1, [W15++]
006A6E  90009E     MOV [W14+2], W1
006A70  781F81     MOV W1, [W15++]
006A72  9000AE     MOV [W14+4], W1
006A74  781F81     MOV W1, [W15++]
006A76  781F80     MOV W0, [W15++]
006A78  2B3920     MOV #0xB392, W0
006A7A  781F80     MOV W0, [W15++]
006A7C  020336     CALL serial_output
006A7E  000000     NOP
006A80  5787F6     SUB W15, #0x16, W15
524:               					udb_cpu_load(),
006A5E  027BBC     CALL udb_cpu_load
006A60  000000     NOP
525:               					rmat[6],rmat[7],rmat[8],
526:               	//				omegagyro[0] , omegagyro[1], omegagyro[2],			
527:               	//				theta[0],theta[1],theta[2],
528:               	//				theta_16[0],theta_16[1],theta_16[2]
529:               	//				(int16_t)((theta_32[0].WW + 0x00008000)>>16) ,
530:               	//				(int16_t)((theta_32[1].WW + 0x00008000)>>16) ,
531:               	//				(int16_t)((theta_32[2].WW + 0x00008000)>>16)
532:               					theta_32[0].WW ,
533:               					theta_32[1].WW ,
534:               					theta_32[2].WW
535:               					
536:               	//				coning_angle_adjustment[0].WW ,
537:               	//				coning_angle_adjustment[1].WW ,
538:               	//				coning_angle_adjustment[2].WW
539:               			);
540:               		}
541:               #endif // LOG_TIC_TOK_TEST
542:               #ifdef GYRO_CALIB
543:               
544:               		{	compute_bill_angles();
545:               			serial_output("%6.1f,%6.1f,%6.1f\r\n", bill_angle_x , bill_angle_y , bill_angle_z);
546:               
547:               		}	
548:               #endif // GYRO_CALIB
549:               #ifdef GYRO_DRIFT
550:               		compute_euler();
551:               		serial_output("%i,%i,%i,%i,%i,%.1f,%.1f,%.1f,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n",
552:               				mpu_temp.value,
553:               				accelOn ,
554:               				udb_cpu_load(),
555:               				omega_magnitude ,
556:               				accel_magnitude ,
557:               				yaw_angle , pitch_angle , roll_angle ,
558:               				omegagyro[0],
559:               				omegagyro[1],
560:               				omegagyro[2],
561:               				(int16_t)((omegagyro_filtered[0].WW)>>12) ,
562:               				(int16_t)((omegagyro_filtered[1].WW)>>12) ,
563:               				(int16_t)((omegagyro_filtered[2].WW)>>12) ,
564:               				errorRP[0] ,
565:               				errorRP[1] ,
566:               				errorRP[2]
567:               					);
568:               		
569:               #endif // GYRO_DRIFT
570:               		
571:               #ifdef BUILD_OFFSET_TABLE
572:               		update_offset_table();
573:               	
574:               		
575:               #endif //
576:               
577:               #ifdef ROAD_TEST
578:               		serial_output("%i,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n",
579:               				gyro_locking_on ,
580:               				omegaAccum[0],
581:               				omegaAccum[1],
582:               				omegaAccum[2] ,
583:               				aero_force[0] ,
584:               				aero_force[1] ,
585:               				aero_force[2] ,
586:               				rmat[6] ,
587:               				rmat[7] ,
588:               				rmat[8] 
589:               					);
590:               	
591:               #endif // GYRO_DRIFT
592:               
593:               
594:               #ifdef LOG_VELOCITY
595:               		{
596:               			serial_output("%i,%i,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\r\n",
597:               					accelOn , udb_cpu_load() ,
598:               					omegaAccum_float[0] ,
599:               					omegaAccum_float[1] , 
600:               					omegaAccum_float[2] ,
601:               					aero_force_float[0] , aero_force_float[1] , aero_force_float[2] ,
602:               					gravity_float[0] , gravity_float[1] , gravity_float[2] ,
603:               					acceleration_float[0] , acceleration_float[1] , acceleration_float[2] , velocity 
604:               					);
605:               		}
606:               #endif // LOG_VELOCITY
607:               		
608:               #ifdef TEST_GYRO_LOCK
609:               		{
610:               			serial_output( "%i,%i,%i,%i,%i,%i,%i,%i,%i,%i\r\n",
611:               					omega_dot_rmat6 ,
612:               					errorYawplane[0] , errorYawplane[1] , errorYawplane[2] , 
613:               					errorRP[0] , errorRP[1] , errorRP[2] , 
614:               					omegaAccum[0] , omegaAccum[1] , omegaAccum[2] 
615:               					) ;
616:               		}
617:               #endif // 
618:               	}
619:               	return ;
006A44  370020     BRA .L4, .LSM86
006A82  370001     BRA .L4, .LSM86
620:               }
006A86  BE064F     MOV.D [--W15], W12
006A88  BE054F     MOV.D [--W15], W10
006A8A  BE044F     MOV.D [--W15], W8
006A8C  FA8000     ULNK
006A8E  060000     RETURN
621:               /*
622:               extern int gplane[] ;
623:               // Prepare a line of serial output and start it sending
624:               void send_debug_line( void )
625:               {
626:               	db_index = 0 ;
627:               	
628:               	if (!hasWrittenHeader)
629:               	{
630:               		sprintf(debug_buffer, "w0 , w1 , w2 , a0 , a1 , a2\r\n") ;
631:               		hasWrittenHeader = 1 ;
632:               	}
633:               	else
634:               	{
635:               		sprintf(debug_buffer, "%i , %i , %i , %i , %i , %i\r\n" ,
636:               		omegagyro[0] , 	omegagyro[1] , omegagyro[2] ,
637:               		gplane[0] , gplane[1] , gplane[2]
638:               		 ) ;
639:               	}
640:               	
641:               	udb_serial_start_sending_data() ;
642:               	
643:               	return ;
644:               }
645:               */
646:               
---  C:/Users/bill/Desktop/git_repos/git_luge/MultiRotor/serial_output.c  -------------------------------
1:                 #include <string.h>
2:                 #include <stdio.h>
3:                 #include <stdarg.h>
4:                 #include "../libUDB/libUDB.h"
5:                 #include "../libUDB/oscillator.h"
6:                 #include "../libUDB/interrupt.h"
7:                 #include "../libUDB/serialIO.h"
8:                 
9:                 #define SERIAL_BUFFER_SIZE	1536
10:                #define NUM_CHUNKS_TO_BUFFER 16
11:                
12:                // Set up two serial buffers, and swap back and forth between then as we buffer
13:                // and send long messages in bursts, to create longer times between each burst
14:                // of data for the ESP32 on the receiving end to have uninterrupted time to
15:                // write the data to flash.
16:                
17:                #ifdef USE_PACKETIZED_TELEMERTY
18:                uint8_t serial_buffer[2][SERIAL_BUFFER_SIZE] ;
19:                uint16_t end_index[2] = {0, 0};
20:                uint8_t write_buffer_index = 0;
21:                uint8_t read_buffer_index = 0;
22:                uint16_t packet_data_start;
23:                uint16_t packet_data_length;
24:                uint8_t num_chunks_buffered = 0;
25:                void finalize_packet();
26:                #else
27:                uint8_t serial_buffer[SERIAL_BUFFER_SIZE] ;
28:                uint16_t end_index = 0;
29:                #endif
30:                
31:                uint16_t sb_index = 0 ;
32:                
33:                static boolean udb_serial_stop_sending_flag = 0;
34:                
35:                extern int16_callback_fptr_t serial_callback_get_byte_to_send ;
36:                extern callback_uint8_fptr_t serial_callback_received_byte ;
37:                
38:                int vsnprintf (char * s, size_t n, const char * format, va_list arg );
39:                
40:                
41:                void __attribute__((__interrupt__, __no_auto_psv__)) _U2TXInterrupt(void)
42:                {
0002C8  F80036     PUSH RCOUNT
0002CA  BE9F80     MOV.D W0, [W15++]
0002CC  BE9F82     MOV.D W2, [W15++]
0002CE  BE9F84     MOV.D W4, [W15++]
0002D0  BE9F86     MOV.D W6, [W15++]
0002D2  FA0002     LNK #0x2
43:                	_U2TXIF = 0; // clear the interrupt
0002D4  A9E087     BCLR 0x87, #7
44:                    // prevent losing a character when stop and start sending data
45:                    if (U2STAbits.UTXBF == 0)
0002D6  801191     MOV U2STA, W1
0002D8  202000     MOV #0x200, W0
0002DA  608000     AND W1, W0, W0
0002DC  500FE0     SUB W0, #0x0, [W15]
0002DE  3A0017     BRA NZ, .LBE2, .LSM10, .L1
46:                    {
47:                        indicate_loading_inter;
48:                        set_ipl_on_output_pin;
49:                        interrupt_save_set_corcon;
0002E0  F80044     PUSH CORCON
0002E2  80F530     MOV 0x1EA6, W0
0002E4  880220     MOV W0, CORCON
50:                
51:                        int16_t txchar = -1;
0002E6  EB8000     SETM W0
0002E8  780F00     MOV W0, [W14]
52:                        if (serial_callback_get_byte_to_send && ! udb_serial_stop_sending_flag)
0002EA  80F480     MOV 0x1E90, W0
0002EC  500FE0     SUB W0, #0x0, [W15]
0002EE  320007     BRA Z, .LSM7, .L3
0002F0  2155E0     MOV #0x155E, W0
0002F2  784010     MOV.B [W0], W0
0002F4  504FE0     SUB.B W0, #0x0, [W15]
0002F6  3A0003     BRA NZ, .LSM7, .L3
53:                        {
54:                            txchar = serial_callback_get_byte_to_send();
0002F8  80F480     MOV 0x1E90, W0
0002FA  010000     CALL W0
0002FC  780F00     MOV W0, [W14]
55:                        }
56:                        if (txchar != -1)
0002FE  78001E     MOV [W14], W0
000300  400FE1     ADD W0, #0x1, [W15]
000302  320004     BRA Z, .LSM9, .L4
57:                        {
58:                            U2TXREG = (uint8_t)txchar;
000304  78001E     MOV [W14], W0
000306  784000     MOV.B W0, W0
000308  FB8000     ZE W0, W0
00030A  8811A0     MOV W0, U2TXREG
59:                        }
60:                        interrupt_restore_corcon;
00030C  F90044     POP CORCON
61:                        unset_ipl_on_output_pin;
62:                    }
63:                }
00030E  FA8000     ULNK
000310  BE034F     MOV.D [--W15], W6
000312  BE024F     MOV.D [--W15], W4
000314  BE014F     MOV.D [--W15], W2
000316  BE004F     MOV.D [--W15], W0
000318  F90036     POP RCOUNT
00031A  064000     RETFIE
64:                
65:                
66:                void udb_serial_start_sending_data(void)
67:                {
00031C  FA0000     LNK #0x0
68:                	 udb_serial_stop_sending_flag = false;
00031E  2155E1     MOV #0x155E, W1
000320  EB4000     CLR.B W0
000322  784880     MOV.B W0, [W1]
69:                	_U2TXIF = 1; // fire the tx interrupt
000324  A8E087     BSET 0x87, #7
70:                }
000326  FA8000     ULNK
000328  060000     RETURN
71:                
72:                void udb_serial_stop_sending_data(void)
73:                {
00032A  FA0000     LNK #0x0
74:                    udb_serial_stop_sending_flag = true; 
00032C  2155E1     MOV #0x155E, W1
00032E  B3C010     MOV.B #0x1, W0
000330  784880     MOV.B W0, [W1]
75:                }
000332  FA8000     ULNK
000334  060000     RETURN
76:                
77:                
78:                #ifdef USE_PACKETIZED_TELEMERTY
79:                
80:                // Super Simple Packetization protocol:
81:                // 0xDED1            - Start a new file
82:                // 0xDED3            - Close current file
83:                // 0xDED2LLLLXXXX... - Send a packet of data 0xLLLL bytes long
84:                //                     High length byte, low length byte, then N data bytes
85:                // 
86:                // We bundle up NUM_CHUNKS_TO_BUFFER messages into one packet, so that we're
87:                // able to burst a bunch of data at once, leaving some time in between these
88:                // large packets, since the ESP32 needs uninterrupted time to write this data
89:                // to flash storage in between packets.
90:                
91:                void serial_output(const char* format, ...)
92:                {
93:                	uint16_t start_index;
94:                	uint16_t remaining;
95:                    uint16_t wrote;
96:                    va_list arglist;
97:                    
98:                    va_start(arglist, format);
99:                    
100:               	start_index = end_index[write_buffer_index];
101:               	remaining = SERIAL_BUFFER_SIZE - start_index;
102:               
103:               	if (remaining > 5)
104:               	{
105:                       if (num_chunks_buffered == 0) {
106:                           serial_buffer[write_buffer_index][start_index++] = 0xDE;
107:                           serial_buffer[write_buffer_index][start_index++] = 0xD2;
108:                           serial_buffer[write_buffer_index][start_index++] = 0x00; // Save space for length bytes
109:                           serial_buffer[write_buffer_index][start_index++] = 0x00;
110:                           packet_data_start = start_index;
111:                           packet_data_length = 0;
112:                       }
113:                       
114:               		wrote = vsnprintf((char*)(&serial_buffer[write_buffer_index][start_index]), (size_t)remaining, format, arglist);
115:                       
116:                       packet_data_length += wrote;
117:               		end_index[write_buffer_index] = start_index + wrote;
118:                       num_chunks_buffered++;
119:                       
120:                       if (num_chunks_buffered >= NUM_CHUNKS_TO_BUFFER) {
121:                           finalize_packet();
122:                           read_buffer_index = write_buffer_index;
123:                           write_buffer_index = !write_buffer_index;
124:                           udb_serial_start_sending_data();
125:                       }
126:               	}
127:                   
128:                   va_end(arglist);
129:               }
130:               
131:               void finalize_packet()
132:               {
133:                   if (num_chunks_buffered && packet_data_start) {
134:                       // Go back and write the length bytes
135:                       uint8_t lenH = packet_data_length/256;
136:                       uint8_t lenL = packet_data_length%256;
137:                       serial_buffer[write_buffer_index][packet_data_start-2] = lenH;
138:                       serial_buffer[write_buffer_index][packet_data_start-1] = lenL;
139:                       num_chunks_buffered = 0;
140:                   }
141:               }
142:               
143:               void serial_output_start_end_packet(boolean isStart)
144:               {
145:                   while (end_index[read_buffer_index]) ;
146:                   
147:                   finalize_packet();
148:                   
149:               	int16_t remaining = SERIAL_BUFFER_SIZE - end_index[write_buffer_index];
150:                   if (remaining > 2) {
151:                       serial_buffer[write_buffer_index][end_index[write_buffer_index]++] = 0xDE;
152:                       serial_buffer[write_buffer_index][end_index[write_buffer_index]++] = (isStart) ? 0xD1 : 0xD3;
153:                       read_buffer_index = write_buffer_index;
154:                       write_buffer_index = !write_buffer_index;
155:                       udb_serial_start_sending_data();
156:                   }
157:               }
158:               
159:               
160:               int16_t udb_serial_callback_get_byte_to_send(void)
161:               {
162:                   if (sb_index < end_index[read_buffer_index]) {
163:                   	return serial_buffer[read_buffer_index][ sb_index++ ];
164:               	}
165:                   else {
166:                       sb_index = 0;
167:                       end_index[read_buffer_index] = 0;
168:                       udb_serial_stop_sending_data();
169:                       return -1;
170:                   }
171:               }
172:               
173:               #else
174:               
175:               void serial_output(const char* format, ...)
176:               {
000336  FA0008     LNK #0x8
177:               	uint16_t start_index;
178:               	uint16_t remaining;
179:                   uint16_t wrote;
180:               	va_list arglist;
181:               
182:               	va_start(arglist, format);
000338  570068     SUB W14, #0x8, W0
00033A  780F00     MOV W0, [W14]
183:               
184:               	start_index = end_index;
00033C  80F4E0     MOV 0x1E9C, W0
00033E  980710     MOV W0, [W14+2]
185:               	remaining = SERIAL_BUFFER_SIZE - start_index;
000340  206001     MOV #0x600, W1
000342  90001E     MOV [W14+2], W0
000344  508000     SUB W1, W0, W0
000346  980720     MOV W0, [W14+4]
186:               
187:               	if (remaining > 1)
000348  90002E     MOV [W14+4], W0
00034A  500FE1     SUB W0, #0x1, [W15]
00034C  36000F     BRA LEU, .LSM27, .L7
188:               	{
189:               		udb_serial_stop_sending_data();
00034E  07FFED     RCALL udb_serial_stop_sending_data
190:               		wrote = vsnprintf((char*)(&serial_buffer[start_index]), (size_t)remaining, format, arglist);
000350  20F5E1     MOV #0xF5E, W1
000352  90001E     MOV [W14+2], W0
000354  408000     ADD W1, W0, W0
000356  78019E     MOV [W14], W3
000358  97B94E     MOV [W14-8], W2
00035A  9000AE     MOV [W14+4], W1
00035C  02159C     CALL _vsnprintf
00035E  000000     NOP
000360  980730     MOV W0, [W14+6]
191:               		end_index = start_index + wrote;
000362  90009E     MOV [W14+2], W1
000364  90003E     MOV [W14+6], W0
000366  408000     ADD W1, W0, W0
000368  88F4E0     MOV W0, 0x1E9C
192:               		udb_serial_start_sending_data();
00036A  07FFD8     RCALL udb_serial_start_sending_data
193:               	}
194:               	va_end(arglist);
195:               }
00036C  FA8000     ULNK
00036E  060000     RETURN
196:               
197:               void serial_output_start_end_packet(boolean isStart) {}
000370  FA0002     LNK #0x2
000372  784F00     MOV.B W0, [W14]
000374  FA8000     ULNK
000376  060000     RETURN
198:               
199:               int16_t udb_serial_callback_get_byte_to_send(void)
200:               {
000378  FA0002     LNK #0x2
201:               	uint8_t txchar = serial_buffer[ sb_index++ ];
00037A  80F4F0     MOV .L53, W0
00037C  20F5E1     MOV #0xF5E, W1
00037E  784F61     MOV.B [W1+W0], [W14]
000380  E80000     INC W0, W0
000382  88F4F0     MOV W0, .L53
202:               	if (txchar)
000384  78401E     MOV.B [W14], W0
000386  504FE0     SUB.B W0, #0x0, [W15]
000388  320003     BRA Z, .LSM34, .L11
203:               	{
204:               		return txchar;
00038A  78409E     MOV.B [W14], W1
00038C  FB8001     ZE W1, W0
00038E  370005     BRA .LSM37, .L12
205:               	}
206:               	else
207:               	{
208:               		sb_index = 0;
000390  EB0000     CLR W0
000392  88F4F0     MOV W0, .L53
209:               		end_index = 0;
000394  EB0000     CLR W0
000396  88F4E0     MOV W0, 0x1E9C
210:               	}
211:               	return -1;
000398  EB8000     SETM W0
212:               }
00039A  FA8000     ULNK
00039C  060000     RETURN
213:               #endif
214:               
215:               
216:               // Don't respond to serial input
217:               void udb_serial_callback_received_byte(uint8_t rxchar)
218:               {
00039E  FA0002     LNK #0x2
0003A0  784F00     MOV.B W0, [W14]
219:               	// Do nothing
220:               	return ;
221:               }
0003A2  FA8000     ULNK
0003A4  060000     RETURN
222:               
223:               
---  C:/Users/bill/Desktop/git_repos/git_luge/MultiRotor/rotorLib.c  ------------------------------------
1:                 #include "rotorLib.h"
2:                 #include "../libDCM/libDCM.h"
3:                 #include "../libDCM/mathlib.h"
4:                 #include "../libDCM/mathlibNAV.h"
5:                 
6:                 int16_t multiply_saturate ( int16_t x , int16_t y , int16_t maximum )
7:                 {
0064B2  FA000E     LNK #0xE
0064B4  980740     MOV W0, [W14+8]
0064B6  980751     MOV W1, [W14+10]
0064B8  980762     MOV W2, [W14+12]
8:                 	int32_t product , max_32 ;
9:                 	max_32 = (int32_t) maximum ;
0064BA  90006E     MOV [W14+12], W0
0064BC  DE80CF     ASR W0, #15, W1
0064BE  980720     MOV W0, [W14+4]
0064C0  980731     MOV W1, [W14+6]
10:                	product = __builtin_mulss( x , y ) ;
0064C2  90004E     MOV [W14+8], W0
0064C4  9000DE     MOV [W14+10], W1
0064C6  B98001     MUL.SS W0, W1, W0
0064C8  BE8F00     MOV.D W0, [W14]
11:                	if (product > max_32 ) product = maximum ;
0064CA  90002E     MOV [W14+4], W0
0064CC  9000BE     MOV [W14+6], W1
0064CE  BE011E     MOV.D [W14], W2
0064D0  510F80     SUB W2, W0, [W15]
0064D2  598F81     SUBB W3, W1, [W15]
0064D4  340003     BRA LE, .L2, .LSM4
0064D6  90006E     MOV [W14+12], W0
0064D8  DE80CF     ASR W0, #15, W1
0064DA  BE8F00     MOV.D W0, [W14]
12:                	if (product <  (-max_32 )) product =(-maximum) ;
0064DC  90002E     MOV [W14+4], W0
0064DE  9000BE     MOV [W14+6], W1
0064E0  100060     SUBR W0, #0x0, W0
0064E2  1880E0     SUBBR W1, #0x0, W1
0064E4  500FBE     SUB W0, [W14++], [W15]
0064E6  588FAE     SUBB W1, [W14--], [W15]
0064E8  340004     BRA LE, .L3, .LSM5
0064EA  90006E     MOV [W14+12], W0
0064EC  EA0000     NEG W0, W0
0064EE  DE80CF     ASR W0, #15, W1
0064F0  BE8F00     MOV.D W0, [W14]
13:                	return ((int16_t) product) ;
0064F2  78001E     MOV [W14], W0
14:                }
0064F4  FA8000     ULNK
0064F6  060000     RETURN
15:                
16:                int16_t fractional_product ( int16_t x , int16_t y )
17:                {
0064F8  FA0008     LNK #0x8
0064FA  980720     MOV W0, [W14+4]
0064FC  980731     MOV W1, [W14+6]
18:                	union longww long_accum ;
19:                	long_accum.WW = __builtin_mulss( x , y ) ;
0064FE  90002E     MOV [W14+4], W0
006500  9000BE     MOV [W14+6], W1
006502  B98001     MUL.SS W0, W1, W0
006504  BE8F00     MOV.D W0, [W14]
20:                	long_accum.WW = long_accum.WW << 2 ;
006506  BE011E     MOV.D [W14], W2
006508  DD1842     SL W3, #2, W0
00650A  DE10CE     LSR W2, #14, W1
00650C  700081     IOR W0, W1, W1
00650E  DD1042     SL W2, #2, W0
006510  BE8F00     MOV.D W0, [W14]
21:                	return long_accum._.W1 ;
006512  90001E     MOV [W14+2], W0
22:                }
006514  FA8000     ULNK
006516  060000     RETURN
23:                
24:                //	normalization algorithm
25:                //  TODO this is an older version of the algorithm, it will work well enough where it is used,
26:                //  but it should eventually be updated
27:                #define RMAX15 24576 //0b0110000000000000   // 1.5 in 2.14 format
28:                #define RMAX 16384
29:                void matrix_normalize(int16_t matrix[])
30:                //	This is the routine that maintains the orthogonality of the
31:                //	direction cosine matrix, which is expressed by the identity
32:                //	relationship that the cosine matrix multiplied by its
33:                //	transpose should equal the identity matrix.
34:                //	Small adjustments are made at each time step to assure orthogonality.
35:                {
006518  FA0018     LNK #0x18
00651A  980F30     MOV W0, [W14+22]
36:                
37:                	int norm;    // actual magnitude
38:                	int renorm;  // renormalization factor
39:                	int rbuff[9];
40:                	VectorCopy( 9 , rbuff , matrix ); // copy direction cosine matrix into buffer
00651C  470064     ADD W14, #0x4, W0
00651E  90093E     MOV [W14+22], W2
006520  780080     MOV W0, W1
006522  200090     MOV #0x9, W0
006524  020BAC     CALL _VectorCopy
006526  000000     NOP
41:                	
42:                	// Leave the bottom (tilt) row alone, it is usually the most accurate.
43:                	// Compute the first row as the cross product of second row with third row.
44:                	VectorCross(&rbuff[0], &rbuff[3] , &rbuff[6]);
006528  470064     ADD W14, #0x4, W0
00652A  40016C     ADD W0, #0xC, W2
00652C  470064     ADD W14, #0x4, W0
00652E  4000E6     ADD W0, #0x6, W1
006530  470064     ADD W14, #0x4, W0
006532  02504E     CALL VectorCross
006534  000000     NOP
45:                	// First row is now perpendicular to the second and third row.
46:                	// Compute the second row as the cross product of the third row with the first row.
47:                	VectorCross(&rbuff[3], &rbuff[6] , &rbuff[0]);
006536  470164     ADD W14, #0x4, W2
006538  470064     ADD W14, #0x4, W0
00653A  4000EC     ADD W0, #0xC, W1
00653C  470064     ADD W14, #0x4, W0
00653E  400066     ADD W0, #0x6, W0
006540  02504E     CALL VectorCross
006542  000000     NOP
48:                	// All three rows are now mutually perpendicular.
49:                
50:                	// Use a Taylor's expansion for 1/sqrt(X*X) to avoid division in the renormalization
51:                
52:                	// rescale row1
53:                	norm = VectorPower(3, &rbuff[0]); // Scalegain of 0.5
006544  470064     ADD W14, #0x4, W0
006546  780080     MOV W0, W1
006548  200030     MOV #0x3, W0
00654A  020CD6     CALL _VectorPower
00654C  000000     NOP
00654E  780F00     MOV W0, [W14]
54:                	renorm = RMAX15 - norm;
006550  260000     MOV #0x6000, W0
006552  50001E     SUB W0, [W14], W0
006554  980710     MOV W0, [W14+2]
55:                	VectorScale(3, &rbuff[0], &rbuff[0], renorm);
006556  4700E4     ADD W14, #0x4, W1
006558  470064     ADD W14, #0x4, W0
00655A  90019E     MOV [W14+2], W3
00655C  780101     MOV W1, W2
00655E  780080     MOV W0, W1
006560  200030     MOV #0x3, W0
006562  020D0E     CALL _VectorScale
006564  000000     NOP
56:                	VectorAdd(3, &matrix[0], &rbuff[0], &rbuff[0]);
006566  4700E4     ADD W14, #0x4, W1
006568  470064     ADD W14, #0x4, W0
00656A  780181     MOV W1, W3
00656C  780100     MOV W0, W2
00656E  9008BE     MOV [W14+22], W1
006570  200030     MOV #0x3, W0
006572  020A76     CALL _VectorAdd
006574  000000     NOP
57:                	// rescale row2
58:                	norm = VectorPower(3, &rbuff[3]);
006576  470064     ADD W14, #0x4, W0
006578  400066     ADD W0, #0x6, W0
00657A  780080     MOV W0, W1
00657C  200030     MOV #0x3, W0
00657E  020CD6     CALL _VectorPower
006580  000000     NOP
006582  780F00     MOV W0, [W14]
59:                	renorm = RMAX15 - norm;
006584  260000     MOV #0x6000, W0
006586  50001E     SUB W0, [W14], W0
006588  980710     MOV W0, [W14+2]
60:                	VectorScale(3, &rbuff[3], &rbuff[3], renorm);
00658A  470064     ADD W14, #0x4, W0
00658C  4000E6     ADD W0, #0x6, W1
00658E  470064     ADD W14, #0x4, W0
006590  400066     ADD W0, #0x6, W0
006592  90019E     MOV [W14+2], W3
006594  780101     MOV W1, W2
006596  780080     MOV W0, W1
006598  200030     MOV #0x3, W0
00659A  020D0E     CALL _VectorScale
00659C  000000     NOP
61:                	VectorAdd(3, &matrix[3], &rbuff[3], &rbuff[3]);
00659E  90083E     MOV [W14+22], W0
0065A0  400066     ADD W0, #0x6, W0
0065A2  4700E4     ADD W14, #0x4, W1
0065A4  408166     ADD W1, #0x6, W2
0065A6  4700E4     ADD W14, #0x4, W1
0065A8  4080E6     ADD W1, #0x6, W1
0065AA  780182     MOV W2, W3
0065AC  780101     MOV W1, W2
0065AE  780080     MOV W0, W1
0065B0  200030     MOV #0x3, W0
0065B2  020A76     CALL _VectorAdd
0065B4  000000     NOP
62:                	// rescale row3
63:                	norm = VectorPower(3, &rbuff[6]);
0065B6  470064     ADD W14, #0x4, W0
0065B8  40006C     ADD W0, #0xC, W0
0065BA  780080     MOV W0, W1
0065BC  200030     MOV #0x3, W0
0065BE  020CD6     CALL _VectorPower
0065C0  000000     NOP
0065C2  780F00     MOV W0, [W14]
64:                	renorm = RMAX15 - norm;
0065C4  260000     MOV #0x6000, W0
0065C6  50001E     SUB W0, [W14], W0
0065C8  980710     MOV W0, [W14+2]
65:                	VectorScale(3, &rbuff[6], &rbuff[6], renorm);
0065CA  470064     ADD W14, #0x4, W0
0065CC  4000EC     ADD W0, #0xC, W1
0065CE  470064     ADD W14, #0x4, W0
0065D0  40006C     ADD W0, #0xC, W0
0065D2  90019E     MOV [W14+2], W3
0065D4  780101     MOV W1, W2
0065D6  780080     MOV W0, W1
0065D8  200030     MOV #0x3, W0
0065DA  020D0E     CALL _VectorScale
0065DC  000000     NOP
66:                	VectorAdd(3, &matrix[6], &rbuff[6], &rbuff[6]);
0065DE  90083E     MOV [W14+22], W0
0065E0  40006C     ADD W0, #0xC, W0
0065E2  4700E4     ADD W14, #0x4, W1
0065E4  40816C     ADD W1, #0xC, W2
0065E6  4700E4     ADD W14, #0x4, W1
0065E8  4080EC     ADD W1, #0xC, W1
0065EA  780182     MOV W2, W3
0065EC  780101     MOV W1, W2
0065EE  780080     MOV W0, W1
0065F0  200030     MOV #0x3, W0
0065F2  020A76     CALL _VectorAdd
0065F4  000000     NOP
67:                }
0065F6  FA8000     ULNK
0065F8  060000     RETURN
68:                
69:                
70:                void MatrixRotate( int16_t matrix[] , int16_t angle[] )
71:                {
0065FA  FA002E     LNK #0x2E
0065FC  981750     MOV W0, [W14+42]
0065FE  981761     MOV W1, [W14+44]
72:                	int rup[9] ;
73:                	int rbuff[9] ;
74:                	unsigned long thetaSquare ;
75:                	unsigned nonlinearAdjust ;
76:                	// diagonal elements of the update matrix:
77:                	rup[0] = rup[4] = rup[8]= RMAX ;
006600  470066     ADD W14, #0x6, W0
006602  240001     MOV #0x4000, W1
006604  980801     MOV W1, [W0+16]
006606  470066     ADD W14, #0x6, W0
006608  900880     MOV [W0+16], W1
00660A  470066     ADD W14, #0x6, W0
00660C  980041     MOV W1, [W0+8]
00660E  470066     ADD W14, #0x6, W0
006610  9000C0     MOV [W0+8], W1
006612  470066     ADD W14, #0x6, W0
006614  780801     MOV W1, [W0]
78:                
79:                	// compute the square of rotation
80:                
81:                	thetaSquare = 	__builtin_mulss ( angle[0] , angle[0] ) +
006616  90106E     MOV [W14+44], W0
006618  780090     MOV [W0], W1
00661A  90106E     MOV [W14+44], W0
00661C  780010     MOV [W0], W0
00661E  B98101     MUL.SS W0, W1, W2
00662E  400102     ADD W0, W2, W2
006630  488183     ADDC W1, W3, W3
006644  BE8F00     MOV.D W0, [W14]
82:                					__builtin_mulss ( angle[1] , angle[1] ) +
006620  90106E     MOV [W14+44], W0
006622  E88000     INC2 W0, W0
006624  780090     MOV [W0], W1
006626  90106E     MOV [W14+44], W0
006628  E88000     INC2 W0, W0
00662A  780010     MOV [W0], W0
00662C  B98001     MUL.SS W0, W1, W0
006640  400002     ADD W0, W2, W0
006642  488083     ADDC W1, W3, W1
83:                					__builtin_mulss ( angle[2] , angle[2] ) ;
006632  90106E     MOV [W14+44], W0
006634  400064     ADD W0, #0x4, W0
006636  780090     MOV [W0], W1
006638  90106E     MOV [W14+44], W0
00663A  400064     ADD W0, #0x4, W0
00663C  780010     MOV [W0], W0
00663E  B98001     MUL.SS W0, W1, W0
84:                
85:                	// adjust gain by rotation_squared divided by 3
86:                
87:                	nonlinearAdjust = RMAX + ((unsigned int ) ( thetaSquare >>14 ))/3 ;	
006646  BE001E     MOV.D [W14], W0
006648  DD0942     SL W1, #2, W2
00664A  DE004E     LSR W0, #14, W0
00664C  710000     IOR W2, W0, W0
00664E  DE08CE     LSR W1, #14, W1
006650  780080     MOV W0, W1
006652  200030     MOV #0x3, W0
006654  780180     MOV W0, W3
006656  090011     REPEAT #0x11
006658  D88083     DIV.UW W1, W3
00665A  780080     MOV W0, W1
00665C  240000     MOV #0x4000, W0
00665E  408000     ADD W1, W0, W0
006660  980720     MOV W0, [W14+4]
88:                
89:                	angle[0] = __builtin_mulsu ( angle[0] , nonlinearAdjust )>>14 ;
006662  90106E     MOV [W14+44], W0
006664  780010     MOV [W0], W0
006666  9000AE     MOV [W14+4], W1
006668  B90001     MUL.SU W0, W1, W0
00666A  DD0942     SL W1, #2, W2
00666C  DE004E     LSR W0, #14, W0
00666E  710000     IOR W2, W0, W0
006670  DE88CE     ASR W1, #14, W1
006672  780080     MOV W0, W1
006674  90106E     MOV [W14+44], W0
006676  780801     MOV W1, [W0]
90:                	angle[1] = __builtin_mulsu ( angle[1] , nonlinearAdjust )>>14 ;
006678  90106E     MOV [W14+44], W0
00667A  E88100     INC2 W0, W2
00667C  90106E     MOV [W14+44], W0
00667E  E88000     INC2 W0, W0
006680  780010     MOV [W0], W0
006682  9000AE     MOV [W14+4], W1
006684  B90001     MUL.SU W0, W1, W0
006686  DD09C2     SL W1, #2, W3
006688  DE004E     LSR W0, #14, W0
00668A  718000     IOR W3, W0, W0
00668C  DE88CE     ASR W1, #14, W1
00668E  780000     MOV W0, W0
006690  780900     MOV W0, [W2]
91:                	angle[2] = __builtin_mulsu ( angle[2] , nonlinearAdjust )>>14 ;
006692  90106E     MOV [W14+44], W0
006694  400164     ADD W0, #0x4, W2
006696  90106E     MOV [W14+44], W0
006698  400064     ADD W0, #0x4, W0
00669A  780010     MOV [W0], W0
00669C  9000AE     MOV [W14+4], W1
00669E  B90001     MUL.SU W0, W1, W0
0066A0  DD09C2     SL W1, #2, W3
0066A2  DE004E     LSR W0, #14, W0
0066A4  718000     IOR W3, W0, W0
0066A6  DE88CE     ASR W1, #14, W1
0066A8  780000     MOV W0, W0
0066AA  780900     MOV W0, [W2]
92:                
93:                	//	construct the off-diagonal elements of the update matrix:
94:                	rup[1] = -angle[2] ;
0066AC  90106E     MOV [W14+44], W0
0066AE  400064     ADD W0, #0x4, W0
0066B0  780010     MOV [W0], W0
0066B2  EA0080     NEG W0, W1
0066B4  470066     ADD W14, #0x6, W0
0066B6  980011     MOV W1, [W0+2]
95:                	rup[2] =  angle[1] ;
0066B8  90106E     MOV [W14+44], W0
0066BA  E88000     INC2 W0, W0
0066BC  780090     MOV [W0], W1
0066BE  470066     ADD W14, #0x6, W0
0066C0  980021     MOV W1, [W0+4]
96:                	rup[3] =  angle[2] ;
0066C2  90106E     MOV [W14+44], W0
0066C4  400064     ADD W0, #0x4, W0
0066C6  780090     MOV [W0], W1
0066C8  470066     ADD W14, #0x6, W0
0066CA  980031     MOV W1, [W0+6]
97:                	rup[5] = -angle[0] ;
0066CC  90106E     MOV [W14+44], W0
0066CE  780010     MOV [W0], W0
0066D0  EA0080     NEG W0, W1
0066D2  470066     ADD W14, #0x6, W0
0066D4  980051     MOV W1, [W0+10]
98:                	rup[6] = -angle[1] ;
0066D6  90106E     MOV [W14+44], W0
0066D8  E88000     INC2 W0, W0
0066DA  780010     MOV [W0], W0
0066DC  EA0080     NEG W0, W1
0066DE  470066     ADD W14, #0x6, W0
0066E0  980061     MOV W1, [W0+12]
99:                	rup[7] =  angle[0] ;
0066E2  90106E     MOV [W14+44], W0
0066E4  780090     MOV [W0], W1
0066E6  470066     ADD W14, #0x6, W0
0066E8  980071     MOV W1, [W0+14]
100:               
101:               	//	matrix multiply the rmatrix by the update matrix
102:               	MatrixMultiply( 3 , 3 , 3 , rbuff , matrix , rup ) ;
0066EA  4700E6     ADD W14, #0x6, W1
0066EC  470078     ADD W14, #0x18, W0
0066EE  780281     MOV W1, W5
0066F0  90125E     MOV [W14+42], W4
0066F2  780180     MOV W0, W3
0066F4  200032     MOV #0x3, W2
0066F6  200031     MOV #0x3, W1
0066F8  200030     MOV #0x3, W0
0066FA  02092A     CALL _MatrixMultiply
0066FC  000000     NOP
103:               	//	multiply by 2 and copy back from rbuff to rmat:
104:               	MatrixAdd( 3 , 3 , matrix , rbuff , rbuff ) ; 
0066FE  4700F8     ADD W14, #0x18, W1
006700  470078     ADD W14, #0x18, W0
006702  780201     MOV W1, W4
006704  780180     MOV W0, W3
006706  90115E     MOV [W14+42], W2
006708  200031     MOV #0x3, W1
00670A  200030     MOV #0x3, W0
00670C  0208EA     CALL _MatrixAdd
00670E  000000     NOP
105:               	return ;
106:               }
006710  FA8000     ULNK
006712  060000     RETURN
107:               
108:               extern int16_t rmat[];
109:               int16_t yaw_rmat[9];
110:               void initialize_yaw_rmat(void)
111:               {
006714  FA0004     LNK #0x4
112:               	int16_t sine , cosine ;
113:               	cosine = __builtin_divsd(__builtin_mulsu(rmat[0]/2 + rmat[4]/2, RMAX),RMAX/2+rmat[8]/2);
006716  80D2A1     MOV 0x1A54, W1
006718  200020     MOV #0x2, W0
00671A  780100     MOV W0, W2
00671C  090011     REPEAT #0x11
00671E  D80082     DIV.SW W1, W2
006720  780080     MOV W0, W1
006722  220000     MOV #0x2000, W0
006724  408100     ADD W1, W0, W2
006726  80D221     MOV 0x1A44, W1
006728  200020     MOV #0x2, W0
00672A  780180     MOV W0, W3
00672C  090011     REPEAT #0x11
00672E  D80083     DIV.SW W1, W3
006730  780080     MOV W0, W1
006732  80D263     MOV 0x1A4C, W3
006734  200020     MOV #0x2, W0
006736  780200     MOV W0, W4
006738  781F81     MOV W1, [W15++]
00673A  090011     REPEAT #0x11
00673C  D80184     DIV.SW W3, W4
00673E  780181     MOV W1, W3
006740  7800CF     MOV [--W15], W1
006742  408000     ADD W1, W0, W0
006744  240001     MOV #0x4000, W1
006746  B90001     MUL.SU W0, W1, W0
006748  781F81     MOV W1, [W15++]
00674A  090011     REPEAT #0x11
00674C  D80842     DIV.SD W0, W2
00674E  7800CF     MOV [--W15], W1
006750  780F00     MOV W0, [W14]
114:               	sine = __builtin_divsd(__builtin_mulsu(rmat[1]/2 - rmat[3]/2, RMAX),RMAX/2+rmat[8]/2);
006752  80D2A1     MOV 0x1A54, W1
006754  200020     MOV #0x2, W0
006756  780100     MOV W0, W2
006758  090011     REPEAT #0x11
00675A  D80082     DIV.SW W1, W2
00675C  780080     MOV W0, W1
00675E  220000     MOV #0x2000, W0
006760  408100     ADD W1, W0, W2
006762  80D231     MOV .L8, W1
006764  200020     MOV #0x2, W0
006766  780180     MOV W0, W3
006768  090011     REPEAT #0x11
00676A  D80083     DIV.SW W1, W3
00676C  780080     MOV W0, W1
00676E  80D253     MOV 0x1A4A, W3
006770  200020     MOV #0x2, W0
006772  780200     MOV W0, W4
006774  781F81     MOV W1, [W15++]
006776  090011     REPEAT #0x11
006778  D80184     DIV.SW W3, W4
00677A  780181     MOV W1, W3
00677C  7800CF     MOV [--W15], W1
00677E  508000     SUB W1, W0, W0
006780  240001     MOV #0x4000, W1
006782  B90001     MUL.SU W0, W1, W0
006784  781F81     MOV W1, [W15++]
006786  090011     REPEAT #0x11
006788  D80842     DIV.SD W0, W2
00678A  7800CF     MOV [--W15], W1
00678C  980710     MOV W0, [W14+2]
115:               	yaw_rmat[0]=cosine;
00678E  78001E     MOV [W14], W0
006790  8BFF60     MOV W0, yaw_rmat
116:               	yaw_rmat[4]=cosine;
006792  78011E     MOV [W14], W2
006794  8BFFA2     MOV W2, 0x7FF4
117:               	yaw_rmat[1]=sine ;
006796  90019E     MOV [W14+2], W3
006798  8BFF73     MOV W3, 0x7FEE
118:               	yaw_rmat[3]=-sine ;
00679A  90001E     MOV [W14+2], W0
00679C  EA0000     NEG W0, W0
00679E  8BFF90     MOV W0, 0x7FF2
119:               	yaw_rmat[2]= 0 ;
0067A0  EB0000     CLR W0
0067A2  8BFF80     MOV W0, .L10
120:               	yaw_rmat[5]= 0 ;
0067A4  EB0000     CLR W0
0067A6  8BFFB0     MOV W0, 0x7FF6
121:               	yaw_rmat[6]= 0 ;
0067A8  EB0000     CLR W0
0067AA  8BFFC0     MOV W0, 0x7FF8
122:               	yaw_rmat[7]= 0 ;
0067AC  EB0000     CLR W0
0067AE  8BFFD0     MOV W0, .LSM24
123:               	yaw_rmat[8]= RMAX ;
0067B0  240000     MOV #0x4000, W0
0067B2  8BFFE0     MOV W0, 0x7FFC
124:               }
0067B4  FA8000     ULNK
0067B6  060000     RETURN
---  C:/Users/bill/Desktop/git_repos/git_luge/MultiRotor/main.c  ----------------------------------------
1:                 // This file is part of the MatrixPilotQuad firmware.
2:                 //
3:                 //    http://code.google.com/p/gentlenav/
4:                 //
5:                 // Copyright 2009-2011 MatrixPilot Team
6:                 // See the AUTHORS.TXT file for a list of authors of MatrixPilot.
7:                 //
8:                 // MatrixPilot is free software: you can redistribute it and/or modify
9:                 // it under the terms of the GNU General Public License as published by
10:                // the Free Software Foundation, either version 3 of the License, or
11:                // (at your option) any later version.
12:                //
13:                // MatrixPilot is distributed in the hope that it will be useful,
14:                // but WITHOUT ANY WARRANTY; without even the implied warranty of
15:                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:                // GNU General Public License for more details.
17:                //
18:                // You should have received a copy of the GNU General Public License
19:                // along with MatrixPilot.  If not, see <http://www.gnu.org/licenses/>.
20:                
21:                
22:                #include "../libDCM/libDCM.h"
23:                #include "../libDCM/libDCM_defines.h"
24:                #include "../libDCM/mathlibNAV.h"
25:                #include "../libDCM/gpsData.h"
26:                #include "../libDCM/gpsParseCommon.h"
27:                #include "../libDCM/rmat.h"
28:                #include "../libUDB/heartbeat.h"
29:                #include "../libUDB/serialIO.h"
30:                #include "../libUDB/servoOut.h"
31:                #include "../libUDB/ADchannel.h"
32:                #include <math.h>
33:                
34:                // Used for serial debug output
35:                #include <stdio.h>
36:                
37:                extern boolean differential_gps(void) ;
38:                extern boolean hasWrittenHeader ;
39:                extern boolean start_log;
40:                extern boolean logging_on;
41:                
42:                boolean didCalibrate = 0 ;
43:                
44:                void send_debug_line( int8_t differential_flag , uint16_t sats , int32_t lat , int32_t lon , int32_t alt , int16_t sog , int16_t  cog , int16_t climb ) ;
45:                void send_imu_data(void);
46:                void motorCntrl( void ) ;
47:                void offsets_init(void) ;
48:                
49:                const int max_tilt = 0 ;  // maximum tilt in byte cicular
50:                int commanded_tilt_gain ;
51:                
52:                int main (void)
53:                {
006A90  FA0000     LNK #0x0
54:                //	offsets_init();
55:                	// Set up the libraries
56:                	if ( GPS_TYPE != GPS_NONE)
57:                	{
58:                		gps_init() ;
59:                	}
60:                	offsets_init() ;
006A92  02741C     CALL offsets_init
006A94  000000     NOP
61:                	mcu_init() ;
006A96  027E26     CALL mcu_init
006A98  000000     NOP
62:                	udb_init() ;
006A9A  02803E     CALL udb_init
006A9C  000000     NOP
63:                	dcm_init() ;
006A9E  02742E     CALL dcm_init
006AA0  000000     NOP
64:                	
65:                #ifdef USE_PACKETIZED_TELEMERTY
66:                	udb_serial_set_rate(460800) ;
67:                    start_log = 0;
68:                    hasWrittenHeader = 1;
69:                    logging_on = 0 ;
70:                #else
71:                	udb_serial_set_rate(57600) ;
006AA2  2E1000     MOV #0xE100, W0
006AA4  200001     MOV #0x0, W1
006AA6  026EE8     CALL udb_serial_set_rate
006AA8  000000     NOP
72:                #endif
73:                    
74:                	LED_GREEN = LED_OFF ;
006AAA  A842DC     BSET LATE, #2
75:                	LED_RED = LED_OFF ;
006AAC  A822DC     BSET LATE, #1
76:                
77:                #if (CONSOLE_UART != 2)
78:                	udb_init_USART(&udb_serial_callback_get_byte_to_send, &udb_serial_callback_received_byte);
006AAE  2039E1     MOV #0x39E, W1
006AB0  203780     MOV #0x378, W0
006AB2  026E7A     CALL udb_init_USART
006AB4  000000     NOP
79:                #endif
80:                	commanded_tilt_gain = sine ( max_tilt ) / 1000 ;
006AB6  85A5A0     MOV 0xB4B4, W0
006AB8  784000     MOV.B W0, W0
006ABA  0248B4     CALL sine
006ABC  000000     NOP
006ABE  203E81     MOV #0x3E8, W1
006AC0  780101     MOV W1, W2
006AC2  090011     REPEAT #0x11
006AC4  D80002     DIV.SW W0, W2
006AC6  88F370     MOV W0, commanded_tilt_gain
81:                	
82:                #ifdef ENABLE_ESP32
83:                    // Pull ESP32 Enable pin high
84:                    _TRISD15 = 0;
85:                    _LATD15 = 1;
86:                #endif
87:                    
88:                	// Start it up!
89:                	while(1)
90:                	{
91:                		udb_run() ; 
006AC8  028064     CALL udb_run
006ACA  000000     NOP
92:                	}
006ACC  37FFFD     BRA .L2, .LSM10
93:                	
94:                	return 0 ;
95:                }
96:                
97:                void align_rmat_to_mag(void);
98:                // Called every 1/2 second at high priority
99:                void udb_background_callback_periodic(void)
100:               {
006ACE  FA0006     LNK #0x6
101:               	int gplane[3];
102:               	if (!didCalibrate)
006AD0  21E540     MOV #0x1E54, W0
006AD2  784010     MOV.B [W0], W0
006AD4  504FE0     SUB.B W0, #0x0, [W15]
006AD6  3A0025     BRA NZ, .L3, .LSM21
103:               	{
104:               		if (udb_flags._.radio_on && dcm_flags._.calib_finished)
006AD8  80F521     MOV udb_flags, W1
006ADA  220000     MOV #0x2000, W0
006ADC  608000     AND W1, W0, W0
006ADE  500FE0     SUB W0, #0x0, [W15]
006AE0  320020     BRA Z, .L3, .LSM21
006AE2  80F2F1     MOV dcm_flags, W1
006AE4  240000     MOV #0x4000, W0
006AE6  608000     AND W1, W0, W0
006AE8  500FE0     SUB W0, #0x0, [W15]
006AEA  32001B     BRA Z, .L3, .LSM21
105:               		{
106:               			dcm_calibrate() ;	
006AEC  02750E     CALL dcm_calibrate
006AEE  000000     NOP
107:               			// record vertical
108:               			gplane[0] = XACCEL_VALUE;
006AF0  80E480     MOV 0x1C90, W0
006AF2  D18080     ASR W0, W1
006AF4  80E470     MOV 0x1C8E, W0
006AF6  D18000     ASR W0, W0
006AF8  508000     SUB W1, W0, W0
006AFA  780F00     MOV W0, [W14]
109:               			gplane[1] = YACCEL_VALUE;
006AFC  80E4C0     MOV 0x1C98, W0
006AFE  D18080     ASR W0, W1
006B00  80E4D0     MOV 0x1C9A, W0
006B02  D18000     ASR W0, W0
006B04  508000     SUB W1, W0, W0
006B06  980710     MOV W0, [W14+2]
110:               			gplane[2] = ZACCEL_VALUE;
006B08  80E510     MOV 0x1CA2, W0
006B0A  D18080     ASR W0, W1
006B0C  80E520     MOV 0x1CA4, W0
006B0E  D18000     ASR W0, W0
006B10  508000     SUB W1, W0, W0
006B12  980720     MOV W0, [W14+4]
111:               			vector3_normalize(&rmat[6],gplane);
006B14  78008E     MOV W14, W1
006B16  21A500     MOV #0x1A50, W0
006B18  024E82     CALL vector3_normalize
006B1A  000000     NOP
112:               			didCalibrate = 1 ;	
006B1C  21E541     MOV #0x1E54, W1
006B1E  B3C010     MOV.B #0x1, W0
006B20  784880     MOV.B W0, [W1]
113:               		}
114:               	}
115:               }
006B22  FA8000     ULNK
006B24  060000     RETURN
116:               
117:               void udb_heartbeat_40hz_callback(void)
118:               {
006B26  FA0000     LNK #0x0
119:               	static int count = 0;
120:               	if (++count > 20)
006B28  80F3A0     MOV _count.9282, W0
006B2A  E80000     INC W0, W0
006B2C  88F3A0     MOV W0, _count.9282
006B2E  80F3A0     MOV _count.9282, W0
006B30  500FF4     SUB W0, #0x14, [W15]
006B32  340003     BRA LE, .L5, .LSM26
121:               	{
122:               		count = 0;
006B34  EB0000     CLR W0
006B36  88F3A0     MOV W0, _count.9282
123:               		udb_background_callback_periodic();	
006B38  07FFCA     RCALL udb_background_callback_periodic
124:               	}
125:               }
006B3A  FA8000     ULNK
006B3C  060000     RETURN
126:               
127:               // Called every time we get gps data (1, 2, or 4 Hz, depending on GPS config)
128:               void dcm_callback_gps_location_updated(void)
129:               {
006B3E  FA0000     LNK #0x0
130:               	return ;
131:               }
006B40  FA8000     ULNK
006B42  060000     RETURN
132:               
133:               extern boolean origin_recorded ;
134:               extern uint16_t number_pulses ;
135:               extern uint16_t altitude ;
136:               
137:               #define DEG_PER_RAD 57.296
138:               float tilt_angle ;
139:               boolean start_log = 1 , stop_log = 0 , slide_in_progress = 0 ;
140:               uint16_t stop_count = 0 ;
141:               void update_slide_detection(void)
142:               {
006B44  FA0002     LNK #0x2
006B46  BE9F88     MOV.D W8, [W15++]
006B48  BE9F8A     MOV.D W10, [W15++]
006B4A  BE9F8C     MOV.D W12, [W15++]
143:               	int16_t tilt_angle_int ;
144:               	tilt_angle = DEG_PER_RAD*atan2f(sqrtf(((float)aero_force_filtered[0]._.W1)*((float)aero_force_filtered[0]._.W1)+((float)aero_force_filtered[1]._.W1)*((float)aero_force_filtered[1]._.W1)),-(float)aero_force_filtered[2]._.W1);
006B4C  80CC00     MOV 0x1980, W0
006B4E  DE80CF     ASR W0, #15, W1
006B50  021092     CALL ___floatsisf
006B52  000000     NOP
006B54  BE0400     MOV.D W0, W8
006B56  A2F009     BTG W9, #15
006B58  80CBC0     MOV .L68, W0
006B5A  DE80CF     ASR W0, #15, W1
006B5C  021092     CALL ___floatsisf
006B5E  000000     NOP
006B60  BE0500     MOV.D W0, W10
006B62  80CBC0     MOV .L68, W0
006B64  DE80CF     ASR W0, #15, W1
006B66  021092     CALL ___floatsisf
006B68  000000     NOP
006B6A  BE0100     MOV.D W0, W2
006B6C  BE000A     MOV.D W10, W0
006B6E  0211B2     CALL ___mulsf3
006B70  000000     NOP
006B72  BE0500     MOV.D W0, W10
006B74  80CBE0     MOV 0x197C, W0
006B76  DE80CF     ASR W0, #15, W1
006B78  021092     CALL ___floatsisf
006B7A  000000     NOP
006B7C  BE0600     MOV.D W0, W12
006B7E  80CBE0     MOV 0x197C, W0
006B80  DE80CF     ASR W0, #15, W1
006B82  021092     CALL ___floatsisf
006B84  000000     NOP
006B86  BE0100     MOV.D W0, W2
006B88  BE000C     MOV.D W12, W0
006B8A  0211B2     CALL ___mulsf3
006B8C  000000     NOP
006B8E  BE0100     MOV.D W0, W2
006B90  BE000A     MOV.D W10, W0
006B92  020DE8     CALL ___addsf3
006B94  000000     NOP
006B96  02121A     CALL _sqrtf
006B98  000000     NOP
006B9A  BE0108     MOV.D W8, W2
006B9C  020EA2     CALL _atan2f
006B9E  000000     NOP
006BA0  22F1B2     MOV #0x2F1B, W2
006BA2  242653     MOV #0x4265, W3
006BA4  0211B2     CALL ___mulsf3
006BA6  000000     NOP
006BA8  88F380     MOV W0, tilt_angle
006BAA  88F391     MOV W1, 0x1E72
145:               	tilt_angle_int = (int16_t)tilt_angle ;
006BAC  80F380     MOV tilt_angle, W0
006BAE  80F391     MOV 0x1E72, W1
006BB0  021050     CALL ___fixsfsi
006BB2  000000     NOP
006BB4  780F00     MOV W0, [W14]
146:               	if ( slide_in_progress == 1)
006BB6  21E570     MOV #0x1E57, W0
006BB8  784010     MOV.B [W0], W0
006BBA  504FE1     SUB.B W0, #0x1, [W15]
006BBC  3A0036     BRA NZ, .L9, .LSM45
147:               		{
148:               		if ( tilt_angle_int > TILT_STOP )
006BBE  2003C0     MOV #0x3C, W0
006BC0  78009E     MOV [W14], W1
006BC2  508F80     SUB W1, W0, [W15]
006BC4  340020     BRA LE, .L10, .LSM42
149:               			if ( stop_count == SLIDE_DET_HZ*TILT_STOP_DELAY)
006BC6  80F2C1     MOV 0x1E58, W1
006BC8  207D00     MOV #0x7D0, W0
006BCA  508F80     SUB W1, W0, [W15]
006BCC  3A0016     BRA NZ, .L11, .LSM39
150:               			{
151:               				stop_log = 1 ;
006BCE  21E561     MOV #0x1E56, W1
006BD0  B3C010     MOV.B #0x1, W0
006BD2  784880     MOV.B W0, [W1]
152:               				slide_in_progress = 0 ;
006BD4  21E571     MOV #0x1E57, W1
006BD6  EB4000     CLR.B W0
006BD8  784880     MOV.B W0, [W1]
153:               				LED_RED = LED_OFF ;
006BDA  A822DC     BSET LATE, #1
154:               				udb_led_toggle(LED_GREEN);
006BDC  8016E0     MOV LATE, W0
006BDE  6000E4     AND W0, #0x4, W1
006BE0  B3C010     MOV.B #0x1, W0
006BE2  508FE0     SUB W1, #0x0, [W15]
006BE4  320001     BRA Z, .L12
006BE6  EB4000     CLR.B W0
006BE8  FB8000     ZE W0, W0
006BEA  600061     AND W0, #0x1, W0
006BEC  DD0042     SL W0, #2, W0
006BEE  8016E2     MOV LATE, W2
006BF0  2FFFB1     MOV #0xFFFB, W1
006BF2  610081     AND W2, W1, W1
006BF4  708000     IOR W1, W0, W0
006BF6  8816E0     MOV W0, LATE
006BF8  370042     BRA .L8, .LSM53
155:               			}
156:               			else
157:               			{
158:               				stop_count ++ ;
006BFA  80F2C0     MOV 0x1E58, W0
006BFC  E80000     INC W0, W0
006BFE  88F2C0     MOV W0, 0x1E58
159:               				LED_RED = LED_ON ;
006C00  A922DC     BCLR LATE, #1
160:               				LED_GREEN = LED_OFF ;
006C02  A842DC     BSET LATE, #2
006C04  37003C     BRA .L8, .LSM53
161:               			}
162:               		else
163:               			{
164:               				stop_count = 0 ;
006C06  EB0000     CLR W0
006C08  88F2C0     MOV W0, 0x1E58
165:               				udb_led_toggle(LED_RED);
006C0A  8016E0     MOV LATE, W0
006C0C  6000E2     AND W0, #0x2, W1
006C0E  B3C010     MOV.B #0x1, W0
006C10  508FE0     SUB W1, #0x0, [W15]
006C12  320001     BRA Z, .L14
006C14  EB4000     CLR.B W0
006C16  FB8000     ZE W0, W0
006C18  600061     AND W0, #0x1, W0
006C1A  400000     ADD W0, W0, W0
006C1C  8016E2     MOV LATE, W2
006C1E  2FFFD1     MOV #0xFFFD, W1
006C20  610081     AND W2, W1, W1
006C22  708000     IOR W1, W0, W0
006C24  8816E0     MOV W0, LATE
166:               				LED_GREEN = LED_OFF ;
006C26  A842DC     BSET LATE, #2
006C28  37002A     BRA .L8, .LSM53
167:               			}
168:               		}
169:               	else
170:               		{
171:               		if ( tilt_angle_int < TILT_START )
006C2A  78001E     MOV [W14], W0
006C2C  500FEE     SUB W0, #0xE, [W15]
006C2E  3C0018     BRA GT, .L15, .LSM51
172:               			{
173:               				stop_count = 0 ;
006C30  EB0000     CLR W0
006C32  88F2C0     MOV W0, 0x1E58
174:               				start_log = 1 ;
006C34  21E551     MOV #0x1E55, W1
006C36  B3C010     MOV.B #0x1, W0
006C38  784880     MOV.B W0, [W1]
175:               				slide_in_progress = 1 ;
006C3A  21E571     MOV #0x1E57, W1
006C3C  B3C010     MOV.B #0x1, W0
006C3E  784880     MOV.B W0, [W1]
176:               				udb_led_toggle(LED_RED);
006C40  8016E0     MOV LATE, W0
006C42  6000E2     AND W0, #0x2, W1
006C44  B3C010     MOV.B #0x1, W0
006C46  508FE0     SUB W1, #0x0, [W15]
006C48  320001     BRA Z, .L16
006C4A  EB4000     CLR.B W0
006C4C  FB8000     ZE W0, W0
006C4E  600061     AND W0, #0x1, W0
006C50  400000     ADD W0, W0, W0
006C52  8016E2     MOV LATE, W2
006C54  2FFFD1     MOV #0xFFFD, W1
006C56  610081     AND W2, W1, W1
006C58  708000     IOR W1, W0, W0
006C5A  8816E0     MOV W0, LATE
177:               				LED_GREEN = LED_OFF ;
006C5C  A842DC     BSET LATE, #2
006C5E  37000F     BRA .L8, .LSM53
178:               			}
179:               		else
180:               			{
181:               				LED_RED = LED_OFF ;
006C60  A822DC     BSET LATE, #1
182:               				udb_led_toggle(LED_GREEN);
006C62  8016E0     MOV LATE, W0
006C64  6000E4     AND W0, #0x4, W1
006C66  B3C010     MOV.B #0x1, W0
006C68  508FE0     SUB W1, #0x0, [W15]
006C6A  320001     BRA Z, .L17
006C6C  EB4000     CLR.B W0
006C6E  FB8000     ZE W0, W0
006C70  600061     AND W0, #0x1, W0
006C72  DD0042     SL W0, #2, W0
006C74  8016E2     MOV LATE, W2
006C76  2FFFB1     MOV #0xFFFB, W1
006C78  610081     AND W2, W1, W1
006C7A  708000     IOR W1, W0, W0
006C7C  8816E0     MOV W0, LATE
183:               			}
184:               		}
185:               }
006C7E  BE064F     MOV.D [--W15], W12
006C80  BE054F     MOV.D [--W15], W10
006C82  BE044F     MOV.D [--W15], W8
006C84  FA8000     ULNK
006C86  060000     RETURN
186:               
187:               // Called at heartbeat Hz, before sending servo pulses
188:               extern boolean log_residuals ;
189:               extern void send_residual_data(void) ;
190:               boolean stop_residuals = 1 ;
191:               boolean start_residuals = 0 ;
192:               extern float yaw_previous , yaw_angle , heading_previous ;
193:               extern void compute_euler(void);
194:               uint16_t residual_log_counter = 0 ;
195:               void dcm_heartbeat_callback(void)
196:               {
006C88  FA0000     LNK #0x0
197:               	if ( didCalibrate )
006C8A  21E540     MOV #0x1E54, W0
006C8C  784010     MOV.B [W0], W0
006C8E  504FE0     SUB.B W0, #0x0, [W15]
006C90  320046     BRA Z, .L18, .LSM75
198:               	{
199:               #ifndef BUILD_OFFSET_TABLE
200:               		update_slide_detection();
006C92  07FF58     RCALL update_slide_detection
201:               #endif // BUILD_OFFSET_TABLE
202:               		if (!hasWrittenHeader)
006C94  21E360     MOV #0x1E36, W0
006C96  784010     MOV.B [W0], W0
006C98  504FE0     SUB.B W0, #0x0, [W15]
006C9A  3A000B     BRA NZ, .L20, .LSM60
203:               		{
204:               			if ((udb_heartbeat_counter % (HEARTBEAT_HZ/HEADER_HZ)) == 0)
006C9C  80F401     MOV .L47, W1
006C9E  2000A0     MOV #0xA, W0
006CA0  780100     MOV W0, W2
006CA2  090011     REPEAT #0x11
006CA4  D88082     DIV.UW W1, W2
006CA6  FD0080     EXCH W0, W1
006CA8  500FE0     SUB W0, #0x0, [W15]
006CAA  3A0023     BRA NZ, .L21, .LSM70
205:               			{
206:               				send_imu_data();
006CAC  026846     CALL send_imu_data
006CAE  000000     NOP
006CB0  370020     BRA .L21, .LSM70
207:               			}
208:               		}
209:               		else
210:               		{
211:               			if ((udb_heartbeat_counter % (HEARTBEAT_HZ/SLIDE_DET_HZ)) == 0)
212:               			{
213:               #ifndef BUILD_OFFSET_TABLE
214:               				if (start_log ==1) 
006CB2  21E550     MOV #0x1E55, W0
006CB4  784010     MOV.B [W0], W0
006CB6  504FE1     SUB.B W0, #0x1, [W15]
006CB8  3A000C     BRA NZ, .L22, .LSM65
215:               				{
216:               					compute_euler();
006CBA  023C74     CALL compute_euler
006CBC  000000     NOP
217:               					yaw_previous = yaw_angle ;
006CBE  80CDE0     MOV yaw_angle, W0
006CC0  80CDF1     MOV 0x19BE, W1
006CC2  88CB00     MOV W0, yaw_previous
006CC4  88CB11     MOV W1, 0x1962
218:               					heading_previous = 0.0 ;
006CC6  B80060     MUL.UU W0, #0, W0
006CC8  88CB40     MOV W0, heading_previous
006CCA  88CB51     MOV W1, 0x196A
219:               					log_residuals = 0 ;
006CCC  21E3F1     MOV #0x1E3F, W1
006CCE  EB4000     CLR.B W0
006CD0  784880     MOV.B W0, [W1]
220:               				}
221:               				if (stop_log ==1 ) 
006CD2  21E560     MOV #0x1E56, W0
006CD4  784010     MOV.B [W0], W0
006CD6  504FE1     SUB.B W0, #0x1, [W15]
006CD8  3A0006     BRA NZ, .L23, .LSM68
222:               				{ 
223:               					start_residuals = 1 ;
006CDA  21E5B1     MOV #0x1E5B, W1
006CDC  B3C010     MOV.B #0x1, W0
006CDE  784880     MOV.B W0, [W1]
224:               					log_residuals = 1 ;
006CE0  21E3F1     MOV #0x1E3F, W1
006CE2  B3C010     MOV.B #0x1, W0
006CE4  784880     MOV.B W0, [W1]
225:               				}
226:               #endif
227:               			}
228:               			
229:               			{
230:               				if ((udb_heartbeat_counter % (HEARTBEAT_HZ/LOGGER_HZ)) == 0)
006CE6  80F400     MOV .L47, W0
006CE8  600063     AND W0, #0x3, W0
006CEA  500FE0     SUB W0, #0x0, [W15]
006CEC  3A0002     BRA NZ, .L21, .LSM70
231:               				{
232:               					send_imu_data();
006CEE  026846     CALL send_imu_data
006CF0  000000     NOP
233:               				}
234:               			}
235:               		}
236:               	//
237:               #ifdef LOG_RESIDUALS
238:               		if (log_residuals == 1)
006CF2  21E3F0     MOV #0x1E3F, W0
006CF4  784010     MOV.B [W0], W0
006CF6  504FE1     SUB.B W0, #0x1, [W15]
006CF8  3A0012     BRA NZ, .L18, .LSM75
239:               		{
240:               			if ((udb_heartbeat_counter % HEARTBEAT_HZ )== 0) residual_log_counter ++ ;
006CFA  80F401     MOV .L47, W1
006CFC  200C80     MOV #0xC8, W0
006CFE  780100     MOV W0, W2
006D00  090011     REPEAT #0x11
006D02  D88082     DIV.UW W1, W2
006D04  FD0080     EXCH W0, W1
006D06  500FE0     SUB W0, #0x0, [W15]
006D08  3A0003     BRA NZ, .L24, .LSM72
006D0A  80F2E0     MOV 0x1E5C, W0
006D0C  E80000     INC W0, W0
006D0E  88F2E0     MOV W0, 0x1E5C
241:               			if ( residual_log_counter == RESIDUAL_LOG_PERIOD ) 
006D10  80F2E0     MOV 0x1E5C, W0
006D12  500FE1     SUB W0, #0x1, [W15]
006D14  3A0004     BRA NZ, .L18, .LSM75
242:               			{
243:               				residual_log_counter = 0 ;
006D16  EB0000     CLR W0
006D18  88F2E0     MOV W0, 0x1E5C
244:               				send_residual_data();
006D1A  0267B8     CALL send_residual_data
006D1C  000000     NOP
245:               			}
246:               		}
247:               #endif // LOG_RESIDUALS
248:               	}
249:               	return ;
250:               }
006D1E  FA8000     ULNK
006D20  060000     RETURN
251:               
252:               
253:               void udb_callback_radio_did_turn_off( void ) {}
006D22  FA0000     LNK #0x0
006D24  FA8000     ULNK
006D26  060000     RETURN
